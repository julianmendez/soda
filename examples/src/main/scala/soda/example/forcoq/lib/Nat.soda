package soda.example.forcoq.lib


class nat = {

  has add (a: nat): nat

  has mul (a: nat): nat
}

class O ()
  extends nat = {

  add (a: nat): nat = a

  mul (a: nat): nat = this
}

class S (k: nat)
  extends nat = {

  t = IntNat_()

  add (a: nat): nat =
    t.from_non_negative( (t.to_Int(k) + 1) + t.to_Int(a) )

  mul (a: nat): nat =
    t.from_non_negative( (t.to_Int(k) + 1) * t.to_Int(a) )
}

class IntNat = {
  + soda.lib.OptionSD
  + soda.lib.NoneSD_
  + soda.lib.SomeSD_
  + soda.lib.Recursion_

  from_Int (a: Int): OptionSD[nat] =
    if a < 0
    then NoneSD_[nat] ()
    else SomeSD_[nat] (from_non_negative (a))

  from_non_negative (a: Int): nat =
    let
      @tailrec
      _from_non_negative (a: Int, b: nat): nat =
        if a <= 0
        then b
        else _from_non_negative(a - 1, S (b))

    in  _from_non_negative (a, O())

  to_Int (a: nat): Int =
    match a {
      | O() -> 0
      | S (k) -> 1 + to_Int (k)
    }
}

class IntNat_()
  extends IntNat

