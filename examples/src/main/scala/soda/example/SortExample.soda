package soda.translator.example


* SortExample = {

  has is_sorted(sequence: Seq[Int]): Boolean
}

* SortExampleWithAt
  extends SortExample = {

  is_sorted(sequence: Seq[Int]): Boolean =
    sequence
      .indices
      .filter(index -> index > 0)
      .forall(index -> sequence(index - 1) <= sequence(index))
}

* SortExampleWithAt_() extends SortExampleWithAt

* SortExampleWithZip
  extends SortExample = {

  is_sorted(sequence: Seq[Int]): Boolean =
    sequence
      .zip(sequence.tail)
      .forall(pair -> (pair._1 <= pair._2))
}

* SortExampleWithZip_() extends SortExampleWithZip

* SortAlgorithmExample = {

  has sort(sequence: Seq[Int]): Seq[Int]
}

* SortAlgorithmExampleWithFold
  extends SortAlgorithmExample = {
  + soda.lib.Rec

  sort(sequence: Seq[Int]): Seq[Int] =
    if sequence.length < 2
    then sequence
    else Rec().fold(sequence, _initial_value, _next_value_function)

  _initial_value = Seq[Int]()

  _next_value_function(current_sequence: Seq[Int], elem: Int): Seq[Int] =
    insert_sorted(current_sequence, elem)

  insert_sorted(sequence: Seq[Int], element: Int): Seq[Int] =
    let
      first_part = sequence.takeWhile(x -> x < element)
      middle = Seq(element)
      last_part = sequence.dropWhile(x -> x < element)
    in first_part.++(middle.++(last_part))
}

* SortAlgorithmExampleWithFold_() extends SortAlgorithmExampleWithFold

* ConstrainedSortAlgorithm = {
  + soda.lib.OptionSD
  + soda.lib.SomeElem
  + soda.lib.NoElem

  sort(sequence: Seq[Int]): OptionSD[Seq[Int]] =
    let
      sorted_sequence =
        SortAlgorithmExampleWithFold_().sort(sequence)
      result =
        if SortExampleWithZip_().is_sorted(sorted_sequence)
        then SomeElem(sorted_sequence)
        else NoElem[Seq[Int]]()
    in result
}

* ConstrainedSortAlgorithm_() extends ConstrainedSortAlgorithm

* SortedSequence[A subtype Comparable[A]] = {
  doc_SortedSequence = "This models a sequence that is always sorted."

  has sequence: Seq[A]
}

* EmptySortedSequence[A subtype Comparable[A]]
  extends SortedSequence[A] = {

  sequence = Seq()
}

* EmptySortedSequence_[A subtype Comparable[A]]()
  extends EmptySortedSequence[A]

* NonEmptySortedSequence[A subtype Comparable[A]]
  extends SortedSequence[A] = {

  has _remaining_sequence: Seq[A]

  has _some_element: A

  sequence =
    let
      first_part = _remaining_sequence.takeWhile(x -> x.compareTo(_some_element) < 0)
      middle = Seq(_some_element)
      last_part = _remaining_sequence.dropWhile(x -> x.compareTo(_some_element) < 0)
    in first_part.++(middle.++(last_part))
}

* _NonEmptySortedSequence_[A subtype Comparable[A]](_some_element: A, _remaining_sequence: Seq[A])
  extends NonEmptySortedSequence[A]

* SortedSequenceBuilder[A subtype Comparable[A]] = {
  + soda.lib.Rec

  build(sequence: Seq[A]): SortedSequence[A] =
    Rec().fold(sequence, _initial_value, _next_value_function)

  _initial_value = EmptySortedSequence_[A]()

  _next_value_function(sorted_sequence: SortedSequence[A], element: A): SortedSequence[A] =
    _NonEmptySortedSequence_[A](_remaining_sequence := sorted_sequence.sequence, _some_element := element)
}

* SortedSequenceBuilder_[A subtype Comparable[A]]() extends SortedSequenceBuilder[A]

