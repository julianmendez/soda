package soda.example



class Airport = {
  import soda.lib.OptionSD
  import soda.lib.SomeSD_
  import soda.lib.NoneSD_

  has name: String

  Airport_invariant =
    name.length == 3 and
    name.forall(ch -> 'A' <= ch and ch <= 'Z')

  Airport_checked: OptionSD[Airport] =
    if Airport_invariant then SomeSD_(this) else NoneSD_()
}

class _Airport_(name: String)
  extends Airport

class AirportBuilder() = {
  import soda.lib.OptionSD

  build (name: String): OptionSD[Airport] =
    _Airport_(name).Airport_checked
}

class PricingAgent = {
  import java.util.Date

  has get_price (flight: Flight, date: Date): Int
}

class Trip = {

  has airport_start: Airport

  has airport_end: Airport
}

class Segment
  extends Trip = {

  invariant_Segment =
    not (airport_start == airport_end)
}

class Segment_ (airport_start: Airport, airport_end: Airport)
  extends Segment

class Flight
  extends Trip = {

  has intermediate_stops: Seq[Airport]

  segments =
    _segments_multi (airport_start, intermediate_stops, airport_end)

  _segments_multi (airport_start: Airport, intermediate_stops: Seq[Airport], airport_end: Airport): Seq[Segment] =
    match intermediate_stops {
      case Nil -> Nil.+:(Segment_ (airport_start, airport_end))
      case x :: xs -> _segments_multi(x, xs, airport_end).+:(Segment_ (airport_start, x))
    }

  invariant_Flight =
    not (intermediate_stops.contains(airport_start)) and
      not (intermediate_stops.contains(airport_end))
}

class PriceMonitorAgent = {
  import java.util.Date

  has pricing_agent: PricingAgent

  has get_a_year_before (date: Date): Date

  has as_flight (segment: Segment): Flight

  prices_of_segments (segments: Seq[Segment], date: Date): Seq[Int] =
    segments.map (segment -> get_price (SingleSegmentFlight_ (segment.airport_start, segment.airport_end), date) )

  sum_of_prices (prices: Seq[Int]): Int =
    prices.sum

  price_of_flight_by_segments (flight: Flight, date: Date): Int =
    sum_of_prices (prices_of_segments (flight.segments, date))

  complies_with_ethical_rule_1 (flight: Flight, date: Date): Boolean =
    get_price (flight, date) <= price_of_flight_by_segments (flight, date)

  complies_with_ethical_rule_2 (flight: Flight, date: Date): Boolean =
    is_price_increase_acceptable (
      old_price := get_price (flight, date),
      new_price := get_price (flight, get_a_year_before(date) ) )

  is_price_increase_acceptable (old_price: Int, new_price: Int): Boolean =
    new_price <= (old_price * 125) / 100

  get_price (flight: Flight, date: Date): Int = pricing_agent.get_price (flight, date)
}

class SingleSegmentFlight
  extends Flight = {

  intermediate_stops = Seq()
}

class SingleSegmentFlight_(airport_start: Airport, airport_end: Airport)
  extends SingleSegmentFlight


