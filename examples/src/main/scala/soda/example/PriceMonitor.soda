package soda.example


class Customer = {

  has name: String

  has ip_address: String
}

class Airport = {
  import soda.lib.OptionSD
  import soda.lib.SomeSD_
  import soda.lib.NoneSD_

  has name: String

  Airport_invariant =
    name.length == 3 and
    name.forall(ch -> 'A' <= ch and ch <= 'Z')

  Airport_checked: OptionSD[Airport] =
    if Airport_invariant then SomeSD_(this) else NoneSD_()
}

class _Airport_(name: String)
  extends Airport

class AirportBuilder() = {
  import soda.lib.OptionSD

  build (name: String): OptionSD[Airport] =
    _Airport_(name).Airport_checked
}

class PricingAgent = {
  import java.util.Date

  has get_price (customer: Customer, flight: Flight, date: Date): Int
}

class Trip = {

  has airport_start: Airport

  has airport_end: Airport
}

class Segment
  extends Trip = {

  invariant_Segment =
    not (airport_start == airport_end)
}

class Segment_ (airport_start: Airport, airport_end: Airport)
  extends Segment

class Flight
  extends Trip = {

  has intermediate_stops: Seq[Airport]

  segments =
    _segments_multi (airport_start, intermediate_stops, airport_end)

  _segments_multi (airport_start: Airport, intermediate_stops: Seq[Airport], airport_end: Airport): Seq[Segment] =
    match intermediate_stops {
      case Nil -> Nil.+:(Segment_ (airport_start, airport_end))
      case x :: xs -> _segments_multi(x, xs, airport_end).+:(Segment_ (airport_start, x))
    }

  invariant_Flight =
    not (intermediate_stops.contains(airport_start)) and
      not (intermediate_stops.contains(airport_end))
}


class PriceMonitorAgent = {
  import java.util.Date

  has pricing_agent: PricingAgent

  has get_a_year_before (date: Date): Date

  has as_flight (segment: Segment): Flight

  get_price (customer: Customer, flight: Flight, date: Date): Int =
    pricing_agent.get_price (customer, flight, date)

  min (x: Int, y: Int): Int = if x < y then x else y

  max (x: Int, y: Int): Int = if x > y then x else y

  minimum_acceptable_similarity = 0.95

  complies_with_societal_principle_1 (customer1: Customer, customer2: Customer, flight: Flight, date: Date): Boolean =
    let
      price_for_customer1 = get_price(customer1, flight, date)
      price_for_customer2 = get_price(customer2, flight, date)
      similarity = min(price_for_customer1, price_for_customer2) / max(price_for_customer1, price_for_customer2)
    in similarity  >= minimum_acceptable_similarity

  acceptable_yearly_increase = 1.25

  complies_with_societal_principle_2 (customer: Customer, flight: Flight, date: Date): Boolean =
    let
      old_price = get_price (customer, flight, get_a_year_before(date) )
      new_price = get_price (customer, flight, date)
    in new_price <= old_price * acceptable_yearly_increase

  complies_with_societal_principle_3 (customer: Customer, flight: Flight, date: Date): Boolean =
    get_price (customer, flight, date) <= price_of_flight_by_segments (customer, flight, date)

  price_of_flight_by_segments (customer: Customer, flight: Flight, date: Date): Int =
    sum_of_prices (prices_of_segments (customer, flight.segments, date))

  prices_of_segments (customer: Customer, segments: Seq[Segment], date: Date): Seq[Int] =
    segments.map (segment -> get_price (customer, SingleSegmentFlight_ (segment.airport_start, segment.airport_end), date) )

  sum_of_prices (prices: Seq[Int]): Int =
    prices.sum
}

class SingleSegmentFlight
  extends Flight = {

  intermediate_stops = Seq()
}

class SingleSegmentFlight_(airport_start: Airport, airport_end: Airport)
  extends SingleSegmentFlight


