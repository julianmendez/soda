package soda.example.pricemonitor


class Customer = {

  has name: String

  has ip_address: String
}

class Customer_(name: String, ip_address: String)
  extends Customer

class PricingAgent = {

  has get_price: (Customer, Flight, Int) -> Int
}

class PricingAgent_(get_price: (Customer, Flight, Int) -> Int)
  extends PricingAgent

class Airport = {
  import soda.lib.OptionSD
  import soda.lib.SomeSD_
  import soda.lib.NoneSD_

  has name: String

  Airport_invariant =
    name.length == 3 and
    name.forall(ch -> 'A' <= ch and ch <= 'Z')

  Airport_checked: OptionSD[Airport] =
    if Airport_invariant then SomeSD_(this) else NoneSD_()
}

class _Airport_(name: String)
  extends Airport

class AirportBuilder() = {
  import soda.lib.OptionSD

  build (name: String): OptionSD[Airport] =
    _Airport_(name).Airport_checked
}

class Trip = {

  has airport_start: Airport

  has airport_end: Airport
}

class Segment
  extends Trip = {

  invariant_Segment =
    not (airport_start == airport_end)
}

class Segment_ (airport_start: Airport, airport_end: Airport)
  extends Segment

class Flight
  extends Trip = {

  has intermediate_stops: Seq[Airport]

  segments =
    _segments_multi (airport_start, intermediate_stops, airport_end)

  _segments_multi (airport_start: Airport, intermediate_stops: Seq[Airport], airport_end: Airport): Seq[Segment] =
    match intermediate_stops {
      case Nil -> Nil.+:(Segment_ (airport_start, airport_end))
      case x :: xs -> _segments_multi(x, xs, airport_end).+:(Segment_ (airport_start, x))
    }

  invariant_Flight =
    not (intermediate_stops.contains(airport_start)) and
      not (intermediate_stops.contains(airport_end))
}

class FlightSocietalPrinciple = {

  has pricing_agent: PricingAgent

  get_price (customer: Customer, flight: Flight, date_in_days: Int): Int =
    pricing_agent.get_price (customer, flight, date_in_days)
}

class FlightSocietalPrinciple1
 extends FlightSocietalPrinciple = {

  minimum_acceptable_similarity = 0.95

  min (x: Int, y: Int): Int = if x < y then x else y

  max (x: Int, y: Int): Int = if x > y then x else y

  complies (c1: Customer, c2: Customer, flight: Flight, date_in_days: Int): Boolean =
    let
      price_for_c1 = get_price(c1, flight, date_in_days)
      price_for_c2 = get_price(c2, flight, date_in_days)
      similarity = min (price_for_c1, price_for_c2) / max (price_for_c1, price_for_c2)
    in similarity >= minimum_acceptable_similarity
}

class FlightSocietalPrinciple1_(get_price: (Customer, Flight, Int) -> Int)

class FlightSocietalPrinciple2
  extends FlightSocietalPrinciple = {

  acceptable_yearly_increase = 1.25

  get_a_year_before (date_in_days: Int): Int =
    date_in_days - 365

  complies (customer: Customer, flight: Flight, date_in_days: Int): Boolean =
    let
      old_price = get_price (customer, flight, get_a_year_before (date_in_days) )
      new_price = get_price (customer, flight, date_in_days)
    in new_price <= old_price * acceptable_yearly_increase
}

class FlightSocietalPrinciple2_(get_price: (Customer, Flight, Int) -> Int)

class FlightSocietalPrinciple3
  extends FlightSocietalPrinciple = {

  complies (customer: Customer, flight: Flight, date_in_days: Int): Boolean =
    get_price (customer, flight, date_in_days) <= price_of_flight_by_segments (customer, flight, date_in_days)

  price_of_flight_by_segments (customer: Customer, flight: Flight, date_in_days: Int): Int =
    sum_of_prices (prices_of_segments (customer, flight.segments, date_in_days))

  prices_of_segments (customer: Customer, segments: Seq[Segment], date_in_days: Int): Seq[Int] =
    segments.map (segment -> get_price (customer, SingleSegmentFlight_ (segment.airport_start, segment.airport_end), date_in_days) )

  sum_of_prices (prices: Seq[Int]): Int =
    prices.sum
}

class FlightSocietalPrinciple3_(get_price: (Customer, Flight, Int) -> Int)

class PriceMonitorAgent = {
  import java.util.Date

  has pricing_agent: PricingAgent

  has get_a_year_before (date_in_days: Date): Date

  has as_flight (segment: Segment): Flight
}

class SingleSegmentFlight
  extends Flight = {

  intermediate_stops = Seq()
}

class SingleSegmentFlight_(airport_start: Airport, airport_end: Airport)
  extends SingleSegmentFlight

