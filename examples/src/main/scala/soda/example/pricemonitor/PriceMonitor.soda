package soda.example.pricemonitor


class Customer = {

  has name: String

  has ip_address: String
}

class Customer_(name: String, ip_address: String)
  extends Customer

class PricingAgent = {
  import java.util.Date

  has get_price (customer: Customer, flight: Flight, date_in_days: Int): Int

  get_days_for (date: Date): Int =
    (date.getTime / (1000 * 60 * 60 * 24)).toInt
}

class Flight = {

  has start_airport: String

  has intermediate_airports: Seq[String]

  has end_airport: String
}

class Flight_ (start_airport: String, intermediate_airports: Seq[String], end_airport: String)
  extends Flight

class Principle = {

  has pricing_agent: PricingAgent

  get_price (customer: Customer, flight: Flight, date_in_days: Int): Int =
    pricing_agent.get_price (customer, flight, date_in_days)
}

class Principle1
 extends Principle = {

  minimum_acceptable_similarity = 0.95

  min (x: Int, y: Int): Int = if x < y then x else y

  max (x: Int, y: Int): Int = if x > y then x else y

  complies (c1: Customer, c2: Customer, flight: Flight, date_in_days: Int): Boolean =
    let
      price_for_c1 = get_price(c1, flight, date_in_days)
      price_for_c2 = get_price(c2, flight, date_in_days)
      similarity = min (price_for_c1, price_for_c2) / max (price_for_c1, price_for_c2)
    in similarity >= minimum_acceptable_similarity
}

class Principle1_(pricing_agent: PricingAgent)
  extends Principle1


class Principle2
  extends Principle = {

  acceptable_yearly_increase = 1.25

  get_a_year_before (date_in_days: Int): Int =
    date_in_days - 365

  complies (customer: Customer, flight: Flight, date_in_days: Int): Boolean =
    let
      old_price = get_price (customer, flight, get_a_year_before (date_in_days) )
      new_price = get_price (customer, flight, date_in_days)
    in new_price <= old_price * acceptable_yearly_increase
}

class Principle2_(pricing_agent: PricingAgent)
  extends Principle2

class Principle3
  extends Principle = {

  complies (customer: Customer, flight: Flight, date_in_days: Int): Boolean =
    get_price (customer, flight, date_in_days) <= price_of_flight_by_segments (customer, flight, date_in_days)

  price_of_flight_by_segments (customer: Customer, flight: Flight, date_in_days: Int): Int =
    sum_of_prices (prices_of_segments (customer, SegmentsForFlight_ (flight).segments, date_in_days))

  prices_of_segments (customer: Customer, segments: Seq[Segment], date_in_days: Int): Seq[Int] =
    segments.map (segment -> get_price (customer, segment, date_in_days) )

  sum_of_prices (prices: Seq[Int]): Int =
    prices.sum
}

class Principle3_(pricing_agent: PricingAgent)
  extends Principle3

class Segment
  extends Flight = {

  intermediate_airports = Seq[String]()
}

class Segment_ (start_airport: String, end_airport: String)
  extends Segment

class SegmentsForFlight = {

  has flight: Flight

  segments: Seq[Segment] =
    _segments_multi (flight.start_airport, flight.intermediate_airports, flight.end_airport)

  _segments_multi (first_airport: String, intermediate_stops: Seq[String], last_airport: String): Seq[Segment] =
    match intermediate_stops {
      case Nil -> Nil.+:(Segment_ (first_airport, last_airport))
      case x :: xs -> _segments_multi(x, xs, last_airport).+:(Segment_ (first_airport, x))
    }
}

class SegmentsForFlight_ (flight: Flight)
  extends SegmentsForFlight


