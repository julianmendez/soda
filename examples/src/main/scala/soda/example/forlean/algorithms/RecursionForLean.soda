
directive lean
notation "Zero_ ()" => Nat.zero
notation "Succ_" => Nat.succ


/**
 * This class contains tail recursive auxiliary functions.
 */

class RecursionForLean

  abstract

  _tailrec_fold4 [A : Type] [B : Type] (list : List [A] ) (current : B)
      (next : B -> A -> B) (condition : B -> A -> Boolean) : B =
    match list
      case Nil ==> current
      case (head) :: (tail) ==>
        if (not (condition (current) (head) ) )
        then current
        else _tailrec_fold4 [A] [B] (tail) (next (current) (head) ) (next) (condition)

  fold4 [A : Type] [B : Type] (list : List [A] ) (initial_value : B)
      (next : B -> A -> B) (condition : B -> A -> Boolean) : B =
    _tailrec_fold4 [A] [B] (list) (initial_value) (next) (condition)

  _tailrec_fold3 [A : Type] [B : Type] (list : List [A] ) (current : B)
      (next : B -> A -> B) : B =
    match list
      case Nil ==> current
      case (head) :: (tail) ==>
        _tailrec_fold3 [A] [B] (tail) (next (current) (head) ) (next)

  fold3 [A : Type] [B : Type] (list : List [A] ) (initial_value : B)
      (next : B -> A -> B) : B =
    _tailrec_fold3 [A] [B] (list) (initial_value) (next)

  _tailrec_range (n : Nat) (list : List [Nat] ) : List [Nat] =
    match n
      case Zero_ () ==> list
      case Succ_ (k) ==>
        _tailrec_range (k) ( (k) :: (list) )

  range (length : Nat) : List [Nat] =
    _tailrec_range (length) (Nil)

end

