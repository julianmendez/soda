package soda.translator.example

* Memoizer[A, B] = {

  has main_function(x: A, memoized_values: Map[A, B]): Tuple2[B, Map[A, B]]

  compute(x: A, memoized_values: Map[A, B]): Tuple2[B, Map[A, B]] =
    let
      maybe_res = memoized_values.get(x)
      result =
        if maybe_res.isEmpty
        then compute_and_update(x, memoized_values)
        else (maybe_res.get, memoized_values)
    in result

  compute_and_update(x: A, memoized_values: Map[A, B]): Tuple2[B, Map[A, B]] =
    let
      (res, map) = main_function(x, memoized_values)
      new_pair = (x, res)
    in (res, map + new_pair)
}

* HardProblem
  extends Memoizer[Int, Int] = {

  is_even(n: Int): Boolean =
    n % 2 == 0

  one_step(n: Int): Int =
    if is_even(n)
    then n / 2
    else 3 * n + 1

  main_function(n: Int, memoized_values: Map[Int, Int]): Tuple2[Int, Map[Int, Int]] =
    if n == 1
    then (0, memoized_values)
    else
      let
        (res, new_map) = compute(one_step(n), memoized_values)
      in (1 + res, new_map)
}

* HardProblem_() extends HardProblem

* MemoizedFibonacci
  extends Memoizer[Int, Int] = {

  main_function(n: Int, memoized_values: Map[Int, Int]): Tuple2[Int, Map[Int, Int]] =
    if n == 0 then (0, memoized_values)
    else if n == 1 then (1, memoized_values)
    else
      let
        (res1, map1) = compute(n - 2, memoized_values)
        (res2, map2) = compute(n - 1, map1)
        res = res1 + res2
        new_pair = (n, res)
      in (res, map2 + new_pair)
}

* MemoizedFibonacci_() extends MemoizedFibonacci

