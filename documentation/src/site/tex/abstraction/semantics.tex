\section{Semantics}

\newcommand{\I}[1]{\ensuremath{{#1}^{\mathcal{I}}}}

\newcommand{\DeltaI}{\ensuremath{\Delta _{\mathcal{I}}}}
\newcommand{\ThetaI}{\ensuremath{\Theta _{\mathcal{I}}}}
\newcommand{\PhiI}{\ensuremath{\Phi _{\mathcal{I}}}}

\newcommand{\lambd}[2]{\ensuremath{(\lambda {#1} \to {#2})}}

The simplified semantics for \Soda can be defined as follows.

This definition is for a non-recursive definition of \Soda.
The recursive definition requires extra constraints to prevent undecidability.
This is discussed in the following section.

An interpretation of a \Soda formula is a pair $\mathcal{I} = \langle \DeltaI, \PhiI, \ThetaI, \I{\cdot} \rangle$, where $\DeltaI$ is the interpretation domain, $\PhiI$ is a set of functions defined with elements of $\DeltaI$, $\ThetaI$ is a set of type names, and $\I{\cdot}$ is the interpretation function.

As defined above, $\DeltaI \subseteq \PhiI$, because constants are considered functions without parameters.

Let $\mathbb{B}$ the set $\{false, true\}$.

We assume that:
\begin{itemize}
    \item $\mathbb{B} \subseteq \DeltaI$
    \item $\lambd{x: \mathbb{B}}{\lnot x} \in \PhiI$
    \item $\lambd{x: \mathbb{B}}{\lambd{y: \mathbb{B}}{x \land y}} \in \PhiI$
    \item $\lambd{x: \mathbb{B}}{\lambd{y: \mathbb{B}}{x \lor y}} \in \PhiI$
\end{itemize}

A \textbf{function definition} is a formula of the form
\[f = e\]
such that $f$ is a function name and $e$ is an expression.
$f$ is the \textbf{definiendum} and $g$ is the \textbf{definiens}.


At this point, we can distinguish between \textbf{recursive function definition} and \textbf{non-recursive function definition} considering whether $f$ occurs free on $e$, in the first case, or not, in the second case.

Please observe that a non-recursive function definition can be recursive by using another function, for example:
\begin{center}
    \[f = g\]
    \[g = f\]
\end{center}
are two non-recursive function definitions that are mutually recursive.

An \textbf{atomic function definition} is a non-recursive function definition of the form
\[f = g_{A}\]
such that $f$ is a fresh function name, not occurring in $g_{A}$, and $g_{A}$ is such that $\I{g_{A}} \in \PhiI$.

For example, these could be possible values for $g_{A}$:
\begin{itemize}
    \item 0
    \item true
    \item -1
    \item $(\lambda x: \mathbb{Z} \to (\lambda y: \mathbb{Z} \to x + y))$
    \item $(\lambda x: \mathbb{B} \to (\lambda y: \mathbb{B} \to x \land y) )$
\end{itemize}

A \textbf{class definition} is a formula of the form
\[\sclass\ A (V_{A}) \ \sextends\ P = S_{A}\]
where $A$ is a fresh class name, $V_{A}$ is a sequence of typed function names, $P$ is a possibly empty sequence of class names, and $S_{A}$ is a set of function definitions.

$P$ is said to be a conjunction of super classes, and this conjunction is notated:
\[P_{1} \ \swith\ P_{2} \ \swith\ \ldots \ \swith\ P_{n}\]

In the following, $S_{P}, S_{P_{1}}, \ldots , S_{P_{n}}$ denotes the set of definitions of $P, P_{1}, \ldots, P_{n}$ respectively.

Please observe that this definition does not consider defining classes inside other classes.

For those acquainted with class-inside-class definition, this expression:
\[\sclass\ A (V_{A}) \ \sextends\ P_{1} = \{
\sclass\ B (V_{B}) \ \sextends\ P_{2} = S_{B} \} \cup S_{A}
\]
can be rewritten as:
\[\sclass\ A (V_{A}) \ \sextends\ P_{1} = S_{A}
\]
\[\sclass\ AB (V_{A}, V_{B}) \ \sextends\ P_{2} = S_{A} \cup S_{B}
\]

where ``$V_{A}$, $V_{B}$'' contains the variables from $A$ and $B$.

In addition, the variables can be included in the function definitions.
This means that
\[\sclass\ A (V_{A}) \ \sextends\ P = \{
f_{1} = g_{1},
\ldots ,
f_{n} = g_{n}
\}
\]

can be rewritten as
\[\sclass\ A() \ \sextends\ P = \{
f_{1}(V_{A}) = g_{1},
\ldots ,
f_{n}(V_{A}) = g_{n}
\}
\]

In practice, all function calls should also include the parameters in $V_{A}$.

Finally, the empty parameters can be also rewritten.
This means that
\[\sclass\ A() \ \sextends\ P = \{
f_{1} = g_{1},
\ldots ,
f_{n} = g_{n}
\}
\]
can be rewritten as:
\[\sclass\ A \ \sextends\ P = \{
f_{1}(self) = g_{1},
\ldots ,
f_{n}(self) = g_{n}
\}
\]
where $self$ is an extra variable needed to invoke the functions, and it is given when a class instance is created.

It is assumed that there exists a class \srccode{Top} such that all classes extend from it.
Hence, if $A$ extends \srccode{Top}, ``$\sextends\ P$'' can be omitted.

``$(V)$'' can be excluded to define a class that cannot be instantiated, which is call an \textbf{abstract class}.
By contrast, a \textbf{concrete class} is a class that can be instantiated.
If $V$ is an empty sequence, the class does not need parameters to be instantiated.

If $S_{A}$ is empty, the equals sign can be omitted.

We say that $A$ is a \textbf{trivial extension} of an abstract class $B$ for the formula when $A$ extends only $B$ and $A$ has no parameters.
A \textbf{concrete trivial extension} is a trivial extension by using a concrete class.

The \shas reserved word allows declaring functions in abstract classes.
As a simple approach, each function or constant declared with \shas can be thought as a kind of parameter needed to instantiate a class.
An abstract class without \shas needed to be satisfied can be instantiated by a concrete trivial extension.

There is a small divergence between \Soda as defined here and its implementation, because the implementation allows defining classes inside classes, and even inside functions.

\textbf{Notation}: $e[f \coloneqq g]$ is a notation that means replacing every free occurrence of $f$ in $e$ by $g$, where bound variables in $e$ can be renamed to avoid that the insertion of free variables in $g$ are bound.

For example,
\begin{itemize}
    \item $f = g$
    \item $g = \lambd {x}{x + y}$
    \item $e = \lambd {y}{2 f(y)}$
    \item then $e[f \coloneqq g] = \lambd {y_{1}}{2 (y_{1} + y)}$
\end{itemize}


The interpretation function is defined as follows:
\begin{itemize}
    \item $\I{\srccode{Boolean}} = \mathbb{B}$
    \item $\I{\srccode{Int}} = \mathbb{Z}$

    \item $\I{(f : T)} = \I{f} \in \I{T}$

    \item $\I{(\sif\ f_{B} \ \sthen\ e_{1} \ \selse\ e_{2})} =
    \begin{cases}
        \I{e_{1}}, & \text{if } \I{f_{B}} \text{ is true }\\
        \I{e_{2}}, & \text{otherwise}
    \end{cases}
    $\\
    provided that $f_{B}$ returns a Boolean value.

    \item $\I{(\slet\ f = g \ \sdin\ e)}$ =
    \I{(e[f := g])}, provided that $f$ does not occur free in $g$.

    \item $\I{(\slet\ f_{1} = g_{1}, \ldots , f_{n} = g_{n} \ \sdin\ e)}$ = \\
    $\I{(\slet\ f_{1} = g_{1}[f_{n} \coloneqq g_{n}], \ldots , f_{n - 1} = g_{n - 1}[f_{n} \coloneqq g_{n}] \ \sdin\ e[f_{n} \coloneqq g_{n}])}$, provided that $f_{n}$ does not occur free in $g_{n}$.

    \item $\I{(\sclass\ A = S_{A})}$ = \\
    $\{ (f_{d}, d) \mid d \in S_{A} \land f_{d} \text{ is the definiendum in } d \land A \in \ThetaI \}$, provided that the definienda are unique.

    \item $\I{(\sclass\ A \ \sextends\ P = S_{A})}$ = \\
    $\I{(\sclass\ A = S_{P} \cup S_{A})}$, provided that $S_{P}$ and $S_{A}$ do not share any definition of the same function name or class name.

    \item $\I{(\sclass\ A \ \sextends\ P_{1} \ \swith\ P_{2} = S_{A})}$ = \\
    $\I{(\sclass\ A \ \sextends\ P_{1} = S_{P_{2}} \cup S_{A})}$, provided that $S_{P_{2}}$ and $S_{A}$ do not share any definition of the same function name or class name.

\end{itemize}

\subsection{Recursive definitions}


One problem is the infinitely recursive definition:
\begin{lstlisting}[label={lst:exampleOfRecursion}]
  f (x: Int) = g(x)
  g (x: Int) = f(x)
\end{lstlisting}

Because of that, conventionally, every recursive function should be declared as such, by being named or starting with the prefix \srccode{rec}.

For example, instead of writing this function
\begin{lstlisting}[label={lst:exampleOfFactorialBadNaming}]
  f (n: Int) =
    if n <= 0
    then 1
    else n * f(n - 1)
\end{lstlisting}

writing this other function
\begin{lstlisting}[label={lst:exampleOfFactorialGoodNaming}]
  rec_f (n: Int) =
    if n <= 0
    then 1
    else n * rec_f(n - 1)
\end{lstlisting}

The purpose is to highlight that it requires extra care to verify that its recursion finishes.

Alternatively, it is possible to use \srccode{foldLeft} over an finite iterable structure.
\begin{lstlisting}[label={lst:exampleOfFactorialFoldLeft}]
  f (n: Int) =
    let
      initial_value = 1
      next_value(acc: Int, elem: Int): Int = acc * elem
    in Range(0, n).foldLeft(initial_value)(next_value)
\end{lstlisting}

More information about it can be found in \textbf{System-F}, \textbf{Martin-L\"{o}f type theory}, and in \textbf{dependent types}.


\url{https://en.wikipedia.org/wiki/Operational_semantics}

In addition, we can operate on a Monad with the following definitions

$\I{bind(a, b)} = $ (to be defined)

\subsection{Measuring similarity}

Abstract classes can be encoded using an \textbf{integer encoding}.
In this encoding, it is possible to determine whether two classes are subsumed with a simple operation.

For this, we consider the \textbf{primitive} classes those who extend only from Top (or \srccode{Thing}).

We assign each primitive class a different prime number, starting with 3.

If a $B$ class is non-primitive and extends classes $A_{1}, \ldots , A_{n}$, the number is

\[ \text{enc}(B) = 2 \cdot \text{lcm}(A_{1}, \ldots, A_{n}) \]

where $\text{lcm}$ is the least-common multiple calculated on $A_{1}, \ldots , A_{n}$.

$A \ \sextends\ B$ if and only if $\text{enc}(B)$ divides $\text{enc}(A)$.

We define a distance
\[
    d(A, B) =
    \begin{cases}
        \log_{2} \frac{\text{enc}(A)}{\text{enc}(B)} & \text{if } \text{enc}(B) \text{ divides }\text{enc}(A) \\
        \infty & \text{otherwise}
    \end{cases}
\]

In the following example, we can see a class hierarchy using a naming convention following the encoding.

\begin{lstlisting}[label={lst:exampleOfIntegerEncoding}]
  class A3
  class A5
  class A7
  class A11
  class A6 extends A3
  class A30 extends A3 with A5
  class A42 extends A3 with A7
  class A420 extends A30 with A42
  class A60 extends A6 with A30
\end{lstlisting}


Please note that two different classes have the same encoding if they extend the same classes.
This encoding cannot be used as identifier.

This encoding can be used to measure \textbf{similarity} between two classes.
This concept of similarity is completely structural and does not depend on the intended meaning modelling the classes.

Similarity can be used to
group similar concepts, either to detect coupling or lack of cohesion.

