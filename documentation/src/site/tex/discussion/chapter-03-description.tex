\chapter{Description}

\Soda (Symbolic Objective Descriptive Analysis) is a human-centered formalism to describe, formalize, and prototype ethical problems and constraints.
It could be seen as a specification language or as a functional programming language.
A specification or piece of source code written in \Soda needs to be especially easy to read, but it does not need to be easy to write.

A prototype written in \Soda does not need to be efficient, as long as it can be executed in a \textit{reasonable time}.
A reasonable time is not a mathematical definition, but a human perception for a specific task.

The current implementation of \Soda can be translated into Scala, and it relies on its data types.
Prototypes written in \Soda can be run in the Java Virtual Machine (JVM).
Therefore, it can be used as a JVM library and use libraries written in Java, Scala, or any other JVM language.

The reasons of translating \Soda into Scala and not just using Scala could be summarized in three main points.

The first point is to have a \textbf{lean syntax}.
\Soda is expected to maximize transparency of written code.
In general, less reserved words are used.
For example, there is no need to distinguish between values (in Scala, \scalaval) and variables (in Scala, \scalavar).
Also, there is no need to distinguish between public, protected or private methods.

The second point is to have a \textbf{constrained syntax}.
This means that the only available commands are those of a purely functional approach.
This prevents creating mutable objects, like when using \scalavar, or changing a class behavior by inheritance, like when using a \scalaclass that is not a \scalacase \ \scalaclass.
It is worth noticing that, since \Soda is a JVM language, it also accepts JVM mutable objects.
However, these objects need to be explicitly declared, and can be restricted, if that is necessary.

Finally, the third point is to have \textbf{translation options}.
\Soda could be translated to other languages that support tail recursion like Kotlin, for example.


\section{The Problems to Solve}

\begin{itemize}
    \item complex syntax
    \item mutable objects
    \item ambiguous (to humans) syntax (C / C++)
    \item intricate symbols (Scala)
    \item excessive importance of code format (Python)
    \item excessive verbosity (Java)
\end{itemize}


\section{The Intended User of \Soda}

The purpose of \Soda is to give at least one way that is clear enough to describe things, paying less regard to efficiency.

Let us try to think what problems \Soda tries to solve.
If we think on the first programming languages, like Fortran, Cobol, and Lisp, they had challenges to parse the source code.
Newer programming languages, like Python or Scala, have clearly more powerful computers to do the processing.

Lisp source code can look very flexible, but it could be challenging keeping track of the parentheses.

Fortran has been used by physicist thanks to its important number of libraries for physics.
Earlier versions of Fortran could not process recursion as we usually do it now, since it did not use a stack for the variables.
Programming backtracking was extremely intricate.

\Soda allows writing functions as tail recursive, as in other modern functional languages, and the compiler transforms the tail recursion to an iteration.

Someone who needs to understand the code does not necessarily need to know how to write a tail recursion.
Writing a tail recursion requires some knowledge of algorithms, but reading a tail recursion is very intuitive, in a mathematical way.
Because of this type of asymmetries, we say that \Soda is a language that is easy to read but not necessarily easy to write.

Since \Soda is intended to maximize transparency, there is no reserved word to declare private methods.
In object-oriented programming languages, classes and their attributes and methods are declared private to prevent using them outside the intended place.
In \Soda, a protected class, attribute, or method name can be identified by using an underscore as prefix.


\section{A Descriptive Language}

In traditional programming languages, if we need to represent a big data structure, every byte counts.
If we need to store numbers between 0 and 250, a byte (8 bits) would suffice.
However, if we need to store numbers between 0 and 260, we would need one more bit (9 bits), which is practice it would mean to use two bytes (16 bits).

In most cases, we do not care if an integer is 32-bit or 64-bit, and to understand an algorithm, we do not even care if an integer has a fixed length.
The number of bytes a system uses is a technical issue, and it could complicate the understanding of an algorithm.

This level of detail is usually irrelevant to describe a problem, unless the problem is about this technicality.
In other words, it is more natural that a human reads about a number, regardless of how many bits that number needs to be represented.

In an algorithm, we explain a sequence of steps to accomplish a particular goal.
If we want to order an array, we can either swap elements in an array, like in bubble sort, or we can choose a pivot, like in quicksort, or use other strategies.

Is it really important to describe a problem to know how an array is sorted?
Usually we do not care how an array is being sorted, as long as it takes a \textit{reasonable} time.

Let us consider another example.
If we are manipulating strings, and we want to find a particular pattern.
Finding a pattern is a very common problem.
As long as there is one way of finding a pattern, we do not really care how it is done.

\Soda could be seen mostly as a specification language, where we can specify without saying how.
It could be seen as a programming language as well.

The important point is that it can provide at least one implementation that is good enough, with an acceptable complexity, to test if something is compliant or not.


\section{Purpose of \Soda}

The purpose of \Soda is to give a ``yes'' or ``no'' answer to verify if something is compliant to ethical constraints.
Ideally, it should also provide an explanation for its answer.

As said before, \Soda is a formalism with some libraries.
It is not only a restricted variant of a functional language.
It is also all the collections of requirements that are useful for defining ethical problems.

In an iterative process, new ethical problems are formalized in \Soda, and when patterns are found in many problems, they join its libraries.
Thus, \Soda contains a collection of small classes and functions to accomplish particular tasks.

In some cases, it could look like a controlled natural language, but it is not its purpose to look like one.
For example, there are formulas that can be said as a sentence or written as a formula.
Reading ``the square root of two'' is harder than reading $\sqrt{2}$.
\Soda code has to be easy to read, not necessarily easy to say, or to write.


\section{General features}

The goal of \Soda is to specify without being too specific, giving some freedom for different implementations.
\Soda tries to keep a good balance between vagueness and concreteness, specificity and generality,
and what is very descriptive but also technically useful.

This happens in a way that is general enough to abstract implementations, but specific enough to constraint a problem.
We do not need to define how things are done, as long as they are done correctly and in a reasonable time.


\section{Technical Considerations}

\Soda needs to be abstract enough to describe, efficient enough, easy to read, easy to execute, and easy to integrate.
Because of that, \Soda is a JVM language and can be compiled into Java byte code.

For now, the translator converts \Soda code into Scala code, which in turn can be compiled to byte code.
For the sake of compatibility with the JVM, \Soda has an \soverride and a \snew annotations.
The \soverride annotations is to be able to override JVM definitions, like method \srccode{toString()} in class \srccode{Object}.
The \snew annotation is to be able to create JVM objects, but it is a technical compromise to be able to translate to Scala 2.
In the translation to Scala 3 this annotation can be omitted.

\Soda uses the main types provided by Scala.
For example, numeric types like \srccode{Int}, \srccode{Float}, and immutable collections like \srccode{Seq}, \srccode{List}, \srccode{Array}, and \srccode{Map}.
The JVM exception handling is done via \srccode{Try}.


\section{Philosophy}

\Soda is designed to be a functional specification language.
There are some general rules that apply to it:

\begin{itemize}
    \item the specification is intended to be read and understood by a human, so it has to be very clear;
    \item every defined thing is defined only once, in one place;
    \item objects are immutable;
    \item classes cannot be modified, but they can be extended.
\end{itemize}


\section{Mutability}

Mutability is one of the reason that algorithms get more difficult to understand.
It is not a matter to understand what the algorithms seems to be doing, it is about what it is actually doing.
Although it could be a practical way to reduce memory usage, it could also be error prone.
For this reason, \Soda does not have ways to program mutability.

For technical reasons, it is possible to use mutable objects from the JVM in \Soda.
This is strongly discouraged, since other design decisions are based assuming that objects are immutable.

\Soda does not handle exceptions (except when they come from the JVM).
The exceptions are caught by Scala classes (like \srccode{Try}), as Scala does.

Functions with side effects, like input and output operations, are discouraged in \Soda.
In exceptional cases, they could be managed by JVM libraries.


\section{Constants and Functions}

In \Soda there are no mutable objects and therefore every value is constant.
In addition, a function without parameters is computed as a constant, i.e. it is computed only once and remains unchanged.

There is a technical difference between constants and functions with empty parameters.
As in Scala, the use of parameters is expected to denote side effects, and indicates that the value is recalculated every time they are invoked.
For constants, \Soda uses \textit{lazy evaluation}, and they are only evaluated when they are used for the first time.

In \Soda, it is possible to define a function that needs auxiliary computations using bindings.
This can be done by defining a block between braces (\srccode{\{ \}}).
In this block, all the auxiliary computations are evaluated only when the last line, the result, needs to be calculated.

For example, the mathematical formula:
\begin{center}
    $f(x) = g(x) + g(g(x))$
\end{center}
can be rewritten as
\begin{center}
    $f(x) = a + b$, where $a = g(x)$ and $b = g(a)$.
\end{center}

In \Soda, the order is slightly changed.
A \slet-\sdin structure is used for the same purpose, with the result put at the end.

It is possible to use a
\begin{lstlisting}[label={lst:exampleFunctionWithLetIn}]
  f (x: Int) =
    let
      a = g(x)
      b = g(a)
    in a + b
\end{lstlisting}

This could be read as:
\begin{center}
    $f(x)$ is a value such that, if $a = g(x)$ and $b = g(a)$, that value is $a + b$.
\end{center}

It is possible to use a variable at the beginning to emphasize the result instead the other bindings, like in a \textit{where} example.
The constant name \srccode{result} is not really a reserved word, but it is a suggested name to write this pattern.
As in a mathematical description, the order of the auxiliary functions is not relevant.

\begin{lstlisting}[label={lst:exampleFunctionLikeWhere}]
  f2 (x: Int) =
    let
      result = a + b
      a = g(x)
      b = g(a)
    in result
\end{lstlisting}


\section{Types and Classes}

\Soda is statically typed.
It has some ideas of object orientation.
However, there are substantial differences with traditional object-oriented programming.


\section{Object Inheritance and Overriding}

\subsection{Abstract and concrete classes}

\Soda has two types of classes: \textbf{abstract classes}, and \textbf{concrete classes}.

Abstract classes are like traits in Scala and interfaces in Java, and either do not have any implementation, or what is implemented cannot be overridden.
In addition, abstract classes can contain \textit{abstract} constants and functions, which are only signatures of constants and functions.
A definition of an abstract class has the name for the new type, a declaration of its super types, and a sequence of possibly abstract constants and functions.

Concrete classes are like case classes in Scala, since they cannot be extended, and have a default constructor.
Since concrete classes cannot be extended, it is recommended to use abstract classes as much as possible, and let concrete classes contain only trivial constants or functions.
A definition of a concrete class has the name for the new type, a declaration of its super types, a tuple of parameters, and a sequence of constants and functions.

\subsection{Classes to define concepts}

Classes should contain the smallest number of constants and functions to describe a \textbf{concept}.
It is important to highlight that the concept should look familiar to a human being for the particular domain being modelled.
While \srccode{Dog} could be a familiar concept to model in a general domain, \srccode{CanisLupusFamiliaris} could be more appropriate in a zoology-centered domain.

As a matter of design, it is then recommended to have small abstract classes.
The larger the class, the more vague its purpose, and therefore, the less useful it is.

If a class contains only constants, then another class can easily use them by extending the class with constants.
In this case, extension is used to import shared constants as local.
Otherwise, extension should only be used when a concept modelled by a class clearly extends another one.
If a class modelling a concept uses functions from another class modelling a different concept, the former should instantiate the latter to use the functions.

The name of a concrete class that is a default implementation of another class could be the name of the abstract class with a suffix underscore.

\begin{lstlisting}[label={lst:exampleDefaultImplementation}]
  class MyModule = {

    f(x: Int) = x + 1
  }

  class MyModule_() extends MyModule
\end{lstlisting}

The definition of the sequence of constants, functions, and subclasses starts with an left brace (``\srccode{\{}'') and closes with a right brace (``\srccode{\}}'').

All constants and functions in a class are meant to be \textit{final}, i.e. if another classes extends the former, it cannot change any defined constant or function from a super class.
This is to prevent that the modelled behavior in a class is changed after extending a it.
For technical reasons, the annotation \soverride can be used to override JVM methods that are implemented already, like \srccode{Any.toString}.

In \Soda, there is a \sthis reserved word where an object can refer to its own instance, but there is no \scalasuper reserved word.
The reason is that there is no difference between a constant or function defined in a class or in a super class.

In \Soda, it is possible to define a \textit{type alias}.
This is just a renaming of a more complex definition.

This can be done by defining a class equals to another class instead of defining the body.

\begin{lstlisting}[label={lst:exampleTypeAlias}]
  class MyMap = Map[Int, Seq[Int]]

  class A[T] = Seq[Int, String]
\end{lstlisting}

This feature is only available when translating to Scala 3.


\section{Static Constants and Functions}

In \Soda, there is no concept of static functions.
It is never assumed that there is one instance of an object.
The class constructors can be implemented as objects of another class, although not necessary unique.


\section{Parametric Types}

Parametric types are technically possible.
It is possible to put upper bounds in the parameter, to define it as a subtype of another type.

\begin{lstlisting}[label={lst:exampleUpperBoundParameter}]
  class Shape

  class Movable

  class Painter[A]

  class ShapePainter[A subtype Shape]

  class ShapeMover[A subtype Shape with Movable]
\end{lstlisting}

In the example, a ShapePainter is an abstract class that can be applied to any Shape or subtype A of a Shape.
When a concrete class extends ShapePainter, it can use specific functions of a concrete type A, even if they are not in type Shape.
A concrete class extending ShapeMover requires a parameter that is a Shape and that is Movable.

Usually, parametric types are needed for highly generic data types, like collections.
Parameters are used to reduce code length, but sometimes smaller code is not necessarily easier to understand.
Using parametric types could hide a design flaw, when the code looks ``very general'', but in practice is only applicable to one specific type.


\section{Style}

\Soda does not require a semicolon to finish each instruction, and the tabulation at the beginning of the line is irrelevant.
Consecutive lines ending with a comma character (\srccode{,}) are considered to belong to the same line.

Braces in the definition of a function should be avoided whenever that is possible.

Defining a constant or a function requires a space around the `equals' character (\sdef).
With \sdefparam is also possible to define values for parameters when using named parameters.

\begin{lstlisting}[label={lst:exampleFunctionWithoutBraces}]
  class EqualsExample () = {
    answer = f (x := 20, y := 2)

    f (x: Int, y: Int) = 2 * x + y
  }
\end{lstlisting}


Variables are statically defined.

The recommended naming convention is using snake case, i.e. separating the words with underscore.
Class names should start with a capital letter, functions with a lowercase letter.

In addition, it is recommended to use nouns representing properties for constants and verbs for functions.
A function should always receive at least one parameter, except when it produces some sort of side effect.

Some exceptions are the constants that start with prefix ``\srccode{is}'', ``\srccode{as}'', and ``\srccode{to}'', which do not need parameters.

In addition, a parameter name should always be a noun, even if the signature is of a function.
Although redundant, this could be eased by adding the suffix ``\srccode{function}''.
Thus, the contrast of reading a noun used as a function is reduced.

This example shows the three cases

\begin{lstlisting}[label={lst:exampleFunctionsAsParameter}]
    naive_definition(values: Seq[Int], weighted_average: Seq[Int] -> Int): Int =
      weighted_average(values)

    alternative_definition(values: Seq[Int], compute_weighted_average: Seq[Int] -> Int): Int =
      compute_weighted_average(values)

    recommended_definition(values: Seq[Int], weighted_average_function: Seq[Int] -> Int): Int =
      weighted_average_function(values)
\end{lstlisting}

Analogously, for a Boolean function, the suffix ``\srccode{condition}'' could simplify the reading.

Since there are no private functions or constants in a class, the suggestion is to start their name with an underscore.

Recursive functions should start with prefix ``\srccode{rec}'', for example, just ``\srccode{rec}'', or ``\srccode{rec\_find\_elem}''.
This is to indicate that there is a recursion, and extra care should be taken into account to verify termination.

Although in the current version of \Soda there is no check for detection of recursive calls, it could be implemented in the future a warning or an error if the one or multiple functions participating in recursions do not indicate that with prefix "rec".

This is only a recommendation, since the JVM objects use camel case, i.e. all the words come together, starting with a capital letter.
Since \Soda can be integrated with other JVM languages, some \Soda code could use camel case.

The following list is an example to summarize the naming convention.

\begin{itemize}
    \item \srccode{LocalTranslator} \\
    \textbf{class} - noun that starts with a capital letter and uses camel case

    \item \srccode{first\_name} \\
    \textbf{constant} - noun that starts with a lowercase letter and uses snake case

    \item \srccode{translate\_paragraph(s: String)} \\
    \textbf{function} - predicate that starts with lowercase letter and uses snake case

    \item \srccode{is\_empty} \\
    \textbf{constant} - predicate ``is-'' that starts with lowercase letter and uses snake case

    \item \srccode{as\_translator} \\
    \textbf{constant} - predicate ``as-'' that starts with lowercase letter and uses snake case

    \item \srccode{to\_global\_translator} \\
    \textbf{constant} - predicate ``to-'' that starts with lowercase letter and uses snake case

    \item \srccode{toGlobalTranslator} \\
    \textbf{constant} - predicate ``to-'' that starts with lowercase letter and uses camel case to be used by JVM projects

    \item \srccode{LocalTranslator\_} \\
    \textbf{concrete class} - noun that starts with a capital letter and uses camel case and ends with an underscore

    \item \srccode{\_LocalModel} \\
    \textbf{non-public class} - noun that starts with an underscore and then capital letter and uses camel case

    \item \srccode{\_internal\_identifier} \\
    \textbf{non-public constant} - noun that starts with an underscore and then a lowercase letter and uses snake case

    \item \srccode{\_find\_internal\_identifier(s: String)} \\
    \textbf{non-public function} - predicate that starts with an underscore and then a lowercase letter and uses snake case

    \item \srccode{rec\_find\_elem(s: String)} \\
    \textbf{recursive function} - predicate that starts with prefix ``rec'' and then lowercase letter and uses snake case

\end{itemize}

Example using snake case, recommended in \Soda

\begin{lstlisting}[label={lst:exampleExtendsSnakeCase}]
  /** Class for a registered person, in snake case */
  class Registered_person (first_name: String, last_name: String) = {
    _separator = " "

    full_name = first_name + _separator + last_name
  }
\end{lstlisting}

Example using camel case, as in Java:
\begin{lstlisting}[label={lst:exampleExtendsCamelCase}]
  /** Class for a registered person, in camel case */
  class RegisteredPerson (firstName: String, lastName: String) = {
    _separator = " "

    fullName = firstName + _separator + lastName
  }
\end{lstlisting}


\section{Comments}

Comments are marked with the \srccode{/*} and  \srccode{*/}.
The Scaladoc can be used by starting the comment with \srccode{/**}, as in Scala.
In each line, comments and source code are mutually exclusive, a line that has a comment does not have source code, a line that has source code does not have a comment.

In general, comments are slightly discouraged, because the code should be descriptive enough.
If the code is not descriptive enough, it should be refactored instead of commented.
Comments can very easily get outdated if the source is changed, and the comment is not updated.

Comments can be part of the implementation itself as constants in classes.
The advantage of this type of comment is that it can be accessed in runtime.
This does not prevent the synchronization issue between written text and written code, though.
For example,

\begin{lstlisting}[label={lst:exampleClassWithComment}]
  class InterestingClass() = {
    doc = "This class is just an example of how to include comments as part of the code."
  }
\end{lstlisting}

A similar feature can be found in Python, for example, where Docstrings can be accessed by reading variable \srccode{\_\_doc\_\_}.

The \srccode{doc} constant is only recommended for concrete classes.
For abstract classes, it should contain a suffix with the class name.

For example,
\begin{lstlisting}[label={lst:exampleAbstractAndConcreteClassesWithComment}]
  class AbstractClassA = {
    doc_AbstractClassA = "Documentation of abstract class A. "
  }

  class AbstractClassB extends AbstractClassA = {
    doc_AbstractClassB = "Documentation of abstract class B. " + doc_AbstractClassA
  }

  class ConcreteClassC() extends AbstractClassB = {
    doc = "Documentation of concrete class C. " + doc_AbstractClassB
  }
\end{lstlisting}

Clearly, an extending class does not need to include the documentation of its superclasses.


\section{Minimality and orthogonality}

The importance of minimality and orthogonality is simplification and standardization.

Minimality helps the user to understand remembering a smaller set of reserved words.
Less reserved words also implies less combinations of them.

Orthogonality helps to achieve common design patterns and tend to have some sort of normal form.
Patterns make source code easier to understand and to detect mistakes in it.

The reason that pattern matching is (at the moment) not available is to maximize orthogonality.


\section{Definitions, theorems, and examples}

In mathematics books, it is common to find Definitions, Theorems, and Examples.

Mathematics uses a very compact notation, defining and redefining symbols to achieve complex expressions.
Mathematicians take some time to get acquainted to the notation by reading examples, and understanding lemmas, theorems, and their proofs.
Mathematics is known to be one of disciplines, most difficult to understand.
This is often attributed, not only to its complex abstract nature, but also to its notation.

The main purpose of \Soda is to make a formal description easy to understand.
For this, we can take advantage of similar techniques used in mathematics.

A set of \Soda classes can be seen as \textit{definitions}.

Properties of those definitions can be seen as \textit{theorems}.

Unit tests are the \textit{examples}, as they contain specific instances.

\Soda is not especially designed to prove correctness of programs, but provides some elements thar simplifies the human part on this verification.

\subsection{Static Types}

The first and most relevant is the static type system.
This provides the first check in compile time to ensure that \Soda code is consistent.

\subsection{Immutable Variables}

The pure functional approach keeps consistency across the evaluation of a function, because variables do not change.

\subsection{Unambiguous Syntax}

Some functional languages like Haskell allow the user to change precedence of its operators, leaving the possibility of writing without parentheses.
Although this could look aesthetically better, leaves room for ambiguity but for the human reader, who might mistake the order of evaluation.

\subsection{Less Format Errors}

Some languages have significant whitespace, like Python.
These makes it easier to, for example, wrongly put a function outside or inside a class, or execute a function after a block, which should be inside.
Signficant whitespace has been a strong motivation to keep the code well indented, but at a very high price of making the code writing more error-prone.

\subsection{Less Verbosity}

Some languages can be very verbose, like Java.
This verbosity can hinder sometimes the true intention in the code.
\Soda is designed to be lightweight and say what it is necessary, but not more.

\subsection{Explicit forms}

\texttt{Implicits} is maybe one of the most powerful features of Scala, but also one of the most confusing.
They are exactly that, implicit, which makes them hard to find without using tools.
Implicits have been considered overused (and misused) in Scala 2, and motivated a change in Scala 3 as \textit{givens}.

\subsection{Clear Location of Definitions}

In some languages, it is possible to partially define functions, like in Haskell, or predicates, like in Prolog.
In the latter, having multiple definitions might make it harder to understand or predict how the interpreter will evaluate a program.
In \Soda each class and in each function is defined only once, in one unique place.
They are final and immutable, simplifying to the human reader understanding their result.

\subsection{Used to Check}

\Soda is a language designed to \textit{check} whether something is right, rather that \textit{explaining} how it should be done.
As in an example of sorting a sequence, \Soda can be used to explain a process in a natural way, although not necessarily in an efficient way.


