\chapter{Motivation}

\newcommand{\question}[1]{\textit{#1}}


\section{Why - An Itemized Justification}

\begin{itemize}
    \item AI systems can be dangerous, not only at an ethical level.
    \item AI systems can be very complex.
    \item Governance can only be achieved by framing and understanding a system.
    \item Communication with computers is formal.
    \item Formal languages are not yet descriptive and resilient to humans, and efficient for computers.
    \item A new descriptive and efficient language would better ensure that AI systems are not dangerous to humans.
\end{itemize}


\textbf{Research Question 1}: How would it be a human-oriented descriptive language used for communication with computers?


\textbf{Research Question 2}: How could ethical values be encoded in such language?


\textbf{Research Question 3}: How should such language be integrated in an ethical verification system?

\subsection{AI Systems risks}

AI systems can outperform single or multiple human beings in specific tasks, like massively performed face recognition,
and used indolently can threaten human well-being.

\subsection{AI Systems complexity}

Even it is difficult to define precisely what AI means, it is common accepted in the literature that are complex systems.

\subsection{Governance of AI Systems}

This means that it is not enough to have an 'off-switch'.
Governance can only be achieved when a system is properly understood by those using it.

\subsection{Communication with computers}

It does not matter how beautiful and human friendly a graphic interface can look,
the communication with a system is through a sequence of 0's and 1's that are interpreted by the computer.
In other words, the human understanding of an approximate explanation, does not apply to computers.
They simulate it, but in the end, everything inside is 0's and 1's.

\subsection{Formal languages}


\begin{itemize}
    \item Why is it hard for people to understand other people's code?
    \item Why do people write comments in natural language next to the source code?
    \item Why do developers need a debugging tools at all?
    \item Why cannot most of the people read code as they read a newspaper?
\end{itemize}
The answer is simple: source code is not easy to read.
Source code needs to be learned, needs to be practiced, and even with many years, pieces of code can be deceiving.

It seems that most of the code is written for computers, and not for other humans.

This can be since the beginning of computing.
Languages like Fortran, Cobol, and Lisp sought a simplified communication in some sense.
Fortran is to write mathematical formulas, Cobol looks like writing English sentences, Lisp is algebraic.
A long list of programming languages, can prove how hard it is to express things clearly.

Python is probably one of the most popular languages in the direction of achieving being both descriptive and useful.
See section about this point.

This is discussed in the corresponding section.

\subsection{A New Language}

A new language is needed, something descriptive and efficient enough.
With efficient we do not necessary mean that is faster than C, for example, we mean that its execution or evaluation time in a human scale.
This language needs to have a human size.
In other words, a human needs to be able to follow what it is written, and determine whether it is right or wrong.
This does not mean that a computer cannot help, but it means that a computer is not needed to understand its operation.
This language needs a way of using it.
This is discussed in the corresponding section.


\section{Why a Language}

To check that an AI system is following ethical principles, it is required to have a system that checks it.

The encoding of ethical values and principles should be reachable to those affected.
If ethical values are encoded in very complex formalisms are not reachable to the affected humans, and could be highly error prone.

The purpose of the language is to have formal specifications that can be \textbf{easily understood by a human reader}, and can be immediately prototyped.
This is used to verify if ethical values are properly encoded in a verification system.

Human-centered specifications are intended to be clearly understood by human.
Please note that this is not necessarily the most abstract form of specification, since a very abstract specification could be hard to understand for the intended reader.

As a rule of thumb, the \textbf{intended reader} is a human that can read a formal specification, probably a second-year undergraduate student of a scientific or engineering course of studies.

There is a marked distinction between the reader and the writer.
In standard formalisms, it is common to find that the gap from reading to writing in that formalism can be small or even trivial.

This is not necessary in the language we are presenting.
The language to be very easily, although not necessarily very easily written.

The \textbf{intended writer} is then an experienced technician that can model ethical values using the provided constructs, but producing a highly readable description.


\section{Properties for the Language}

This section discusses what kind of language is needed.

The following is a list of properties required for a useful specification language for ethical problems.

At most:
\begin{itemize}
    \item Formal semantics
    \item Consistency
    \item Decidability
\end{itemize}

At least:
\begin{itemize}
    \item Unary predicates, properties or types
    \item Relations or binary predicates
    \item Logical connectors
    \item Distinction and counting
    \item States or time
    \item Specific domains
\end{itemize}


\section{At-most requirements}

\subsection{Formal semantics}

(filter $\leq $)

A formal semantics is intended to give meaning to the language.
This could be used not only to present to humans, but also to prove formal properties on the language.
This allows for rewriting to have consistency checking and/or formal verification.

(This discards most of the informally developed programming languages.)

\subsection{Consistency}

(filter $\leq $)

The language has to produce consistent specifications.
Consistency is a key property to ensure that a system really follows what is has been specified.
In other words, if a specification is not consistent, it is not usable.

Please note that this requires that descriptions are well-defined.
Some programming languages handle undefined values poorly, letting a program throw an exception when this occurs, instead of preventing it from happening in the first place.

(This property is maybe obvious, but discards unusable formal languages.)

\subsection{Decidability}

(filter $\leq $)

Decidability is intended to ensure that an answer exists and it is computable.
This comes, of course, to a gray area, since decidability has a high price tag by reducing expressivenes.
Thus, the requirement is to have a language with a well defined useful decidable fragment.


\section{At-least requirements}

\subsection{Unary predicates, properties or types}

(filter $\geq $)

Predicates and properties are a very natural way of expressing ideas.
If a formal language does not have them, it becomes more intricate to read.

(This discards low-expressive formalisms, like proposition logic.)

\subsection{Logical connectors}

(filter $\geq $)

The language should include some logical connectors used in natural languages.
Things like \textit{and}, \textit{or}, \textit{not} should be able to be expressed in a direct way.

(This discards many decidable fragments of FOL, like lightweight description logics. )

\subsection{Distinction and counting}

(filter $\geq $)

Expressing distinction is a simple way to count.
Without distinction, there is no way to say ``at least 3 elements''.

Even if it is possible, some formalisms do not provide constructs to do it.
In other words, to say that a set has at least 3 elements, we need to explicitly mention $a, b, c$, and then state
$\{a, b, c\} \subseteq A$, $a \neq b$, $a \neq c$, $b \neq c$.

This grows quadratically in the number of elements.
This is not human friendly, and a construct should be provided, something like $size(A) \geq 3$

(This discards formalisms without counting.)

\subsection{Relations or binary predicates}

(filter $\geq $)

Relating objects is necessary to express basic ideas.
For example, to express that something belongs to someone, it is necessary to relate two elements.
An alternative would be creating separate predicates for each object or for each owner.
This grows linearly in the number of properties (for objects or owners) and it is not human friendly.

(This discards formalisms without relations.)

\subsection{States or time}

(filter $\geq $)

It should be possible to reflect the conceptual idea of time and a sequence.
This means that things happen in a certain order, there is a \textit{before} and an \textit{after}.
In addition, in these transitions, there are \textit{states} associated.
This is a human way of understanding \textit{how things go}.

(This discards formalisms without states.)

\subsection{Specific domains}

(filter $\geq $)

It should be possible to describe things going without modelling them completely.
This means, for example, using operations with floating point, without specifying how floating point works.
When modelling problems, it is reasonable to assume that underlying types would work as expected.

(This discard formalisms that cannot use specific domains / concrete domains.)



