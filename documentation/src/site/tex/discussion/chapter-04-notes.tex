\chapter{Decisions}

\section{Why and why not}

\subsection{Mutability}
Mutable structures are extremely error prone, since a variable can change its value without any apparent change.

Example:

/* a = ?, b = ?, c = ? */
a = C(5)

/* a = C(5), b = ?, c = ? */
b = compute(a)

/* a = C(6), b = C(a), c = ? */
c = compute(b)
/* a = C(6), b = C(7), c = C(7) */


compute(a)
a.increment(1)
return a


expected
/* a = ?, b = ?, c = ? */
a = C(5)

/* a = C(5), b = ?, c = ? */
b = compute(a)

/* a = C(5), b = C(6), c = ? */
c = compute(b)
/* a = C(5), b = C(6), c = C(7) */

\subsection{Tuples}

The use of tuple can hide an error in design.
Unlike sequences, tuples may accept different types in their components.

For example,

("Jon", true, true, false)

is far less legible than

Individual(name := "Jon", registered := true, evaluated := true, passed := true)

\subsection{Meaningful tabulations}

In Python, horizontal tabulations can make a big difference.

This is the intended snippet:

if x > 0:
positive = True
y = x
else:
positive = False
y = 0


This function has a bug, since it always assigns 0 to variable $y$.

if x > 0:
positive = True
y = x
else:
positive = False
y = 0

This kind of bug is for a 6-line snippet.
This can propagate when thousands of lines are written.

In Scala 3, it is possible to define classes using a similar criterion.
We decided to avoid this notation, because \Soda also allows declaring classes inside classes.

If we used this type of notation in \Soda, this could produce a similar type of error:

Original expected declaration

class A = {
    ...
}

class B = {
    ...
}

With this notation
class A:
...

class B:
...

With a bug:
class A:
...
class B:
...

In the last example, class B is part of class A.
The compiler will accept it, and a human can accept it.

In addition, Scala 3 accepts declaring functions outside classes, which \Soda does not.

