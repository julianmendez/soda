/*
 * This file is automatically generated. Do not edit.
 */

package soda.lib

/**
 * This class contains tail recursive auxiliary functions.
 */
* Recursion = {

  @tailrec
  _rec_fold4[A, B, C subtype B](
             sequence: Seq[A],
             current_value: C,
             next_value_function: (B, A) -> C,
             condition: (B, A) -> Boolean
         ): C =
    if sequence.isEmpty
    then current_value
    else
      if not condition(current_value, sequence.head)
      then current_value
      else _rec_fold4(sequence.tail, next_value_function(current_value, sequence.head), next_value_function, condition)

  fold[A, B, C subtype B](
      sequence: Seq[A],
      initial_value: C,
      next_value_function: (B, A) -> C,
      condition: (B, A) -> Boolean
  ): C =
    _rec_fold4(sequence, initial_value, next_value_function, condition)

  @tailrec
  _rec_fold3[A, B, C subtype B](
             sequence: Seq[A],
             current_value: C,
             next_value_function: (B, A) -> C
         ): C =
    if sequence.isEmpty
    then current_value
    else _rec_fold3(sequence.tail, next_value_function(current_value, sequence.head), next_value_function)

  fold[A, B, C subtype B](
      sequence: Seq[A],
      initial_value: C,
      next_value_function: (B, A) -> C
  ): C =
    _rec_fold3(sequence, initial_value, next_value_function)

  @tailrec
  _rec_range(n: Int, sequence: Seq[Int]): Seq[Int] =
    if n <= 0
    then sequence
    else _rec_range(n - 1, sequence.+:(n - 1))

  range(length: Int): Seq[Int] =
    _rec_range(length, Seq[Int]())
}

* Recursion_() extends Recursion
