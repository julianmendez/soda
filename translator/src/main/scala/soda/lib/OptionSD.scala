/*
 * This file is automatically generated. Do not edit.
 */

package soda.lib

/**
 * This is an Option implemented without exceptions.
 */
trait OptionSD [A] {

  def open [B]  (ifEmpty: B, ifNonEmpty: A => B ): B

  def toOption: Option [A]

  def toSeq: Seq [A]

  lazy val isEmpty: Boolean =
    open (
      ifEmpty = true, ifNonEmpty = element => false
    )

  lazy val isDefined: Boolean = ! isEmpty

  lazy val nonEmpty: Boolean = ! isEmpty

  def getOrElse (ifEmpty: A ): A

  def fold [B]  (ifEmpty: B, f: A => B ): B = open (ifEmpty, f )

  def map [B]  (mapping: A => B ): OptionSD [B] =
    open (
      ifEmpty = NoneSD [B]  (), ifNonEmpty = element => SomeSD [B]  (mapping (element )  )
    )

  def flatMap [B]  (mapping: A => OptionSD [B]  ): OptionSD [B] =
    open (
      ifEmpty = NoneSD [B]  (), ifNonEmpty = element => mapping (element )
    )
}

case class NoneSD [A] () extends OptionSD [A] {

  def open [B]  (ifEmpty: B, ifNonEmpty: A => B ): B = ifEmpty

  def getOrElse (ifEmpty: A ): A = ifEmpty

  lazy val toOption: None.type = None

  lazy val toSeq: Seq [A] = Seq [A]  ()
}

case class SomeSD [A] (element: A ) extends OptionSD [A] {

  lazy val get: A = element

  def open [B]  (ifEmpty: B, ifNonEmpty: A => B ): B = ifNonEmpty (element )

  def getOrElse (ifEmpty: A ): A = element

  lazy val toOption: Some [A] = Some [A]  (element )

  lazy val toSeq: Seq [A] = Seq [A]  (element )
}

case class OptionSDBuilder [A]  () {

  def build (opt: Option [A]  ): OptionSD [A] =
    if (opt.isEmpty
    ) NoneSD [A]  ()
    else SomeSD [A]  (opt.get )

}
