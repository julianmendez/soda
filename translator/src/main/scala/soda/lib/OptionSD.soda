/*
 * This file is automatically generated. Do not edit.
 */

package soda.lib

/**
 * This is an Option implemented without exceptions.
 */
* OptionSD[A] {

  has open[B](ifEmpty: B, ifNonEmpty: A -> B): B

  has toOption: Option[A]

  has toSeq: Seq[A]

  isEmpty: Boolean =
    open(
      ifEmpty := true,
      ifNonEmpty := element -> false
    )

  isDefined: Boolean = not isEmpty

  nonEmpty: Boolean = not isEmpty

  has getOrElse(ifEmpty: A): A

  fold[B](ifEmpty: B, f: A -> B): B = open(ifEmpty, f)

  map[B](mapping: A -> B): OptionSD[B] =
    open(
      ifEmpty := NoneSD[B](),
      ifNonEmpty := element -> SomeSD[B](mapping(element))
    )

  flatMap[B](mapping: A -> OptionSD[B]): OptionSD[B] =
    open(
      ifEmpty := NoneSD[B](),
      ifNonEmpty := element -> mapping(element)
    )
}

* NoneSD[A] () extends OptionSD[A] {

  open[B](ifEmpty: B, ifNonEmpty: A -> B): B = ifEmpty

  getOrElse(ifEmpty: A): A = ifEmpty

  toOption: None.type = None

  toSeq: Seq[A] = Seq[A]()
}

* SomeSD[A] (element: A) extends OptionSD[A] {

  get: A = element

  open[B](ifEmpty: B, ifNonEmpty: A -> B): B = ifNonEmpty(element)

  getOrElse(ifEmpty: A): A = element

  toOption: Some[A] = Some[A](element)

  toSeq: Seq[A] = Seq[A](element)
}

* OptionSDBuilder[A]() {

  build(opt: Option[A]): OptionSD[A] =
    if opt.isEmpty
    then NoneSD[A]()
    else SomeSD[A](opt.get)

}
