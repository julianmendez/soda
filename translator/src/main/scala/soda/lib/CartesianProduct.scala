/*
 * This file is automatically generated. Do not edit.
 */

package soda.lib

/**
 * This class contains auxiliary functions for combinations.
 */
trait CartesianProduct {

  def _initial_value [T] (seq: Seq [T]  ): Seq [Seq [T]] =
    seq.map (elem => Seq [T]  (elem )  )

  def _next_value [T] (accum: Seq [Seq [T]], seq_a: Seq [T]  ): Seq [Seq [T]] =
    seq_a.flatMap (elem_a =>
      accum.map (seq_b => seq_b.+: (elem_a ) ) )

  def get_cartesian_product [T] (sequences: Seq [Seq [T]]  ): Seq [Seq [T]] =
    {
      lazy val result =
        if (sequences.isEmpty
        ) sequences
        else
          {
            lazy val rev_sequences = sequences.reverse
            Recursion_ () .fold (rev_sequences.tail, _initial_value (rev_sequences.head ), _next_value [T]  ) }
      result }

}

case class CartesianProduct_ () extends CartesianProduct
