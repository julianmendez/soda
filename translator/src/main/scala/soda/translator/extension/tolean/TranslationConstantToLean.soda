
/**
 * This class contains constants that are specific for the Soda translator, like reserved words for Soda and Lean.
 */

class TranslationConstantToLean

  import
    soda.translator.parser.SodaConstant_

  soda_constant = SodaConstant_ ()

  lean_space = " "

  lean_new_line = "\n"

  lean_function_definition_symbol = ":="

  lean_type_membership_symbol = ":"

  lean_subtype_symbol = "<:"

  lean_supertype_symbol = ">:"

  lean_function_arrow_symbol = "->"

  lean_empty_string = ""

  lean_vertical_bar_symbol = "|"

  lean_match_end_translation = ""

  lean_opening_parenthesis = "("

  lean_closing_parenthesis = ")"

  lean_opening_comment = "/-"

  lean_closing_comment = "-/"

  lean_opening_documentation = "/--"

  lean_closing_documentation = "-/"

  lean_some_variable_name = "x"

  lean_opening_brace = "{"

  lean_closing_brace = "}"

  lean_product_type_symbol = "*"

  lean_constructor_symbol = "::"

  lean_lambda_arrow_symbol = "=>"

  lean_case_arrow_symbol = "=>"

  lean_case_translation = lean_vertical_bar_symbol + lean_space

  lean_not_reserved_word = "notb"

  lean_and_symbol = "&&"

  lean_or_symbol = "||"

  lean_end_symbol = ""

  lean_set_reserved_word : String = "Set"

  lean_type_reserved_word : String = "Type"

  lean_decidable_eq_type_name : String = "DecidableEq"

  lean_inductive_end_symbol : String = lean_end_symbol

  lean_definition_end_symbol : String = lean_end_symbol

  lean_recursive_definition_end_symbol : String = lean_end_symbol

  lean_theorem_end_symbol : String = lean_end_symbol

  lean_by_reserved_word : String = "by"

  lean_calc_reserved_word : String = "calc"

  lean_def_reserved_word : String = "def"

  lean_deriving_reserved_word : String = "deriving"

  lean_do_reserved_word : String = "do"

  lean_else_reserved_word : String = "else"

  lean_end_reserved_word : String = "end"

  lean_example_reserved_word : String = "example"

  lean_fun_reserved_word = "fun"

  lean_if_reserved_word : String = "if"

  lean_import_reserved_word : String = "import"

  lean_in_reserved_word : String = "in"

  lean_inductive_reserved_word : String = "inductive"

  lean_infix_reserved_word : String = "infix"

  lean_instance_reserved_word : String = "instance"

  lean_let_reserved_word : String = "let"

  lean_match_reserved_word : String = "match"

  lean_namespace_reserved_word : String = "namespace"

  lean_notation_reserved_word : String = "notation"

  lean_open_reserved_word : String = "open"

  lean_set_option_reserved_word : String = "set_option"

  lean_structure_reserved_word : String = "structure"

  lean_then_reserved_word : String = "then"

  lean_theorem_reserved_word : String = "theorem"

  lean_where_reserved_word : String = "where"

  lean_with_reserved_word : String = "with"

  lean_hash_check_reserved_word : String = "#check"

  lean_hash_eval_reserved_word : String = "#eval"

  lean_hash_print_reserved_word : String = "#print"

  lean_hash_reduce_reserved_word : String = "#reduce"

  lean_recursive_definition_reserved_word : String = lean_def_reserved_word

  lean_namespace_end_reserved_word : String = lean_end_reserved_word

  lean_proof_begin_reserved_word : String = ""

  lean_proof_end_reserved_word : String = lean_end_reserved_word

  lean_reserved_words : Seq [String] =
    Seq (
      lean_by_reserved_word ,
      lean_calc_reserved_word ,
      lean_def_reserved_word ,
      lean_deriving_reserved_word ,
      lean_do_reserved_word,
      lean_else_reserved_word ,
      lean_end_reserved_word,
      lean_example_reserved_word ,
      lean_fun_reserved_word ,
      lean_if_reserved_word ,
      lean_import_reserved_word ,
      lean_in_reserved_word ,
      lean_inductive_reserved_word ,
      lean_infix_reserved_word ,
      lean_instance_reserved_word ,
      lean_let_reserved_word ,
      lean_match_reserved_word  ,
      lean_namespace_reserved_word ,
      lean_notation_reserved_word ,
      lean_open_reserved_word ,
      lean_set_option_reserved_word ,
      lean_structure_reserved_word ,
      lean_then_reserved_word ,
      lean_theorem_reserved_word ,
      lean_where_reserved_word ,
      lean_with_reserved_word ,
      lean_hash_check_reserved_word ,
      lean_hash_eval_reserved_word ,
      lean_hash_print_reserved_word ,
      lean_hash_reduce_reserved_word
    )

  lean_prelude : Seq [String] =
    Seq (
      ""
    )

  lean_recursive_function_prefixes : Seq [String] =
    Seq (
      "rec_",
      "_rec_",
      "tailrec_",
      "_tailrec_",
      "@tailrec"
    )

  non_definition_block_prefixes : Seq [String] =
    Seq (
      soda_constant .package_reserved_word ,
      soda_constant .import_reserved_word ,
      soda_constant .class_end_reserved_word ,
      soda_constant .class_reserved_word ,
      soda_constant .comment_opening_symbol
    )

  type_symbols_translation : Seq [Tuple2 [String] [String] ] =
    Seq (
      Tuple2 (soda_constant .subtype_reserved_word, lean_subtype_symbol),
      Tuple2 (soda_constant .supertype_reserved_word, lean_supertype_symbol),
      Tuple2 (soda_constant .function_arrow_symbol, lean_function_arrow_symbol)
    )

  function_symbols_translation : Seq [Tuple2 [String] [String] ] =
    Seq (
      Tuple2 (soda_constant .function_definition_symbol , lean_function_definition_symbol),
      Tuple2 (soda_constant .lambda_reserved_word , lean_fun_reserved_word),
      Tuple2 (soda_constant .any_reserved_word , lean_fun_reserved_word),
      Tuple2 (soda_constant .lambda_arrow_symbol , lean_lambda_arrow_symbol),
      Tuple2 (soda_constant .case_arrow_symbol , lean_case_arrow_symbol),
      Tuple2 (soda_constant .not_reserved_word , lean_not_reserved_word),
      Tuple2 (soda_constant .and_reserved_word , lean_and_symbol),
      Tuple2 (soda_constant .or_reserved_word , lean_or_symbol)
    )

  type_translation : Seq [ Tuple2 [String] [String]  ] =
    Seq (
        Tuple2 ("Boolean" , "Bool"),
        Tuple2 ("Nat" , "Nat"),
        Tuple2 ("Option" , "Option"),
        Tuple2 ("List" , "List"),
        Tuple2 ("String" , "String"),
        Tuple2 ("Tuple2" , "Prod")
    )

  prefix_lean_non_soda : String = "__soda__"

  lean_non_soda : Seq [Tuple2 [String] [String] ] =
    lean_reserved_words
      .filter (lambda x --> not soda_constant .soda_reserved_words  .contains (x))
      .map (lambda x --> Tuple2 (x , prefix_lean_non_soda + x) )

  is_lean_word (word : String) : Boolean =
    lean_reserved_words  .contains (word)

  is_soda_word (word : String) : Boolean =
    soda_constant .soda_reserved_words .contains (word)

end

