package soda.translator.extension.toscala

/**
 * This class translates Soda source code into Scala source code.
 */
* MicroTranslatorToScala
  extends soda.translator.block.BlockTranslator = {

  + soda.lib.SomeSD_
  + soda.translator.block.Block
  + soda.translator.block.Block_
  + soda.translator.replacement.CommentPreprocessor_
  + soda.translator.replacement.ParserStateEnum_
  + soda.translator.replacement.Replacement_
  + soda.translator.replacement.Token
  + soda.translator.replacement.Token_
  + soda.translator.replacement.Tokenizer_
  + soda.translator.replacement.Translator

  source = "soda"

  target = "scala"

  tc = TranslationConstantToScala_ ()

  new_line = "\n"

  soda_opening_parenthesis: String = "("

  synonym_at_beginning = DefaultTranslator_ (tc.synonym_at_beginning)

  translation_at_beginning_with_paren = DefaultTranslator_ (tc.translation_at_beginning_with_paren)

  translation_at_beginning_without_paren_for_type_alias =
      DefaultTranslator_ (tc.translation_at_beginning_without_paren_for_type_alias)

  translation_at_beginning_without_paren =
      DefaultTranslator_ (tc.translation_at_beginning_without_paren)

  synonym = DefaultTranslator_ (tc.synonym)

  main_translation = DefaultTranslator_ (tc.main_translation)

  scala_non_soda = DefaultTranslator_ (tc.scala_non_soda)

  beautifier = DefaultTranslator_ (tc.beautifier)

  translate (block: Block): Block =
    SomeSD_ (block)
      .map (join_lines_with_forward_join)
      .map (preprocess_let_in_commands)
      .map (preprocess_match_case_commands)
      .map (join_lines_with_backward_join)
      .map (translate_lines)
      .value

  join_lines_with_forward_join (block: Block): Block =
    Block_ (
      LineJoinerToScala_ (block.lines).joined_lines_with_forward_join
    )

  join_lines_with_backward_join (block: Block): Block =
    Block_ (
      LineJoinerToScala_ (block.lines).joined_lines_with_backward_join
    )

  translate_lines (block: Block): Block =
    Block_ (
      CommentPreprocessor_ (block.lines)
        .annotated_lines
        .map (annotated_line ->
          if annotated_line.isComment
          then annotated_line.line
          else _translate_non_comment (annotated_line.line)
        )
    )

  _translate_non_comment (line: String): String =
      SomeSD_ (line)
        .map (x -> Replacement_ (x).add_space_to_soda_line ().line)
        .map (x -> Tokenizer_ (x).tokens)
        .map (x -> _translate_line (x))
        .map (x -> _join_tokens (x))
        .map (x -> Replacement_ (x).remove_space_from_scala_line ().line)
        .value

  _translate_line (tokens: Seq[Token]): Seq[Token] =
    tokens.map (
      token ->
        if token.parser_state == ParserStateEnum_ ().plain
        then Token_ (_get_all_replacements (token), token.parser_state, token.index)
        else token
    )

  _get_all_replacements (token: Token): String =
    Replacement_ (token.text)
      .add_spaces_to_symbols (symbols := tc.soda_brackets_and_comma.toSet)
      .replace (scala_non_soda)
      .replace_at_beginning (token.index, synonym_at_beginning)
      .replace (synonym)
      .replace_with (try_definition)
      .replace_at_beginning (token.index, get_translation_table_at_beginning (token.text))
      .replace (main_translation)
      .replace_regex (beautifier)
      .line

  get_translation_table_at_beginning (line: String): Translator =
    if line.contains (soda_opening_parenthesis)
    then translation_at_beginning_with_paren
    else
      if DefinitionTranslatorToScala_ (line).condition_for_type_alias
      then translation_at_beginning_without_paren_for_type_alias
      else translation_at_beginning_without_paren

  try_definition (line: String): String =
    DefinitionTranslatorToScala_ (line).translation

  _join_tokens (tokens: Seq[Token]): String =
    tokens
      .map (token -> token.text)
      .mkString ("")

  preprocess_let_in_commands (block: Block): Block =
    Block_ (
      block.lines
        .map (line -> replace_all_when (line, starts_with, tc.soda_in_let_pattern, tc.scala_in_let_translation) )
        .map (line -> replace_all_when (line, are_trim_equal, tc.soda_in_let_pattern.trim, tc.scala_in_let_translation) )
        .map (line -> append_if_condition (line, starts_with, tc.soda_in_pattern, tc.scala_in_translation) )
    )

  preprocess_match_case_commands (block: Block): Block =
    Block_ (
      block.lines
        .map (line -> insert_match_before_brace_if_found (line) )
    )

  starts_with (line: String, pattern: String): Boolean =
    line.trim.startsWith (pattern)

  are_trim_equal (line: String, pattern: String): Boolean =
    (line.trim == pattern.trim)

  replace_all_when (line: String, condition: (String, String) -> Boolean, pattern: String, new_text: String): String =
    if condition (line, pattern)
    then line.replaceAll (pattern, new_text)
    else line

  append_if_condition (line: String, condition: (String, String) -> Boolean, pattern: String, to_append: String): String =
    if condition (line, pattern)
    then line + to_append
    else line

  insert_match_before_brace_if_found (line: String): String =
    if line.trim ().startsWith (tc.soda_match_pattern)
    then
      let
        index_of_match = line.indexOf (tc.soda_match_pattern)
        left_part = line.substring (0, index_of_match)
        right_part = line.substring (index_of_match + tc.soda_match_pattern.length, line.length)
      in left_part + right_part + tc.scala_match_translation + tc.space + tc.scala_opening_brace
    else line

}

* MicroTranslatorToScala_ ()
  extends MicroTranslatorToScala

* Table = {

  has table: Seq[ (String, String)]

}

* DefaultTranslator
  extends Table
  with soda.translator.replacement.Translator = {

  keys = table.map (pair -> pair._1)

  translate (word: String): String =
    table.toMap.get (word).getOrElse (word)

}

* DefaultTranslator_ (table: Seq[ (String, String)])
  extends DefaultTranslator


