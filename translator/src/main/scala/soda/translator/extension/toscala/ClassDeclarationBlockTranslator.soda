package soda.translator.extension.toscala

* ClassDeclarationBlockTranslator
  extends soda.translator.block.BlockTranslator = {

  import
    soda.translator.block.AnnotatedBlock
    soda.translator.block.BlockAnnotationEnum_
    soda.translator.block.Translator
    soda.translator.blocktr.TokenizedBlockTranslator_
    soda.translator.blocktr.TableTranslator_
    soda.translator.replacement.Replacement
    soda.translator.replacement.Replacement_
    soda.translator.replacement.Token

  soda_opening_parenthesis: String = "("

  tc = TranslationConstantToScala_ ()

  soda_space: String = " "

  scala_space: String = " "

  soda_definition = tc.soda_definition

  scala_3_class_definition = tc.scala_3_class_definition

  space_and_definition = soda_space + soda_definition

  _labels = BlockAnnotationEnum_ ()

  replace_token: Token -> String =
    lambda token ->
      Replacement_ (token.text)
        .replace_at_beginning (token.index, get_table_translator (token.text) )
        .replace_with (_replace_definition_symbol)
        .line

  _replace_definition_symbol (line: String): String =
    if (has_condition_for_type_alias (line))
    then line
    else
      if (line.trim.endsWith (space_and_definition) )
      then line.replaceAll (space_and_definition, scala_3_class_definition)
      else line.replaceAll (space_and_definition, "")

  get_table_translator (line: String): Translator =
    TableTranslator_ (
      Seq (Tuple2 (tc.soda_class_reserved_word, get_class_declaration_translation (line) ) )
    )

  get_class_declaration_translation (line: String): String =
    if line.contains (soda_opening_parenthesis)
    then tc.class_declaration_translation_at_beginning_with_paren
    else
      if has_condition_for_type_alias (line)
      then tc.class_declaration_translation_at_beginning_without_paren_for_type_alias
      else tc.class_declaration_translation_at_beginning_without_paren

  translator = TokenizedBlockTranslator_ (replace_token)

  translate (block: AnnotatedBlock): AnnotatedBlock =
    if block.block_annotation == _labels.class_beginning
      or block.block_annotation == _labels.class_declaration
    then translator.translate (block)
    else block

  translation_of_class_definition (line: String): Replacement =
    if has_condition_for_type_alias (line)
    then Replacement_ (line)
    else Replacement_ (line).replace_all (soda_space + tc.soda_definition, _new_text_for_class_definition (line) )

  _new_text_for_class_definition (line: String): String =
    if ends_with_equals (line)
    then tc.scala_3_class_definition
    else ""

  ends_with_equals (line: String): Boolean =
    line.trim.endsWith (tc.soda_definition)

  ends_with_opening_brace (line: String): Boolean =
    line.trim.endsWith (tc.soda_opening_brace)

  contains_equals (line: String): Boolean =
    line.trim.contains (tc.soda_definition)

  has_condition_for_type_alias (line: String): Boolean =
    contains_equals (line) and not (ends_with_equals (line) or ends_with_opening_brace (line) )

}

* ClassDeclarationBlockTranslator_ ()
  extends ClassDeclarationBlockTranslator

