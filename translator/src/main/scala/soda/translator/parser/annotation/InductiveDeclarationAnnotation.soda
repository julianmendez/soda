
class ConstructorTuple

  abstract
    name : String
    parameters : Seq [String]

  parameters_without_last : Seq [String] =
    parameters .dropRight (1)

end

class InductiveDeclarationAnnotation
  extends
    BlockAnnotationParser

  abstract
    block : soda.translator.block.Block

  import
    soda.translator.block.AnnotatedLine
    soda.translator.block.BlockAnnotationEnum
    soda.translator.block.BlockAnnotationId
    soda.translator.parser.SodaConstant

  identifier : BlockAnnotationId = BlockAnnotationEnum .mk .inductive_declaration

  _sc = SodaConstant .mk

  first_line : String =
    if block .readable_lines .nonEmpty
    then block .readable_lines .head .line .trim + _sc .space
    else ""

  applies : Boolean =
    first_line .startsWith (_sc .inductive_reserved_word + _sc .space) or
    first_line .startsWith (_sc .data_reserved_word + _sc .space) or
    first_line .startsWith (_sc .datatype_reserved_word + _sc .space)

  _get_parameters (line : String) : Seq [String] =
    _sc .constructor_parameter_separation_regex
      .r
      .replaceAllIn (line,
        lambda m --> m .matched .replaceAll (_sc .function_arrow_symbol , _sc .placeholder_symbol) )
      .split (_sc .function_arrow_symbol)
      .map (lambda piece --> piece .replaceAll(_sc .placeholder_symbol , _sc .function_arrow_symbol) )
      .toList

  _make_constructor_from_line_with (line : String) (index : Int) : ConstructorTuple =
    if index >= 0
    then ConstructorTuple .mk (
      line .substring (0 , index) .trim) (
      _get_parameters (line .substring (index + _sc .type_membership_symbol .length) ) )
    else ConstructorTuple .mk (line .trim) (Seq [String] () )

  make_constructor_from_line (line : String) : ConstructorTuple =
    _make_constructor_from_line_with (line) (line .indexOf (_sc .type_membership_symbol) )

  constructors_with_comments : Seq [AnnotatedLine] =
    content_lines

  constructors : Seq [ConstructorTuple] =
    constructors_with_comments
      .filter (lambda line --> not line .is_comment)
      .map (lambda annotated_line --> annotated_line .line)
      .map (lambda line --> make_constructor_from_line (line) )

  _class_name_for (line : String) (word : String) : String =
    if first_line .startsWith (word + _sc .space)
    then line .substring (line .indexOf (word) + word .length) .trim
    else ""

  class_name_and_parameters : String =
    _class_name_for (first_readable_line .line) (_sc .inductive_reserved_word) +
    _class_name_for (first_readable_line .line) (_sc .data_reserved_word) +
    _class_name_for (first_readable_line .line) (_sc .datatype_reserved_word)

  class_name : String =
    class_name_and_parameters
      .split ("\\[")
      .headOption
      .getOrElse ("")
      .trim

  type_parameters : Seq [String] =
    class_name_and_parameters
      .split ("\\[")
      .flatMap(lambda piece --> piece .split (",") )
      .map (lambda piece --> piece .replaceAll (":.*" , "") .trim )
      .drop (1)
      .toIndexedSeq

end

