package soda.translator.parser

class PreprocessorSequenceTranslator
  extends
    soda.translator.block.BlockSequenceTranslator

  abstract
    translator: soda.translator.block.BlockSequenceTranslator

  import
    soda.translator.block.AnnotatedLine_
    soda.translator.block.AnnotatedBlock
    soda.translator.parser.annotation.AnnotationFactory_
    soda.translator.parser.annotation.AbstractDeclarationAnnotation
    soda.translator.parser.annotation.ClassBeginningAnnotation
    soda.translator.parser.annotation.ClassEndAnnotation
    soda.translator.parser.annotation.ClassEndAnnotation_

  block_annotator = AnnotationFactory_ ()

  ba = soda.translator.block.BlockAnnotationEnum_ ()

  sc = SodaConstant_ ()

  recursion = soda.lib.Recursion_ ()

  empty_line = AnnotatedLine_ ("", true)

  translate: Seq [AnnotatedBlock] -> Seq [AnnotatedBlock] =
    lambda block_sequence ->
      translate_for (block_sequence)

  translate_for (block_sequence: Seq [AnnotatedBlock]): Seq [AnnotatedBlock] =
    translator.translate (
      _get_second_pass (
        _get_first_pass (block_sequence)
      )
    )

  _get_first_pass (block_sequence: Seq [AnnotatedBlock] ): Seq [AnnotatedBlock] =
    block_sequence.map (block -> block_annotator.translate (block) )

  _get_second_pass (block_sequence: Seq [AnnotatedBlock] ): Seq [AnnotatedBlock] =
    recursion
      .fold (
        block_sequence.indices,
        _initial_value (block_sequence),
        _next_value_function
      )
      .accumulated
      .reverse

  _initial_value (block_sequence: Seq [AnnotatedBlock] ): AuxiliaryTuple =
    AuxiliaryTuple_ (
      block_sequence := block_sequence,
      accumulated := Seq [AnnotatedBlock] (),
      references := Seq [Seq [AnnotatedBlock] ] ()
    )

  _next_value_function (current: AuxiliaryTuple, index: Int): AuxiliaryTuple =
    _pass_next_step (current, index, _get_additional_information (current, index) )

  _get_additional_information (current: AuxiliaryTuple, index: Int): AnnotatedBlock =
    match current.block_sequence.apply (index)
      | block: ClassEndAnnotation => _get_updated_block (current, block)
      | x => x
    end

  _get_updated_block (current: AuxiliaryTuple, block: ClassEndAnnotation): ClassEndAnnotation =
    ClassEndAnnotation_ (block.block, block.references.++ (current.references.lastOption.getOrElse (Seq [AnnotatedBlock] () ) ) )

  _pass_next_step (current: AuxiliaryTuple, index: Int, updated_block: AnnotatedBlock ): AuxiliaryTuple =
    AuxiliaryTuple_ (
      block_sequence := current.block_sequence,
      accumulated := current.accumulated.+: (updated_block),
      references := _update_references (current, index)
    )

  _update_references (current: AuxiliaryTuple, index: Int): Seq [Seq [AnnotatedBlock] ] =
    match current.block_sequence.apply (index)
      | b: ClassBeginningAnnotation => current.references.+: (Seq [AnnotatedBlock] (b) )
      | b: AbstractDeclarationAnnotation => _update_first_element (current.references, b)
      | b: ClassEndAnnotation => _tail_non_empty (current.references)
      | x => current.references
    end

  _update_first_element (s: Seq [Seq [AnnotatedBlock] ], b: AnnotatedBlock): Seq [Seq [AnnotatedBlock] ] =
    _tail_non_empty (s).+: (s.headOption.getOrElse (Seq [AnnotatedBlock] () ).+: (b) )

  _tail_non_empty [T] (s: Seq [T]): Seq [T] =
    if s.isEmpty
    then s
    else s.tail

end

class PreprocessorSequenceTranslator_ (translator: soda.translator.block.BlockSequenceTranslator)
  extends
    PreprocessorSequenceTranslator

end

class AuxiliaryTuple

  abstract
    block_sequence: Seq [soda.translator.block.AnnotatedBlock]
    accumulated: Seq [soda.translator.block.AnnotatedBlock]
    references: Seq [ Seq [soda.translator.block.AnnotatedBlock] ]

end

class AuxiliaryTuple_ (block_sequence: Seq [soda.translator.block.AnnotatedBlock], accumulated: Seq [soda.translator.block.AnnotatedBlock], references: Seq [Seq [soda.translator.block.AnnotatedBlock] ] )
  extends
    AuxiliaryTuple

end

