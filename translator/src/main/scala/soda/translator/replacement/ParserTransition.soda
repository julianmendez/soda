package soda.translator.replacement


/**
 * This models all the possible states that the parser can be.
 */
* ParserState extends soda.lib.EnumConstant

* ParserState_(ordinal: Int, name: String) extends ParserState

* ParserStateConstant = {

  undefined_state = ParserState_(0, "undefined_state")

  quotes_state = ParserState_(1, "quotes_state")

  apostrophe_state = ParserState_(2, "apostrophe_state")

  quotes_backslash_state = ParserState_(3, "quotes_backslash_state")

  apostrophe_backslash_state = ParserState_(4, "apostrophe_backslash_state")

  plain = ParserState_(5, "plain")

  parser_state_values = Seq(undefined_state, quotes_state, apostrophe_state, quotes_backslash_state, apostrophe_backslash_state, plain)
}

/**
 * This is an enumeration of all the parser states.
 */
* ParserStateEnum extends ParserStateConstant = {

  values = parser_state_values

  is_same_class(x: ParserState, y: ParserState): Boolean =
    (x == y) or is_like(x, y) or is_like(y, x)

  is_like(x: ParserState, y: ParserState): Boolean =
    (x == quotes_state and y == quotes_backslash_state) or
      (x == apostrophe_state and y == apostrophe_backslash_state)
}

* ParserStateEnum_() extends ParserStateEnum

* ParserTransition = {

  ps = ParserStateEnum_()

  ct = CharTypeEnum_()

  transitions_that_change_states: Map[(ParserState, CharType), ParserState] =
    Map(
      /* */
      ((ps.quotes_state, ct.undefined_type), ps.undefined_state),
      ((ps.quotes_state, ct.quotes_type), ps.plain),
      ((ps.quotes_state, ct.backslash_type), ps.quotes_backslash_state),
      /* */
      ((ps.apostrophe_state, ct.undefined_type), ps.undefined_state),
      ((ps.apostrophe_state, ct.apostrophe_type), ps.plain),
      ((ps.apostrophe_state, ct.backslash_type), ps.apostrophe_backslash_state),
      /* */
      ((ps.quotes_backslash_state, ct.undefined_type), ps.undefined_state),
      ((ps.quotes_backslash_state, ct.quotes_type), ps.quotes_state),
      ((ps.quotes_backslash_state, ct.apostrophe_type), ps.quotes_state),
      ((ps.quotes_backslash_state, ct.backslash_type), ps.quotes_state),
      ((ps.quotes_backslash_state, ct.plain_type), ps.quotes_state),
      /* */
      ((ps.apostrophe_backslash_state, ct.undefined_type), ps.undefined_state),
      ((ps.apostrophe_backslash_state, ct.quotes_type), ps.apostrophe_state),
      ((ps.apostrophe_backslash_state, ct.apostrophe_type), ps.apostrophe_state),
      ((ps.apostrophe_backslash_state, ct.backslash_type), ps.apostrophe_state),
      ((ps.apostrophe_backslash_state, ct.plain_type), ps.apostrophe_state),
      /* */
      ((ps.plain, ct.undefined_type), ps.undefined_state),
      ((ps.plain, ct.quotes_type), ps.quotes_state),
      ((ps.plain, ct.apostrophe_type), ps.apostrophe_state),
      ((ps.plain, ct.backslash_type), ps.plain),
      ((ps.plain, ct.plain_type), ps.plain)
    )

  next_parser_state(parser_state: ParserState, char_type: CharType): ParserState =
    transitions_that_change_states.getOrElse((parser_state, char_type), parser_state)
}

* ParserTransition_() extends ParserTransition

