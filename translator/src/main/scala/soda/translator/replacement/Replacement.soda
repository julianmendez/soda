package soda.translator.replacement

/**
 * This models a collection of replacement functions.
 * This is intended to be used as a pipeline.
 */
* Replacement
  extends soda.translator.block.SingleLineProcessor = {

  + soda.translator.block.Translator

  aux = ReplacementAux_ ()

  soda_space = aux.soda_space

  replace_with (function: String -> String): Replacement =
    Replacement_ (function (line))

  replace_at_beginning (index: Int, translator: Translator): Replacement =
    Replacement_ (aux.replace_at_beginning (line, index, translator))

  replace_all (pattern: String, replacement: String): Replacement =
    Replacement_ (aux.replace_all (line, pattern, replacement))

  replace (translator: Translator): Replacement =
    Replacement_ (aux.replace (line, translator))

  add_space_to_soda_line (): Replacement =
    Replacement_ (soda_space + line + soda_space)

  add_spaces_to_symbols (symbols: Set [Char]): Replacement =
    Replacement_ (aux.add_spaces_to_symbols (line, symbols))

  remove_space_from_scala_line (): Replacement =
    Replacement_ (aux.remove_space_from_scala_line (line))

  add_after_spaces_or_pattern (pattern: String, text_to_prepend: String): Replacement =
    Replacement_ (aux.add_after_spaces_or_pattern (line, pattern, text_to_prepend))

  replace_regex (translator: Translator): Replacement =
    Replacement_ (aux.replace_regex (line, translator))

}

* Replacement_ (line: String)
  extends Replacement

* ReplacementAux = {

 + soda.translator.block.Translator
 + soda.lib.Recursion_

  soda_space = " "

  scala_space = " "

  replace_at_beginning (line: String, index: Int, translator: Translator): String =
    if index == 0
    then replace_only_beginning (line, translator)
    else line

  replace_only_beginning (line: String, translator: Translator): String =
    let
      initial_value: String = line
      next_value_function (line: String, reserved_word: String): String =
        replace_if_found_at_beginning (line,
          soda_space + reserved_word + soda_space, scala_space + translator.translate (reserved_word) + scala_space)
    in Recursion_ ().fold (translator.keys, initial_value, next_value_function)

  replace_if_found_at_beginning (line: String, pattern: String, new_text: String): String =
    if line.trim.startsWith (pattern.trim)
    then replace_all (line, pattern, new_text)
    else line

  replace (line: String, translator: Translator): String =
    let
      initial_value: String = line
      next_value_function (line: String, reserved_word: String): String =
        replace_if_found (line,
          soda_space + reserved_word + soda_space, scala_space + translator.translate (reserved_word) + scala_space)
    in Recursion_ ().fold (translator.keys, initial_value, next_value_function)

  replace_if_found  (line: String, pattern: String, new_text: String): String =
    if line.contains  (pattern)
    then replace_all  (line, pattern, new_text)
    else line

  replace_all  (line: String, pattern: String, replacement: String): String =
    Replacer_ (line, pattern, replacement).replaced_text

  add_spaces_to_symbols  (line: String, symbols: Set [Char]): String =
    line.indices.map (index ->
      let
        ch = line  (index)
      in _left_part_of_symbols  (line, symbols, index, ch) + ch + _right_part_of_symbols  (line, symbols, index, ch)
    ).mkString ("")

  _left_part_of_symbols  (line: String, symbols: Set [Char], index: Int, ch: Char): String =
    if  (index > 0) and symbols.contains  (ch) and
      not line  (index - 1).isWhitespace
    then scala_space
    else ""

  _right_part_of_symbols  (line: String, symbols: Set [Char], index: Int, ch: Char): String =
    if  (index < line.length - 1) and symbols.contains  (ch) and
      not line  (index + 1).isWhitespace
    then scala_space
    else ""

  remove_space_from_scala_line  (line: String): String =
    _get_line_without_ending_space ( _get_line_without_starting_space (line) )

  _get_line_without_starting_space (line: String): String =
    if line.startsWith (scala_space)
    then line.substring (1)
    else line

  _get_line_without_ending_space (line: String): String =
    if line.endsWith (scala_space)
    then line.substring (0, line.length - 1)
    else line

  add_after_spaces_or_pattern (line: String, pattern: String, text_to_prepend: String): String =
    let
      prefix_length =
        if line.trim.startsWith (pattern)
        then line.indexOf (pattern) + pattern.length
        else line.takeWhile (ch -> ch.isSpaceChar).length
    in line.substring (0, prefix_length) + text_to_prepend + line.substring (prefix_length)

  replace_regex (line: String, translator: Translator): String =
    let
      initial_value: String = line
      next_value_function (line: String, regex: String): String =
        line.replaceAll (regex, translator.translate (regex))
    in Recursion_ ().fold (translator.keys, initial_value, next_value_function)

}

* ReplacementAux_ ()
  extends ReplacementAux

