package soda.translator.replacement


/**
 * This models a collection of replacement functions.
 * This is intended to be used as a pipeline.
 */
* Replacement = {
  + soda.lib.Rec

  has line: String

  soda_space: String = " "
  scala_space: String = " "

  replace_with(function: String -> String): Replacement =
    ReplacementImpl(function(line))

  replace_at_beginning(index: Int, translator: Translator): Replacement =
    ReplacementImpl(replace_at_beginning(line, index, translator))

  replace_at_beginning(line: String, index: Int, translator: Translator): String =
    if index == 0
    then replace_only_beginning(line, translator)
    else line

  replace_only_beginning(line: String, translator: Translator): String =
    let
      initial_value: String = line

      next_value(line: String, reserved_word: String): String =
        _replace_if_found(line,
          soda_space + reserved_word + soda_space, scala_space + translator.translate(reserved_word) + scala_space)

    in Rec().foldLeft(translator.keys, initial_value, next_value)

  _replace_if_found(line: String, pattern: String, new_text: String): String =
    if line.trim.startsWith(pattern.trim)
    then replace_all(line, pattern, new_text)
    else line

  replace_all(pattern: String, replacement: String): Replacement =
    ReplacementImpl(replace_all(line, pattern, replacement))

  replace(translator: Translator): Replacement =
    ReplacementImpl(replace(line, translator))

  replace(line: String, translator: Translator): String =
    let
      initial_value: String = line

      next_value(line: String, reserved_word: String): String =
        replace_if_found(line,
          soda_space + reserved_word + soda_space, scala_space + translator.translate(reserved_word) + scala_space)

    in Rec().foldLeft(translator.keys, initial_value, next_value)

  replace_if_found(line: String, pattern: String, new_text: String): String =
    if line.contains(pattern)
    then replace_all(line, pattern, new_text)
    else line

  replace_all(line: String, pattern: String, replacement: String): String =
    ReplacerImpl(line, pattern, replacement).replace

  add_space_to_soda_line(): Replacement =
    ReplacementImpl(soda_space + line + soda_space)

  add_spaces_to_symbols(symbols: Set[Char]): Replacement =
    ReplacementImpl(add_spaces_to_symbols(line, symbols))

  add_spaces_to_symbols(line: String, symbols: Set[Char]): String =
    line.indices.map(index ->
      let
        ch = line(index)
        left_part =
          if (index > 0) and symbols.contains(ch) and
            not line(index - 1).isWhitespace
          then scala_space
          else ""
        right_part =
          if (index < line.length - 1) and symbols.contains(ch) and
            not line(index + 1).isWhitespace
          then scala_space
          else ""

      in left_part + ch + right_part
    ).mkString("")

  remove_space_from_scala_line(): Replacement =
    ReplacementImpl(remove_space_from_scala_line(line))

  remove_space_from_scala_line(line: String): String =
    let
      line_without_starting_space =
        if line.startsWith(scala_space)
        then line.substring(1)
        else line
      line_without_ending_space =
        if line_without_starting_space.endsWith(scala_space)
        then line_without_starting_space.substring(0, line_without_starting_space.length - 1)
        else line_without_starting_space
    in line_without_ending_space

  add_after_spaces(text_to_prepend: String): Replacement =
    ReplacementImpl(add_after_spaces(line, text_to_prepend))

  add_after_spaces(line: String, text_to_prepend: String): String =
    let
      prefix_length = line.takeWhile(ch -> ch.isSpaceChar).length
    in line.substring(0, prefix_length) + text_to_prepend + line.substring(prefix_length)

  replace_regex(translator: Translator): Replacement =
    ReplacementImpl(replace_regex(line, translator))

  replace_regex(line: String, translator: Translator): String =
    let
      initial_value: String = line
      next_value(line: String, regex: String): String =
        line.replaceAll(regex, translator.translate(regex))
    in Rec().foldLeft(translator.keys, initial_value, next_value)
}

* ReplacementImpl(line: String) extends Replacement

* Replacer = {
  + soda.lib.Rec

  has line: String

  has pattern: String

  has replacement: String

  replace =
    postproc( Rec().foldLeftWhile( Rec().range(line.length), initial_value, next_value, condition ) )

  initial_value = ReplacerFoldTuple( Seq(), 0 )

  next_value(tuple: ReplacerFoldTuple, x: Int): ReplacerFoldTuple =
    _next_tuple(
      replaced_text_rev := tuple.replaced_text_rev,
      start_index := tuple.start_index,
      pos := line.indexOf(pattern, tuple.start_index)
    )

  _next_tuple(replaced_text_rev: Seq[String], start_index: Int, pos: Int): ReplacerFoldTuple =
    if pos == -1
    then ReplacerFoldTuple( replaced_text_rev.+:(line.substring(start_index)), pos )
    else
      let
        new_replaced_text_rev = (replaced_text_rev.+:(line.substring(start_index, pos))).+:(replacement)
        new_index = pos + pattern.length
      in ReplacerFoldTuple( new_replaced_text_rev, new_index )

  condition(tuple: ReplacerFoldTuple, x: Int): Boolean =
    not (tuple.start_index == -1)

  postproc(tuple: ReplacerFoldTuple): String =
    tuple.replaced_text_rev.reverse.mkString("")
}

* ReplacerImpl(line: String, pattern: String, replacement: String) extends Replacer

* ReplacerFoldTuple(replaced_text_rev: Seq[String], start_index: Int)

