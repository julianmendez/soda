package soda.translator.replacement


* AnnotatedLine = {

  has line: String

  has isComment: Boolean
}

* AnnotatedLine_(line: String, isComment: Boolean) extends AnnotatedLine

/**
 * This preprocessor annotates lines to determine whether they are comments.
 */
* CommentPreprocessor = {
  + soda.lib.Recursion_

  has lines: Seq[String]

  soda_begin_comment = "/*"

  soda_end_comment = "*/"

  annotated_lines: Seq[AnnotatedLine] =
    Recursion_().fold(lines, initial_value, next_value_function)
      .annotated_lines_rev
      .reverse

  initial_value = PreprocessorFoldTuple_(false, Seq())

  next_value_function(pair: PreprocessorFoldTuple, line: String): PreprocessorFoldTuple =
    let
      t = annotate_this_line(line, pair.comment_state)
    in PreprocessorFoldTuple_(t.new_comment_state,
        pair.annotated_lines_rev.+:(AnnotatedLine_(line, t.current_state)))

  annotate_this_line(line: String, comment_state: Boolean): CurrentAndNewCommentState =
    if comment_state
    then CurrentAndNewCommentState_(true, not line.trim.endsWith(soda_end_comment))
    else
      if line.trim.startsWith(soda_begin_comment)
      then CurrentAndNewCommentState_(true, not line.trim.endsWith(soda_end_comment))
      else CurrentAndNewCommentState_(false, false)
}

* CommentPreprocessor_(lines: Seq[String]) extends CommentPreprocessor

* PreprocessorFoldTuple = {

  has comment_state: Boolean

  has annotated_lines_rev: Seq[AnnotatedLine]
}

* PreprocessorFoldTuple_(comment_state: Boolean, annotated_lines_rev: Seq[AnnotatedLine]) extends PreprocessorFoldTuple

* CurrentAndNewCommentState = {

  has current_state: Boolean

  has new_comment_state: Boolean
}

* CurrentAndNewCommentState_(current_state: Boolean, new_comment_state: Boolean) extends CurrentAndNewCommentState

