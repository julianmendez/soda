package soda.translator.blocktr

* TokenizedBlockTranslator
  extends soda.translator.block.BlockTranslator = {

  + soda.lib.SomeSD_
  + soda.translator.block.Block
  + soda.translator.parser.BlockBuilder_
  + soda.translator.block.Translator
  + soda.translator.replacement.ParserStateEnum_
  + soda.translator.replacement.Replacement_
  + soda.translator.replacement.Token
  + soda.translator.replacement.Token_
  + soda.translator.replacement.Tokenizer_

  has replace_token: Token -> String

  translate (block: Block): Block =
    BlockBuilder_ ().build (
      block
        .annotated_lines
        .map (annotated_line ->
          if annotated_line.is_comment
          then annotated_line.line
          else _translate_non_comment (annotated_line.line)
        )
    )

  _translate_non_comment (line: String): String =
      SomeSD_ (line)
        .map (x -> Replacement_ (x).add_space_to_soda_line ().line)
        .map (x -> Tokenizer_ (x).tokens)
        .map (x -> _translate_line (x))
        .map (x -> _join_tokens (x))
        .map (x -> Replacement_ (x).remove_space_from_scala_line ().line)
        .value

  _translate_line (tokens: Seq [Token]): Seq [Token] =
    tokens.map (
      token ->
        if token.parser_state == ParserStateEnum_ ().plain
        then Token_ (replace_token (token), token.parser_state, token.index)
        else token
    )

  _join_tokens (tokens: Seq [Token]): String =
    tokens
      .map (token -> token.text)
      .mkString ("")

}

* TokenizedBlockTranslator_ (replace_token: soda.translator.replacement.Token -> String)
  extends TokenizedBlockTranslator

