package soda.translator.blocktr

* Joiner = {

  + soda.lib.Recursion_

  has lines_to_join: Seq [String]

  has is_a_join:  (String, String) -> Boolean

  join: Seq [String] = reverse_join.reverse

  reverse_join: Seq [String] =
    if lines_to_join.isEmpty
    then lines_to_join
    else
      let
        tuple = Recursion_ ().fold (lines_to_join.tail, _initial_value_function (lines_to_join.head), _next_value_function)
        result =
          if tuple.in_process_rev.isEmpty
          then tuple.processed_rev.+: (tuple.previous_line)
          else tuple.processed_rev.+: (_rev_list_as_element (tuple.in_process_rev, tuple.previous_line))
      in result

  _initial_value_function (first_line: String): JoinerFoldTuple =
    JoinerFoldTuple_ (Seq (), Seq (), first_line)

  _next_value_function (tuple: JoinerFoldTuple, head: String): JoinerFoldTuple =
    if is_a_join (tuple.previous_line.trim, head.trim)
    then JoinerFoldTuple_ (tuple.in_process_rev.+: (tuple.previous_line), tuple.processed_rev, head)
    else
      let
        processed_line = _rev_list_as_element (tuple.in_process_rev, tuple.previous_line)
      in JoinerFoldTuple_ (Seq (), tuple.processed_rev.+: (processed_line), head)

  _rev_list_as_element (in_process_rev: Seq [String], line: String): String =
    in_process_rev.reverse.mkString ("") + line

}

* Joiner_ (lines_to_join: Seq [String], is_a_join:  (String, String) -> Boolean)
  extends Joiner

* JoinerFoldTuple = {

  has in_process_rev: Seq [String]

  has processed_rev: Seq [String]

  has previous_line: String

}

* JoinerFoldTuple_ (in_process_rev: Seq [String], processed_rev: Seq [String], previous_line: String)
  extends JoinerFoldTuple

