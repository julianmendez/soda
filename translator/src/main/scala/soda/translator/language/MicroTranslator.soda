package soda.translator.language


/**
 * This class translates Soda source code into Scala source code.
 */
* MicroTranslator = {
  + soda.lib.SomeElem
  + soda.translator.replacement.CommentPreprocessorImpl
  + soda.translator.replacement.ParserStateEnum
  + soda.translator.replacement.ReplacementImpl
  + soda.translator.replacement.Token
  + soda.translator.replacement.TokenizerImpl
  + soda.translator.replacement.Translator

  NewLine = "\n"
  SodaOpeningParenthesis: String = "("

  SynonymAtBeginning = DefaultTranslatorImpl(Translation().SynonymAtBeginning)
  TranslationAtBeginningWithParen = DefaultTranslatorImpl(Translation().TranslationAtBeginningWithParen)
  TranslationAtBeginningWithoutParen = DefaultTranslatorImpl(Translation().TranslationAtBeginningWithoutParen)
  Synonym = DefaultTranslatorImpl(Translation().Synonym)
  MainTranslation = DefaultTranslatorImpl(Translation().MainTranslation)
  ScalaNonSoda = DefaultTranslatorImpl(Translation().ScalaNonSoda)
  Beautifier = DefaultTranslatorImpl(Translation().Beautifier)

  translate_program(program: String): String =
    SomeElem(program)
      .map(split_lines)
      .map(join_lines_with_forward_join)
      .map(preprocess_let_in_commands)
      .map(join_lines_with_backward_join)
      .map(translate_lines)
      .map(join_translated_lines)
      .get

  split_lines (program: String): Seq[String] =
    program.split(NewLine).toIndexedSeq

  join_lines_with_forward_join(lines: Seq[String]): Seq[String] =
    LineJoinerImpl(lines).get_joined_lines_with_forward_join

  join_lines_with_backward_join(lines: Seq[String]): Seq[String] =
    LineJoinerImpl(lines).get_joined_lines_with_backward_join

  join_translated_lines (lines: Seq[String]): String =
    lines.mkString(NewLine) + NewLine

  translate_lines(lines: Seq[String]): Seq[String] =
    CommentPreprocessorImpl(lines)
      .get_annotated_lines
      .map(annotated_line ->
        if annotated_line.isComment
        then annotated_line.line
        else _translate_non_comment(annotated_line.line)
      )

  _translate_non_comment(line: String): String =
      SomeElem(line)
        .map(x -> ReplacementImpl(x).add_space_to_soda_line().line)
        .map(x -> TokenizerImpl(x).get_tokens)
        .map(x -> _translate_line(x))
        .map(x -> _join_tokens(x))
        .map(x -> ReplacementImpl(x).remove_space_from_scala_line().line)
        .get

  _translate_line(tokens: Seq[Token]): Seq[Token] =
    tokens.map(
      token ->
        if token.parser_state == ParserStateEnum().Plain
        then Token(_get_all_replacements(token), token.parser_state, token.index)
        else token
    )

  _get_all_replacements(token: Token): String =
    ReplacementImpl(token.text)
      .add_spaces_to_symbols(symbols := Translation().SodaBracketsAndComma.toSet)
      .replace(ScalaNonSoda)
      .replace_at_beginning(token.index, SynonymAtBeginning)
      .replace(Synonym)
      .replace_with(try_definition)
      .replace_at_beginning(token.index, get_translation_table_at_beginning(token.text))
      .replace(MainTranslation)
      .replace_regex(Beautifier)
      .line

  get_translation_table_at_beginning(line: String): Translator =
    if line.contains(SodaOpeningParenthesis)
    then TranslationAtBeginningWithParen
    else TranslationAtBeginningWithoutParen

  try_definition(line: String): String =
    DefinitionTranslatorImpl(line).get_translation

  _join_tokens(tokens: Seq[Token]): String =
    tokens
      .map(token -> token.text)
      .mkString("")

  preprocess_let_in_commands(lines: Seq[String]): Seq[String] =
    lines.map(line ->
      append_if_condition(line, starts_with_in, Translation().ScalaInTranslation) )

  starts_with_in(line: String): Boolean =
    line.trim().startsWith(Translation().SodaInPattern)

  append_if_condition(line: String, condition: String -> Boolean, to_append: String): String =
    if condition(line)
    then line + to_append
    else line
}

* MicroTranslatorImpl() extends MicroTranslator

* DefaultTranslator extends soda.translator.replacement.Translator = {

  has table: Seq[(String, String)]

  keys = table.map(pair -> pair._1)

  translate(word: String): String =
    table.toMap.get(word).getOrElse(word)
}

* DefaultTranslatorImpl(table: Seq[(String, String)]) extends DefaultTranslator

