package soda.translator.language

+ soda.lib.Rec
+ soda.lib.OptionSD
+ soda.lib.NoneSD
+ soda.lib.SomeSD
+ soda.lib.OptionSDBuilder
+ soda.translator.replacement.CommentPreprocessor
+ soda.translator.replacement.ParserStateEnum
+ soda.translator.replacement.Replacement
+ soda.translator.replacement.Token
+ soda.translator.replacement.Tokenizer
+ soda.translator.replacement.Translator


/**
 * This class translates Soda source code into Scala source code.
 */
* MicroTranslator() = {

  NewLine = "\n"
  Comma = ","

  SodaOpeningParenthesis: String = "("
  SodaClosingParenthesis: String = ")"
  SodaOpeningBracket: String = "["
  SodaClosingBracket: String = "]"
  SodaSpace: String = " "
  ScalaSpace: String = " "

  translate_program(program: String): String = {
    original_lines = split_lines(program)
    lines_to_translate = join_lines_ending_with_comma_or_opening_parenthesis(original_lines)
    translated_lines = translate_lines(lines_to_translate)
    join_translated_lines (translated_lines)
  }

  split_lines (program: String): Seq[String] =
    program.split(NewLine).toIndexedSeq

  join_lines_ending_with_comma_or_opening_parenthesis(lines: Seq[String]): Seq[String] = {
    result = processed_lines.reverse

    processed_lines = {
      pairs = Rec().foldLeft(lines, initial_value, next_value)
      if pairs.in_process_rev.isEmpty
      then pairs.processed_rev
      else pairs.processed_rev.+:(rev_list_as_element(pairs.in_process_rev, ""))
    }

    * FoldTuple(in_process_rev: Seq[String], processed_rev: Seq[String])

    initial_value = FoldTuple(Seq(), Seq())

    next_value(pair: FoldTuple, head: String): FoldTuple =
      if head.trim().endsWith(Comma) or head.trim().endsWith(SodaOpeningParenthesis)
      then FoldTuple(pair.in_process_rev.+:(head), pair.processed_rev)
      else {
        new_head = rev_list_as_element(pair.in_process_rev, head)
        FoldTuple(Seq(), pair.processed_rev.+:(new_head))
      }

    rev_list_as_element(in_process_rev: Seq[String], line: String): String =
      in_process_rev.reverse.mkString("") + line

    result
  }

  join_translated_lines (lines: Seq[String]): String =
    lines.mkString(NewLine) + NewLine

  tokenize(line: String): Seq[Token] =
    Tokenizer().tokenize(line)

  translate_lines(lines: Seq[String]): Seq[String] =
    CommentPreprocessor()
      .annotate_lines(lines)
      .map(annotated_line ->
        if annotated_line.isComment
        then annotated_line.line
        else _translate_non_comment(annotated_line.line)
      )

  _translate_non_comment(line: String): String = {
    line_with_space = Replacement(line).add_space_to_soda_line().line
    tokenized_line = tokenize(line_with_space)
    translated_line = _translate_line(tokenized_line)
    joint_line = _join_tokens(translated_line)
    final_line = Replacement(joint_line).remove_space_from_scala_line().line
    final_line
  }

  _translate_line(tokens: Seq[Token]): Seq[Token] =
    tokens.map(
      token ->
        if token.parser_state == ParserStateEnum().Plain
        then {
          newText = Replacement(token.text)
            .add_spaces_to_symbols(symbols := Translation().SodaBracketsAndComma.toSet)
            .replace(ScalaNonSoda(), only_beginning := false)
            .replace_at_beginning(token.index, SynonymAtBeginning())
            .replace(Synonym(), only_beginning := false)
            .replace_with(try_definition)
            .replace_with(try_extends_between_square_brackets)
            .replace_at_beginning(token.index, get_translation_table_at_beginning(token.text))
            .replace(MainTranslation(), only_beginning := false)
            .replace_regex(Beautifier())
            .line
          Token(newText, token.parser_state, token.index)
        }
        else token
    )

  get_translation_table_at_beginning(line: String): Translator =
    if line.contains(SodaOpeningParenthesis)
    then TranslationAtBeginningWithParen()
    else TranslationAtBeginningWithoutParen()

  /**
   * A line containing the definition sign will be classified as a definition.
   * The definitions need to be identified as 'val', 'def', or 'class'.
   *
   * 'class' is for class definition.
   * It is detected if the 'class' reserved word is also in the same line.
   *
   * 'val' is for value definition.
   * It is detected in three cases.
   * Case 1: The line does not have a opening parenthesis, e.g. `a = 1`
   * Case 2: The first opening parenthesis is after the definition sign, e.g. `x = f(y)`
   * Case 3: The first opening parenthesis is after a colon, e.g. `x: (A, B) -> C = (x, y) -> f(x,y)`
   *
   * 'def' is for function definition.
   * If it does not fit in any of the 'val' cases.
   *
   * Formerly there was another case for 'val'.
   * Deprecated Case: The first non-blank character of a line is an open parenthesis, e.g. `(x, y) = (0, 1)`
   * This was implemented simply as:
   *  `line.trim.startsWith(SodaOpeningParenthesis)`
   * This is no longer supported.
   *
   * @param line line
   * @return a translated line
   */
  try_definition(line: String): String = {

    result = find_definition(line).open(
      ifEmpty := line,
      ifNonEmpty := position -> try_found_definition(position).line
    )

    try_found_definition(position: Int): Replacement =
      if is_class_definition then translate_class_definition
      else if is_val_definition(position) then translate_val_definition
      else translate_def_definition

    is_class_definition =
      indexOf(line, SodaSpace + Translation().SodaClassReservedWord + SodaSpace).isDefined

    is_val_definition(initial_position: Int) = {
      position_of_first_opening_parenthesis = indexOf(line, SodaOpeningParenthesis)

      case1 = position_of_first_opening_parenthesis.isEmpty
      case2 = position_of_first_opening_parenthesis.open(false, position -> position > initial_position)
      case3 =
        indexOf(line, Translation().SodaColon).open(
          ifEmpty := false,
          ifNonEmpty := other_position ->
            position_of_first_opening_parenthesis.open(false, position -> position > other_position)
        )

      case1 or case2 or case3
    }

    translate_class_definition =
      Replacement(line).replace_all(SodaSpace + Translation().SodaDefinition, "")

    translate_val_definition =
      Replacement(line).add_after_spaces( Translation().ScalaValue + ScalaSpace )

    translate_def_definition =
      Replacement(line).add_after_spaces( Translation().ScalaDefinition + ScalaSpace )

    result
  }


  /**
   * A line is a definition when its main operator is "=" (the equals sign), which in this context is also called the definition sign.
   * This function finds the first occurrence of the definition sign, if it is present.
   *
   * @param line line
   * @return maybe the position of the definition sign
   */
  find_definition(line: String): OptionSD[Int] =
    if line.endsWith(SodaSpace + Translation().SodaDefinition)
    then SomeSD(line.length - Translation().SodaDefinition.length)
    else indexOf(line, SodaSpace + Translation().SodaDefinition + SodaSpace)

  indexOf(line: String, pattern: String): OptionSD[Int] = indexOf(line, pattern, 0)

  indexOf(line: String, pattern: String, start: Int): OptionSD[Int] =
    OptionSDBuilder().build(
      value := line.indexOf(pattern, start),
      condition := (position: Int) -> not (position == -1)
    )

  /**
   * This tries to replace an `extends` by a subtype restriction, to define an upper bound of a parametric type.
   * This only applies to a parameter that is between square brackets.
   * @param line line
   * @return maybe a translated line
   */
  try_extends_between_square_brackets (line: String): String = {
    result = Rec().foldLeft(find_square_brackets(line), initial_value, next_value)

    initial_value = line

    next_value(line: String, position: Excerpt): String = {
      substr = line.substring(position.beginning, position.end)
      new_substr = Replacement(substr)
        .replace(TranslationBetweenSquareBrackets(), only_beginning := false)
        .line
      if substr == new_substr
      then line
      else line.substring(0, position.beginning) + new_substr + line.substring(position.end)
    }

    result
  }

  find_square_brackets(line: String): Seq[Excerpt] = {
    result =
      Rec()
        .foldLeftWhile(Rec().range(line.length), initial_value, next_value, condition)
        .positions

    initial_value = FoldTuple(Seq(), 0)

    next_value(tuple: FoldTuple, x: Int): FoldTuple =
      find_square_brackets(line, tuple.start).open(
        ifEmpty := FoldTuple(tuple.positions, -1),
        ifNonEmpty := pair ->
          FoldTuple(tuple.positions.+:(pair), pair.end + SodaClosingBracket.length)
      )

    condition(tuple: FoldTuple, x: Int): Boolean =
      (0 <= tuple.start and tuple.start <= line.length)

    * FoldTuple(positions: Seq[Excerpt], start: Int)

    result
  }

  find_square_brackets(line: String, start: Int): OptionSD[Excerpt] =
    SomeSD(true)
      .filter(x -> start >= 0 and start < line.length)
      .flatMap(x -> indexOf(line, SodaOpeningBracket, start)
        .flatMap(left -> indexOf(line, SodaClosingBracket, left + SodaOpeningBracket.length)
          .map(right -> Excerpt(left + SodaOpeningBracket.length, right) )
        )
      )

  _join_tokens(tokens: Seq[Token]): String =
    tokens
      .map(token -> token.text)
      .mkString("")

  * Excerpt(beginning: Int, end: Int)

}

