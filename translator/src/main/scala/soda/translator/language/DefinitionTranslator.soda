package soda.translator.language


/**
 * A line containing the definition sign will be classified as a definition.
 * The definitions need to be identified as 'val', 'def', or 'class'.
 *
 * 'class' is for class definition.
 * It is detected if the 'class' reserved word is also in the same line.
 *
 * 'val' is for value definition.
 * It is detected in three cases.
 * Case 1: The line does not have a opening parenthesis, e.g. `a = 1`
 * Case 2: The first opening parenthesis is after the definition sign, e.g. `x = f(y)`
 * Case 3: The first opening parenthesis is after a colon, e.g. `x: (A, B) -> C = (x, y) -> f(x,y)`
 *
 * 'def' is for function definition.
 * If it does not fit in any of the 'val' cases.
 *
 * Formerly there was another case for 'val'.
 * Deprecated Case: The first non-blank character of a line is an open parenthesis, e.g. `(x, y) = (0, 1)`
 * This was implemented simply as:
 * `line.trim.startsWith(soda_opening_parenthesis)`
 * This is no longer supported.
 *
 */
* DefinitionTranslator = {
  + soda.lib.OptionSD
  + soda.lib.SomeSD_
  + soda.translator.replacement.Replacement
  + soda.translator.replacement.Replacement_

  has line: String

  soda_space: String = " "

  scala_space: String = " "

  translation =
    find_definition(line).opt(
      ifEmpty := line,
      ifNonEmpty := position -> try_found_definition(position).line
    )

  is_class_definition =
    get_index(line, soda_space + TranslationConstant_().soda_class_reserved_word + soda_space).isDefined

  translation_of_class_definition =
    let
      new_text =
        if ends_with_equals
        then TranslationConstant_().scala_3_class_definition
        else ""
      result =
        if condition_for_type_alias
        then Replacement_(line)
        else Replacement_(line).replace_all(soda_space + TranslationConstant_().soda_definition, new_text)
    in result

  ends_with_equals =
    line.trim().endsWith(TranslationConstant_().soda_definition)

  ends_with_opening_brace =
    line.trim().endsWith(TranslationConstant_().soda_opening_brace)

  contains_equals =
    line.trim().contains(TranslationConstant_().soda_definition)

  condition_for_type_alias =
    contains_equals and not (ends_with_equals or ends_with_opening_brace)

  translation_of_val_definition =
    Replacement_(line).add_after_spaces( TranslationConstant_().scala_value + scala_space )

  translation_of_def_definition =
    Replacement_(line).add_after_spaces( TranslationConstant_().scala_definition + scala_space )

  try_found_definition(position: Int): Replacement =
    if is_class_definition then translation_of_class_definition
    else if is_val_definition(position) then translation_of_val_definition
    else translation_of_def_definition

  is_val_definition(initial_position: Int): Boolean =
    let
      position_of_first_opening_parenthesis = get_index(line, TranslationConstant_().soda_opening_parenthesis)
      is_case_1 = position_of_first_opening_parenthesis.isEmpty
      is_case_2 = position_of_first_opening_parenthesis.opt(false, position -> position > initial_position)
      is_case_3 =
        get_index(line, TranslationConstant_().soda_colon).opt(
          ifEmpty := false,
          ifNonEmpty := other_position ->
            position_of_first_opening_parenthesis.opt(false, position -> position > other_position)
        )
    in is_case_1 or is_case_2 or is_case_3

  /**
   * A line is a definition when its main operator is "=" (the equals sign), which in this context is also called the definition sign.
   * This function finds the first occurrence of the definition sign, if it is present.
   *
   * @param line line
   * @return maybe the position of the definition sign
   */
  find_definition(line: String): OptionSD[Int] =
    if line.endsWith(soda_space + TranslationConstant_().soda_definition)
    then SomeSD_(line.length - TranslationConstant_().soda_definition.length)
    else get_index(line, soda_space + TranslationConstant_().soda_definition + soda_space)

  get_index(line: String, pattern: String): OptionSD[Int] =
    get_index(line, pattern, 0)

  get_index(line: String, pattern: String, start: Int): OptionSD[Int] =
    SomeSD_(line.indexOf(pattern, start))
      .filter(position -> not (position == -1))
}

* DefinitionTranslator_(line: String) extends DefinitionTranslator

