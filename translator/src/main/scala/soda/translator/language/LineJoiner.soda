package soda.translator.language


* LineJoiner = {

  has lines: Seq[String]

  comma = ","

  soda_opening_parenthesis: String = "("

  soda_closing_parenthesis: String = ")"

  soda_opening_bracket: String = "["

  soda_closing_bracket: String = "]"

  space = " "

  joined_lines_with_forward_join: Seq[String] =
    JoinerImpl(lines, is_a_forward_join).join

  joined_lines_with_backward_join: Seq[String] =
    JoinerImpl(lines, is_a_backward_join).join

  is_a_forward_join(previous_line: String, current_line: String): Boolean =
    is_a_symbol_forward_join(previous_line) or
    is_a_reserved_word_forward_join(previous_line)

  is_a_symbol_forward_join(previous_line: String): Boolean =
    Translation().symbol_forward_joiner
      .exists(previous_line.endsWith)

  is_a_reserved_word_forward_join(previous_line: String): Boolean =
    Translation().reserved_word_joiner
      .map(x -> space + x)
      .exists(previous_line.endsWith)

  is_a_backward_join(previous_line: String, current_line: String): Boolean =
    is_a_symbol_backward_join(current_line) or
    is_a_reserved_word_backward_join(current_line)

  is_a_symbol_backward_join(current_line: String): Boolean =
    Translation().symbol_backward_joiner
      .exists(current_line.startsWith)

  is_a_reserved_word_backward_join(current_line: String): Boolean =
    Translation().reserved_word_joiner
      .map(x -> x + space)
      .exists(current_line.startsWith)
}

* LineJoinerImpl(lines: Seq[String]) extends LineJoiner

* Joiner = {
  + soda.lib.Rec

  has lines_to_join: Seq[String]

  has is_a_join: (String, String) -> Boolean

  join: Seq[String] = reverse_join.reverse

  reverse_join: Seq[String] =
    if lines_to_join.isEmpty
    then lines_to_join
    else
      let
        tuple = Rec().fold(lines_to_join.tail, _initial_value(lines_to_join.head), _next_value)
        result =
          if tuple.in_process_rev.isEmpty
          then tuple.processed_rev.+:(tuple.previous_line)
          else tuple.processed_rev.+:(_rev_list_as_element(tuple.in_process_rev, tuple.previous_line))
      in result

  _initial_value(first_line: String): JoinerFoldTuple =
    JoinerFoldTuple(Seq(), Seq(), first_line)

  _next_value(tuple: JoinerFoldTuple, head: String): JoinerFoldTuple =
    if is_a_join(tuple.previous_line.trim, head.trim)
    then JoinerFoldTuple(tuple.in_process_rev.+:(tuple.previous_line), tuple.processed_rev, head)
    else
      let
        processed_line = _rev_list_as_element(tuple.in_process_rev, tuple.previous_line)
      in JoinerFoldTuple(Seq(), tuple.processed_rev.+:(processed_line), head)

  _rev_list_as_element(in_process_rev: Seq[String], line: String): String =
    in_process_rev.reverse.mkString("") + line
}

* JoinerImpl(lines_to_join: Seq[String], is_a_join: (String, String) -> Boolean)
  extends Joiner

* JoinerFoldTuple(in_process_rev: Seq[String], processed_rev: Seq[String], previous_line: String)

