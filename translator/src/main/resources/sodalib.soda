/*
 * This file is automatically generated. Do not edit.
 */

package soda.lib

/*  ********  */

/**
 * This is a constant to be used in enumerations.
 */
* EnumConstant {

  has ordinal: Int

  has name: String

  @override
  toString: String = "" + ordinal + "-" + name
}

/*  ********  */

/**
 * This is an Option implemented without exceptions.
 */
* OptionSD[T] {

  has isEmpty: Boolean

  has open[B](ifEmpty: B, ifNonEmpty: T -> B): B

  has map[B](mapping: T -> B): OptionSD[B]
}

* NoneSD[T] () extends OptionSD[T] {

  isEmpty = true

  open[B](ifEmpty: B, ifNonEmpty: T -> B): B = ifEmpty

  map[B](mapping: T -> B): NoneSD[B] = NoneSD[B]()
}

* SomeSD[T] (element: T) extends OptionSD[T] {

  isEmpty = false

  get: T = element

  open[B](ifEmpty: B, ifNonEmpty: T -> B): B = ifNonEmpty(element)

  map[B](mapping: T -> B): SomeSD[B] = SomeSD[B](mapping(element))
}

/*  ********  */

/**
 * This class contains auxiliary functions for combinations.
 */
* Comb() {

  cartesianProduct[T](sequences: Seq[Seq[T]]): Seq[Seq[T]] = {
    result =
      if sequences.isEmpty
      then sequences
      else {
        rev_sequences = sequences.reverse
        Rec().foldLeft(rev_sequences.tail, initial_value(rev_sequences.head), next_value)
      }

    initial_value(seq: Seq[T]): Seq[Seq[T]] = seq.map(elem -> Seq(elem))

    next_value(accum: Seq[Seq[T]], seq_a: Seq[T]): Seq[Seq[T]] =
      seq_a.flatMap(elem_a ->
        accum.map(seq_b -> seq_b.+:(elem_a) ) )

    result
  }

}

/*  ********  */

/**
 * This class contains tail recursive auxiliary functions.
 */
* Rec() {


  foldLeftWhile[A, B, C extends B](s: Seq[A], initial_value: C,
      next_value: (B, A) -> C, cond: (B, A) -> Boolean): C = {

    result = rec(s, initial_value, next_value, cond)

    @tailrec
    rec(seq: Seq[A], acc: C, next_value: (B, A) -> C,
        cond: (B, A) -> Boolean): C =
      if seq.isEmpty
      then acc
      else
        if not cond(acc, seq.head)
        then acc
        else rec(seq.tail, next_value(acc, seq.head), next_value, cond)

    result
  }


  foldLeft[A, B, C extends B](seq: Seq[A], initial_value: C,
      next_value: (B, A) -> C): C = {

    result = rec(seq, initial_value, next_value)

    @tailrec
    rec(seq: Seq[A], acc: C, next_value: (B, A) -> C): C =
      if seq.isEmpty
      then acc
      else rec(seq.tail, next_value(acc, seq.head), next_value)

    result
  }


  range(n: Int): Seq[Int] = {

    result = rec(n, Seq[Int]())

    @tailrec
    rec(n: Int, seq: Seq[Int]): Seq[Int] =
      if n <= 0
      then seq
      else rec(n - 1, seq.+:(n - 1))

    result
  }

}

