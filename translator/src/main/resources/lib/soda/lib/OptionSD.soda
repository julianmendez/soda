/*
 * This file is automatically generated. Do not edit.
 */

package soda.lib

/**
 * This is an Option implemented without exceptions.
 */
* OptionSD[A] = {

  has opt[B](ifEmpty: B, ifNonEmpty: A -> B): B

  isEmpty: Boolean =
    opt(ifEmpty := true, ifNonEmpty := element -> false)

  isDefined: Boolean = not isEmpty

  nonEmpty: Boolean = not isEmpty

  toOption: Option[A] =
    opt(ifEmpty := None, ifNonEmpty := element -> Some[A](element))

  toSeq: Seq[A] =
    opt(ifEmpty := Seq(), ifNonEmpty := element -> Seq(element))

  getOrElse(default: A): A =
    opt(ifEmpty := default, ifNonEmpty := element -> element)

  fold[B](ifEmpty: B, f: A -> B): B =
    opt(ifEmpty, f)

  map[B](mapping: A -> B): OptionSD[B] =
    opt(
      ifEmpty := NoneSD[B](),
      ifNonEmpty := element -> SomeSD[B](mapping(element))
    )

  flatMap[B](mapping: A -> OptionSD[B]): OptionSD[B] =
    opt(
      ifEmpty := NoneSD[B](),
      ifNonEmpty := element -> mapping(element)
    )

  filter(predicate: A -> Boolean): OptionSD[A] =
    opt(
      ifEmpty := this,
      ifNonEmpty := element -> if predicate(element) then this else NoneSD[A]()
    )

}

* NoneSD[A] () extends OptionSD[A] = {

  opt[B](ifEmpty: B, ifNonEmpty: A -> B): B = ifEmpty

}

* SomeSD[A] (element: A) extends OptionSD[A] = {

  get: A = element

  opt[B](ifEmpty: B, ifNonEmpty: A -> B): B = ifNonEmpty(element)

}

* OptionSDBuilder[A]() = {

  build(option: Option[A]): OptionSD[A] =
    if option.isEmpty
    then NoneSD[A]()
    else SomeSD[A](option.get)

}

