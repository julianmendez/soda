/*
 * This file is automatically generated. Do not edit.
 */

package soda.lib

/**
 * This class contains auxiliary functions for combinations.
 */

trait CartesianProduct
{

  def _initial_value [A] (seq: Seq [A] ): Seq [Seq [A]] =
    seq.map (elem => Seq [A] (elem )  )

  def _next_value [A] (accum: Seq [Seq [A]], seq_a: Seq [A] ): Seq [Seq [A]] =
    seq_a.flatMap (elem_a =>
      accum.map (seq_b => seq_b.+: (elem_a ) ) )

  def _apply_recursion [A] (rev_sequences: Seq [Seq [A]] ): Seq [Seq [A]] =
    Recursion_ () .fold (rev_sequences.tail, _initial_value (rev_sequences.head ), _next_value [A] )

  def get_cartesian_product [A] (sequences: Seq [Seq [A]] ): Seq [Seq [A]] =
    if (sequences.isEmpty
    ) sequences
    else _apply_recursion (sequences.reverse )

}

case class CartesianProduct_ ()
  extends
    CartesianProduct
{

}
