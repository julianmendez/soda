/*
 * This file is automatically generated. Do not edit.
 */

package soda.lib

/**
 * This class contains auxiliary functions for combinations.
 */

trait CartesianProduct
{

  def apply [A] (sequences : Seq [Seq [A] ] ) : Seq [Seq [A] ] =
    if ( sequences.isEmpty
    ) sequences
    else _apply_recursion (sequences.reverse)

  private def _apply_recursion [A] (rev_sequences : Seq [Seq [A] ] ) : Seq [Seq [A] ] =
    _fold.apply (rev_sequences.tail) (_initial_value (rev_sequences.head) ) (_next_value [A] )

  private lazy val _fold = Fold_ ()

  private def _initial_value [A] (seq : Seq [A] ) : Seq [Seq [A] ] =
    seq.map (  elem => Seq [A] (elem) )

  private def _next_value [A] (accum : Seq [Seq [A] ] ) (seq_a : Seq [A] ) : Seq [Seq [A] ] =
    seq_a.flatMap (  elem_a =>
      accum.map (  seq_b => seq_b.+: (elem_a) ) )

}

case class CartesianProduct_ () extends CartesianProduct
