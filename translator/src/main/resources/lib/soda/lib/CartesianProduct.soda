/*
 * This file is automatically generated. Do not edit.
 */

package soda.lib

/**
 * This class contains auxiliary functions for combinations.
 */

class CartesianProduct

  _initial_value [A] (seq: Seq [A] ): Seq [Seq [A] ] =
    seq.map (elem -> Seq [A] (elem))

  _next_value [A] (accum: Seq [Seq [A] ], seq_a: Seq [A] ): Seq [Seq [A] ] =
    seq_a.flatMap (elem_a ->
      accum.map (seq_b -> seq_b.+: (elem_a) ) )

  _apply_recursion [A] (rev_sequences: Seq [Seq [A] ] ): Seq [Seq [A] ] =
    Recursion_ ().fold (rev_sequences.tail, _initial_value (rev_sequences.head), _next_value [A] )

  get_cartesian_product [A] (sequences: Seq [Seq [A] ] ): Seq [Seq [A] ] =
    if sequences.isEmpty
    then sequences
    else _apply_recursion (sequences.reverse)

end

