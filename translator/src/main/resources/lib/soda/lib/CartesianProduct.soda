/*
 * This file is automatically generated. Do not edit.
 */

/**
 * This class contains auxiliary functions for combinations.
 */

class CartesianProduct

  abstract

  fold = Fold .mk

  _initial [A : Type] (seq : Seq [A] ) : Seq [Seq [A] ] =
    seq .map (lambda elem --> (elem) +: Nil)

  _next [A : Type] (accum : Seq [Seq [A] ] ) (seq : Seq [A] ) : Seq [Seq [A] ] =
    seq .flatMap (lambda elem -->
      accum .map (lambda seq_b --> (elem) +: (seq_b) ) )

  _apply_recursion [A : Type] (rev_sequences : Seq [Seq [A] ] ) : Seq [Seq [A] ] =
    fold [Seq [A] ] [Seq [Seq [A] ] ] (rev_sequences .tail) (
      _initial [A] (rev_sequences .head) ) (_next)

  apply [A : Type] (sequences : Seq [Seq [A] ] ) : Seq [Seq [A] ] =
    if sequences .isEmpty
    then sequences
    else _apply_recursion [A] (sequences .reverse)

end

