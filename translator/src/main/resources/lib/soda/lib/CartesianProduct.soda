/*
 * This file is automatically generated. Do not edit.
 */

package soda.lib

/**
 * This class contains auxiliary functions for combinations.
 */
* CartesianProduct =

  _initial_value [T] (seq: Seq [T]): Seq [Seq [T]] =
    seq.map (elem -> Seq [T] (elem))

  _next_value [T] (accum: Seq [Seq [T]], seq_a: Seq [T]): Seq [Seq [T]] =
    seq_a.flatMap (elem_a ->
      accum.map (seq_b -> seq_b.+: (elem_a) ) )

  _apply_recursion [T] (rev_sequences: Seq [Seq [T]]): Seq [Seq [T]] =
    Recursion_ ().fold (rev_sequences.tail, _initial_value (rev_sequences.head), _next_value [T])

  get_cartesian_product [T] (sequences: Seq [Seq [T]]): Seq [Seq [T]] =
    if sequences.isEmpty
    then sequences
    else _apply_recursion (sequences.reverse)

end

* CartesianProduct_ ()
  extends CartesianProduct

