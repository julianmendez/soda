/*
 * This file is automatically generated. Do not edit.
 */

package soda.lib

/**
 * This is an Option implemented without exceptions.
 */
trait OptionSD [A] {

  def opt [B]  (ifEmpty: B, ifNonEmpty: A => B ): B

  def map [B]  (mapping: A => B ): OptionSD [B]

  def toOption: Option [A]

  lazy val isEmpty: Boolean =
    opt (ifEmpty = true, ifNonEmpty = element => false )

  lazy val isDefined: Boolean = ! isEmpty

  lazy val nonEmpty: Boolean = ! isEmpty

  lazy val toSeq: Seq [A] =
    opt (ifEmpty = Seq (), ifNonEmpty = element => Seq (element )  )

  def getOrElse (default: A ): A =
    opt (ifEmpty = default, ifNonEmpty = element => element )

  def fold [B]  (ifEmpty: B, f: A => B ): B =
    opt (ifEmpty, f )

  def flatMap [B]  (mapping: A => OptionSD [B]  ): OptionSD [B] =
    opt (ifEmpty = NoInst [B]  (), ifNonEmpty = element => mapping (element )    )

  def bind [B]  (mapping: A => OptionSD [B]  ): OptionSD [B] = flatMap [B]  (mapping )

  def filter (predicate: A => Boolean ): OptionSD [A] =
    opt (ifEmpty = this, ifNonEmpty = element => if (predicate (element ) ) this else NoInst [A]  ()    )
}

trait NoneSD [A] extends OptionSD [A] {

  def opt [B]  (ifEmpty: B, ifNonEmpty: A => B ): B = ifEmpty

  def map [B]  (mapping: A => B ): NoneSD [B] = NoInst [B]  ()

  lazy val toOption: None.type = None
}

case class NoInst [A]  () extends NoneSD [A]

trait SomeSD [A] extends OptionSD [A] {

  def element: A

  lazy val get: A = element

  def opt [B]  (ifEmpty: B, ifNonEmpty: A => B ): B = ifNonEmpty (element )

  def map [B]  (mapping: A => B ): SomeSD [B] = SomeInst [B]  (mapping (element )  )

  lazy val toOption: Some [A] = Some [A]  (element )
}

case class SomeInst [A]  (element: A ) extends SomeSD [A]

trait OptionSDBuilder [A] {

  def build (option: Option [A]  ): OptionSD [A] =
    if (option.isEmpty
    ) NoInst [A]  ()
    else SomeInst [A]  (option.get )
}

case class OptionSDBuilderImpl [A]  () extends OptionSDBuilder [A]
