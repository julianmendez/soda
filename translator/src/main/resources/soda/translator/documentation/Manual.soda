package soda.translator.documentation

/*
 * This is a Soda tutorial written in Soda.
 * Copyright 2021 Julian Mendez
 * Version: 2021-08-12
 */

class Shape

class Movable

class ShapePainter[A subtype Shape]

class ShapeMover[A subtype Shape with Movable]

class EqualsExample = {

  answer = f (x := 20, y := 2)

  f (x: Int, y: Int) = 2 * x + y
}

class RegisteredPerson = {

  has first_name: String

  has last_name: String

  _separator = " "

  full_name = first_name + _separator + last_name
}

class Person(name: String)

class Agent = {

  has identifier: String
}

class Agent_(identifier: String) extends Agent

class RankedIndividual = {

  has rank: Int
}

class RankedAgentPerson (identifier: String, rank: Int)
  extends Agent with RankedIndividual

class Element = {

  has accept(v: Visitor): Boolean
}

class Visitor = {

  has visit(x: Element): Boolean
}

class Item (identifier: Int) extends Element = {

  accept (v: Visitor) = v.visit (this)
}

class PersonName = {

  has name: String

  @override
  toString = name
}

/**
  * This contains the examples shown in the manual.
  */
class Manual = {
  import java.util.Date

  a = 1

  b: Int = 2

  now = @new Date()

  plus_one (x: Int): Int = x + 1

  max (x: Int, y: Int): Int =
    if x > y
    then x
    else y

  plus_one (sequence: Seq[Int]): Seq[Int] =
    sequence.map(element -> element + 1)

  my_not (x: Boolean): Boolean =
    if x
    then false
    else true

  my_and (x: Boolean, y: Boolean): Boolean =
    if x
    then
      if y
      then true
      else false
    else false

  my_or (x: Boolean, y: Boolean): Boolean =
    if x
    then true
    else
      if y
      then true
      else false

  my_xor (x: Boolean, y: Boolean) =
    (x or y) and not (x and y)

  sum (n: Int) =
    let
      result = rec (n, 0)

      @tailrec
      rec (n: Int, accum: Int): Int =
        if n < 0
        then accum
        else rec (n - 1, n + accum)

    in result

  f0 (x: Int): Int =
    let
      a = g(x)
      b = g(a)
    in a + b

  f1 (x: Int): Int =
    let
      result = a + b
      a = g(x)
      b = g(a)
    in result

  g (x: Int): Int = x + 1
}

* AbstractFactorialConcise = {

  has factorial (n: Int): Int
}

* FactorialConcise
  extends AbstractFactorialConcise = {

  factorial (n: Int) =
    let
      result = rec (n, 1)

      @tailrec
      rec (n: Int, product: Int): Int =
        if n == 0
        then product
        else rec (n - 1, n * product)

    in result
}

class AbstractFactorialVerbose is {

  has factorial (n: Int): Int
}

class FactorialVerbose
  extends AbstractFactorialVerbose is {

  factorial (n: Int) is
    let
      result is rec (n, 1)

      @tailrec
      rec (n: Int, product: Int): Int is
        if n == 0
        then product
        else rec (n - 1, n * product)

    in result
}

class Recursion = {

  fold[A, B, C subtype B](
      sequence: Seq[A],
      initial_value: C,
      next_value_function: (B, A) -> C,
      condition: (B, A) -> Boolean
  ): C =
    let
      @tailrec
      rec(seq: Seq[A], acc: C): C =
        if seq.isEmpty
        then acc
        else
          if not condition(acc, seq.head)
          then acc
          else rec(seq.tail, next_value_function(acc, seq.head))

    in rec(sequence, initial_value)

  range(length: Int): Seq[Int] =
    let
      @tailrec
      rec(n: Int, seq: Seq[Int]): Seq[Int] =
        if n <= 0
        then seq
        else rec(n - 1, seq.+:(n - 1))

    in rec(length, Seq[Int]())
}

class Recursion_() extends Recursion

class MainClass = {

  main(arguments: Array[String]): Unit =
    println ("Hello world!")
}

class Main() extends MainClass

@main

