package soda.translator.documentation

/*
 * This is a Soda tutorial written in Soda.
 * Copyright 2021 Julian Mendez
 * Version: 2021-08-12
 */

/* To declare a class, just add `class` before a class name.
 * It is recommended to use camel case style starting with a capital letter.
 * The name could be a noun or an adjective, but it should not be a verb. */
class Shape

/* There is an abbreviation for class declaration.
 * For this, just start a line with an asterisk (`*`). */
* Movable

/* A class can be parameterized.
 * The parameter type can be constrained using `subtype` and `supertype`.
 * For example, `A subtype B` means that `A` is a subtype of `B`. */
class ShapePainter[A subtype Shape]

/* It is possible to constrain a class parameter with more than one type.
 * Connect them using `with`. */
class ShapeMover[A subtype Shape with Movable]

/* The body of a class is declared between braces (`{` and `
}`) after the equals sign (`=`).
 * It is recommended to indent the constants and functions declared inside. */
class EqualsExample = {

  /* A constant does not have parameters, and it is declared with the equals sign (`=`).
   * It is recommended to use snake case and start in lowercase.
   * The constant name should be a noun.
   * In a function call the parameters can be specified with the colon-equals sign (`:=`).
   * This is especially recommended when the parameters are of the same type.
   * Constants are only evaluated once, which is the first time they are needed. */
  answer: Int = f (x := 20, y := 2)

  /* A function has parameters.
   * If the parameters are empty, it is implied that the function produces some side effect.
   * Functions, even with empty parameters, are evaluated every time they are invoked. */
  f (x: Int, y: Int): Int = 2 * x + y

}

/* A class can extend another one by using `extends`.
 * Abstract classes cannot be instantiated but can be extended.
 * Conversely, concrete classes cannot be extended but can be instantiated.
 * Concrete classes are declared with parentheses `(` and `)`.
 * It is recommended that concrete classes do not have a body, because this cannot be reused.
 * Concrete classes extending only one class could be named as its superclass, but ending with an underscore (`_`). */
class EqualsExample_() extends EqualsExample

/* A class does not need to define all its constants and functions. */
class RegisteredPerson = {

  /* A line starting with `has` denotes a constant or function that needs to be defined in extending classes. */
  has first_name: String

  has last_name: String

  /* If a constant or function is not meant to be exported, its name should start with an underscore (`_`). */
  _separator = " "

  /* Strings can be concatenated by using the plus sign (`+`). */
  full_name = first_name + _separator + last_name

}

/* A concrete class can be declared with parameters.
 * It is not recommended to use this pattern when using this class as receiving parameters in functions. */
class Person(name: String)

class Agent = {

  has identifier: String

}

/* A concrete class needs as parameters all the constants and functions that have not be defined in its super class.
 * Please note that an abstract class might have constants and functions that are not defined in its ancestor classes. */
class Agent_(identifier: String) extends Agent

class RankedIndividual = {

  has rank: Int

}

class RankedAgentPerson(identifier: String, rank: Int)
  extends Agent with RankedIndividual

class Element = {

  has accept(v: Visitor): Boolean

}

class Visitor = {

  has visit(x: Element): Boolean

}

class Item (identifier: Int) extends Element = {

  /* It is possible to refer to an object instance by using `this`. */
  accept (v: Visitor) = v.visit (this)

}

class PersonName = {

  has name: String

  /* It is possible to override a function by using annotation `@override`.
   * This is intended only for exceptional cases, like the `toString` function. */
  @override
  toString = name

}

/**
  * This contains the examples shown in the manual.
  */
class Manual = {
  import java.util.Date

  a = 1

  b: Int = 2

  /* An instance of a JVM class can be created with annotation `@new`.
   * If the code is translated to Scala 3, this annotation is not required. */
  now = @new Date()

  plus_one (x: Int): Int = x + 1

  /* A function can be defined using a `if`-`then`-`else` structure.
   * The condition in the `if` is evaluated, and then only the corresponding branch is evaluated. */
  max (x: Int, y: Int): Int =
    if x > y
    then x
    else y

  /* Scala sequences (`Seq`) can be used, as well as other basic Scala classes.
   * Lambda functions are declared using a right arrow (`->`). */
  plus_one (sequence: Seq[Int]): Seq[Int] =
    sequence.map(element -> element + 1)

  /* Boolean values `false` and `true` are available. */
  my_not (x: Boolean): Boolean =
    if x
    then false
    else true

  my_and (x: Boolean, y: Boolean): Boolean =
    if x
    then
      if y
      then true
      else false
    else false

  my_or (x: Boolean, y: Boolean): Boolean =
    if x
    then true
    else
      if y
      then true
      else false

  /* Boolean values have the standard `not`-`and`-`or` functions. */
  my_xor (x: Boolean, y: Boolean) =
    (x or y) and not (x and y)

  /* To evaluate a constant or a function, it is possible to declare intermediate functions.
   * This is done in a block `let`-`in`.
   * The block starts with a `let` containing the intermediate functions in no particular order.
   * This block is evaluated in an expression after the `in`. */
  sum (n: Int) =
    _rec (n, 0)

  /* A tail recursive function cannot be declared insider another function, and its name could start with underscore '_'.
   * Annotation `@tailrec` helps ensuring that the tail recursion is detected and optimized. */
  @tailrec
  _rec (n: Int, accum: Int): Int =
    if n < 0
    then accum
    else _rec (n - 1, n + accum)

  f0 (x: Int): Int =
    let
      a = g(x)
      b = g(a)
    in a + b

  /* Since the order in a `let`-`in` block is not important, a constant `result` at the beginning could easily indicate
   * what is the main result to be evaluated. */
  f1 (x: Int): Int =
    let
      result = a + b
      a = g(x)
      b = g(a)
    in result

  g (x: Int): Int = x + 1

}

* AbstractFactorialConcise = {

  has factorial (n: Int): Int

}

* FactorialConcise
  extends AbstractFactorialConcise = {

  @tailrec
  _rec (n: Int, product: Int): Int =
    /* The function to compare equality is a long equals (`==`). */
    if n == 0
    then product
    else _rec (n - 1, n * product)

  factorial (n: Int) =
    let
      result = _rec (n, 1)
    in result

}

/* The word `is` is a synonym for the equals sign (`=`) and they are interchangeable. */
class AbstractFactorialVerbose is {

  has factorial (n: Int): Int

}

class FactorialVerbose
  extends AbstractFactorialVerbose is {

  @tailrec
  _rec (n: Int, product: Int): Int is
    if n == 0
    then product
    else _rec (n - 1, n * product)

  factorial (n: Int) is
    let
      result is _rec (n, 1)
    in result

}

class Recursion = {

  @tailrec
  _rec_fold4[A, B, C subtype B](
             sequence: Seq[A],
             current_value: C,
             next_value_function: (B, A) -> C,
             condition: (B, A) -> Boolean
         ): C =
    if sequence.isEmpty
    then current_value
    else
      if not condition(current_value, sequence.head)
      then current_value
      else _rec_fold4(sequence.tail, next_value_function(current_value, sequence.head), next_value_function, condition)

  fold[A, B, C subtype B](
      sequence: Seq[A],
      initial_value: C,
      next_value_function: (B, A) -> C,
      condition: (B, A) -> Boolean
  ): C =
    _rec_fold4(sequence, initial_value, next_value_function, condition)

  @tailrec
  _rec_range(n: Int, sequence: Seq[Int]): Seq[Int] =
    if n <= 0
    then sequence
    else _rec_range(n - 1, sequence.+:(n - 1))

  range(length: Int): Seq[Int] =
    _rec_range(length, Seq[Int]())

}

class Recursion_() extends Recursion


/* The main class is concrete and it is called `Main()`. */
class Main() extends MainClass

/* The main class requires a `main` function that receives an `Array[String]` and returns a `Unit`. */
class MainClass = {

  main(arguments: Array[String]): Unit =
    /* An output to the standard output can be send with a `println` command.
     * This is a shorter form of JVM's `System.out.println`. */
    println("Hello world!")

}

/* The main class needs to be indicated with annotation `@main`.
 * Only one main class per package is allowed. */
@main

