package soda.lib

+ scala.util.Try
+ scala.util.Success
+ scala.util.Failure
+ org.scalatest.funsuite.AnyFunSuite

* OptionSDSpec() extends AnyFunSuite = {

  test("should test an empty option") {
    empty = NoneSD()
    assert(empty.isEmpty)
    assert(not empty.isDefined)
    assert(not empty.nonEmpty)
  }

  test("should test a non empty option") {
    element = SomeSD(1)
    assert(not element.isEmpty)
    assert(element.isDefined)
    assert(element.nonEmpty)
  }

  test("should get a default value, when empty") {
    empty = NoneSD[Int]()
    expected = 1
    obtained = empty.getOrElse(1)
    assert(obtained == expected)
  }

  test("should get a value") {
    empty = SomeSD[Int](2)
    expected = 2
    obtained = empty.getOrElse(1)
    assert(obtained == expected)
  }

  test("should open an empty option") {
    result_if_empty: String = "It is empty."
    result_if_non_empty(value: String): String = "Its value is " + value + "."

    empty = NoneSD[String]()

    expected = "It is empty."
    obtained = empty.open(
      ifEmpty := result_if_empty,
      ifNonEmpty := result_if_non_empty)

    assert(obtained == expected)
  }

  test("should open an non empty option") {
    result_if_empty: String = "It is empty."
    result_if_non_empty(value: String): String = "Its value is " + value + "."

    some_element = SomeSD[String]("0")

    expected = "Its value is 0."
    obtained = some_element.open(
      ifEmpty := result_if_empty,
      ifNonEmpty := result_if_non_empty)

    assert(obtained == expected)
  }

  test("should try fold an empty option") {
    result_if_empty: String = "It is empty."
    result_if_non_empty(value: String): String = "Its value is " + value + "."

    empty = NoneSD[String]()

    expected = "It is empty."
    obtained = empty.fold(
      ifEmpty := result_if_empty,
      f := result_if_non_empty)

    assert(obtained == expected)
  }

  test("should try fold an non empty option") {
    result_if_empty: String = "It is empty."
    result_if_non_empty(value: String): String = "Its value is " + value + "."

    some_element = SomeSD[String]("0")

    expected = "Its value is 0."
    obtained = some_element.fold(
      ifEmpty := result_if_empty,
      f := result_if_non_empty)

    assert(obtained == expected)
  }

  test("should map empty to empty") {
    to_string(n: Int): String = "" + n

    empty = NoneSD[Int]()

    expected = NoneSD[String]()
    obtained = empty.map(to_string)

    assert(obtained == expected)
  }

  test("should map a non-empty to another non-empty") {
    to_string(n: Int): String = "" + n

    some_element = SomeSD[Int](2)

    expected = SomeSD[String]("2")
    obtained = some_element.map(to_string)

    assert(obtained == expected)
  }

  test("should flat map empty to empty") {
    to_string(n: Int): SomeSD[String] = SomeSD[String]("" + n)

    empty = NoneSD[Int]()

    expected = NoneSD[String]()
    obtained = empty.flatMap(to_string)

    assert(obtained == expected)
  }

  test("should flat map a non-empty to another non-empty") {
    to_string(n: Int): SomeSD[String] = SomeSD[String]("" + n)

    some_element = SomeSD[Int](2)

    expected = SomeSD[String]("2")
    obtained = some_element.flatMap(to_string)

    assert(obtained == expected)
  }


  test("should try how successive applications of open works") {

    toInt(s: String): OptionSD[Int] =
      OptionSDBuilder().build(
        Try( Integer.parseInt(s.trim) )
          .toOption
      )

    stringA = "1"
    stringB = "2"
    stringC = "3"

    maybeA = toInt(stringA)
    maybeB = toInt(stringB)
    maybeC = toInt(stringC)

    expected = SomeSD(6)
    obtained =
      maybeA.open(ifEmpty := NoneSD,
        ifNonEmpty := a ->
          maybeB.open(ifEmpty := NoneSD,
            ifNonEmpty := b ->
              maybeC.open(ifEmpty := NoneSD,
                ifNonEmpty := c ->
                  SomeSD(a + b + c) ) ) )

    assert(obtained == expected)
  }

  test("toOption with non empty option") {
    input: OptionSD[Int] = SomeSD(1)
    expected: Option[Int] = Some(1)
    obtained = input.toOption
    assert(obtained == expected)
  }

  test("toOption with another non empty option") {
    input: SomeSD[Int] = SomeSD(2)
    expected: Some[Int] = Some(2)
    obtained = input.toOption
    assert(obtained == expected)
  }

  test("toOption with empty option") {
    input: OptionSD[Int] = NoneSD()
    expected = None
    obtained = input.toOption
    assert(obtained == expected)
  }

  test("toSeq with non empty option") {
    input: OptionSD[Int] = SomeSD(1)
    expected: Seq[Int] = Seq(1)
    obtained = input.toSeq
    assert(obtained == expected)
  }

  test("toSeq with another non empty option") {
    input: SomeSD[Int] = SomeSD(2)
    expected: Seq[Int] = Seq(2)
    obtained = input.toSeq
    assert(obtained == expected)
  }

  test("toSeq with empty option") {
    input: OptionSD[Int] = NoneSD()
    expected = Seq()
    obtained = input.toSeq
    assert(obtained == expected)
  }

  test("build Some using conditions") {
    input = "an example"
    expected = SomeSD(5)
    obtained = OptionSDBuilder().build(input.indexOf("ample"), (x: Int) -> not (x == -1))
    assert(obtained == expected)
  }

  test("build None using conditions") {
    input = "an example"
    expected = NoneSD()
    obtained = OptionSDBuilder().build(input.indexOf("sample"), (x: Int) -> not (x == -1))
    assert(obtained == expected)
  }

  test("filter should work for None") {
    input = NoneSD[Int]
    expected = NoneSD[Int]()
    obtained = input.filter(x -> true)
    assert(obtained == expected)
  }

  test("filter should work for Some, if predicate does not hold") {
    input = SomeSD[Int](0)
    expected = NoneSD[Int]()
    obtained = input.filter(x -> x > 0)
    assert(obtained == expected)
  }

  test("filter should work for Some, if predicate holds") {
    input = SomeSD[Int](1)
    expected = SomeSD[Int](1)
    obtained = input.filter(x -> x > 0)
    assert(obtained == expected)
  }

}

