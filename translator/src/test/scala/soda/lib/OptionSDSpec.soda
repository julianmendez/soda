package soda.lib


* OptionSDSpec() extends org.scalatest.funsuite.AnyFunSuite = {
  + scala.util.Try
  + scala.util.Success
  + scala.util.Failure

  test("should test an empty option") {
    empty = NoInst()

    assert(empty.isEmpty and
      not empty.isDefined and
      not empty.nonEmpty)
  }

  test("should test a non empty option") {
    element = SomeInst(1)

    assert(not element.isEmpty and
      element.isDefined and
      element.nonEmpty)
  }

  test("should get a default value, when empty") {
    empty = NoInst[Int]()
    expected = 1
    obtained = empty.getOrElse(1)

    assert(obtained == expected)
  }

  test("should get a value") {
    empty = SomeInst[Int](2)
    expected = 2
    obtained = empty.getOrElse(1)

    assert(obtained == expected)
  }

  test("should open an empty option") {
    result_if_empty: String = "It is empty."
    result_if_non_empty(value: String): String = "Its value is " + value + "."
    empty = NoInst[String]()
    expected = "It is empty."
    obtained = empty.opt(
      ifEmpty := result_if_empty,
      ifNonEmpty := result_if_non_empty)

    assert(obtained == expected)
  }

  test("should open an non empty option") {
    result_if_empty: String = "It is empty."
    result_if_non_empty(value: String): String = "Its value is " + value + "."
    some_element = SomeInst[String]("0")
    expected = "Its value is 0."
    obtained = some_element.opt(
      ifEmpty := result_if_empty,
      ifNonEmpty := result_if_non_empty)

    assert(obtained == expected)
  }

  test("should try fold an empty option") {
    result_if_empty: String = "It is empty."
    result_if_non_empty(value: String): String = "Its value is " + value + "."
    empty = NoInst[String]()
    expected = "It is empty."
    obtained = empty.fold(
      ifEmpty := result_if_empty,
      f := result_if_non_empty)

    assert(obtained == expected)
  }

  test("should try fold an non empty option") {
    result_if_empty: String = "It is empty."
    result_if_non_empty(value: String): String = "Its value is " + value + "."
    some_element = SomeInst[String]("0")
    expected = "Its value is 0."
    obtained = some_element.fold(
      ifEmpty := result_if_empty,
      f := result_if_non_empty)

    assert(obtained == expected)
  }

  test("should map empty to empty") {
    to_string(n: Int): String = "" + n
    empty = NoInst[Int]()
    expected = NoInst[String]()
    obtained = empty.map(to_string)

    assert(obtained == expected)
  }

  test("should map a non-empty to another non-empty") {
    to_string(n: Int): String = "" + n
    some_element = SomeInst[Int](2)
    expected = SomeInst[String]("2")
    obtained = some_element.map(to_string)

    assert(obtained == expected)
  }

  test("should flat map empty to empty") {
    to_string(n: Int): SomeInst[String] = SomeInst[String]("" + n)
    empty = NoInst[Int]()
    expected = NoInst[String]()
    obtained = empty.flatMap(to_string)

    assert(obtained == expected)
  }

  test("should flat map a non-empty to another non-empty") {
    to_string(n: Int): SomeInst[String] = SomeInst[String]("" + n)
    some_element = SomeInst[Int](2)
    expected = SomeInst[String]("2")
    obtained = some_element.flatMap(to_string)

    assert(obtained == expected)
  }


  test("should try how successive applications of open works") {
    toInt(s: String): OptionSD[Int] =
      OptionSDBuilderImpl().build(
        Try( Integer.parseInt(s.trim) )
          .toOption
      )

    stringA = "1"
    stringB = "2"
    stringC = "3"

    maybeA = toInt(stringA)
    maybeB = toInt(stringB)
    maybeC = toInt(stringC)

    expected = SomeInst(6)
    obtained =
      maybeA.opt(ifEmpty := NoInst,
        ifNonEmpty := a ->
          maybeB.opt(ifEmpty := NoInst,
            ifNonEmpty := b ->
              maybeC.opt(ifEmpty := NoInst,
                ifNonEmpty := c ->
                  SomeInst(a + b + c) ) ) )

    assert(obtained == expected)
  }

  test("toOption with non empty option") {
    input: OptionSD[Int] = SomeInst(1)
    expected: Option[Int] = Some(1)
    obtained = input.toOption

    assert(obtained == expected)
  }

  test("toOption with another non empty option") {
    input: SomeInst[Int] = SomeInst(2)
    expected: Some[Int] = Some(2)
    obtained = input.toOption

    assert(obtained == expected)
  }

  test("toOption with empty option") {
    input: OptionSD[Int] = NoInst()
    expected = None
    obtained = input.toOption

    assert(obtained == expected)
  }

  test("toSeq with non empty option") {
    input: OptionSD[Int] = SomeInst(1)
    expected: Seq[Int] = Seq(1)
    obtained = input.toSeq

    assert(obtained == expected)
  }

  test("toSeq with another non empty option") {
    input: SomeInst[Int] = SomeInst(2)
    expected: Seq[Int] = Seq(2)
    obtained = input.toSeq

    assert(obtained == expected)
  }

  test("toSeq with empty option") {
    input: OptionSD[Int] = NoInst()
    expected = Seq()
    obtained = input.toSeq

    assert(obtained == expected)
  }

  test("filter should work for None") {
    input = NoInst[Int]()
    expected = NoInst[Int]()
    obtained = input.filter(x -> true)

    assert(obtained == expected)
  }

  test("filter should work for Some, if predicate does not hold") {
    input = SomeInst[Int](0)
    expected = NoInst[Int]()
    obtained = input.filter(x -> x > 0)

    assert(obtained == expected)
  }

  test("filter should work for Some, if predicate holds") {
    input = SomeInst[Int](1)
    expected = SomeInst[Int](1)
    obtained = input.filter(x -> x > 0)

    assert(obtained == expected)
  }
}

