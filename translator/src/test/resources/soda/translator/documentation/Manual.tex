\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}

\lstdefinelanguage{Soda}{
    morekeywords={lambda, any, def, if, then, else, match, case, class, extends, abstract, end, this, subtype, supertype, false, true, not, and, or, package, import, theorem, directive, @tailrec, @override, @new},
    sensitive=true,
    morecomment=[s]{/*}{*/},
   morestring=[b]"
}

\lstset{frame=tb,
    language=Soda,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=none,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{teal},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=3
}

\begin{document}

\begin{lstlisting}
package soda.translator.documentation


\end{lstlisting}

This is a Soda tutorial written in Soda.
Copyright 2020--2023 Julian Alfredo Mendez
 Version: 2023-07-01


\begin{lstlisting}



\end{lstlisting}

 This tutorial is itself a "Hello world!" program.The example snippet can be found at the end.


\begin{lstlisting}



\end{lstlisting}

Source code written in Soda is intended to be descriptive and very readable.It is usually written in different files, and each file has `blocks`.
These blocks are pieces of code that have some meaning.
A block should be short, maybe less than 10 lines.
However, it is more important to make things clear than concise.
These are examples of blocks:
1. a constant or function definition
2. the beginning of a class definition
3. the end of a class definition
4. a block declaration of abstract constants and functions
5. a block of imports
6. a package declaration
7. a class alias
 8. a comment


\begin{lstlisting}



\end{lstlisting}

The name could be a noun or an adjective, but it should not be a verb. To declare a class, just add `class` before a class name, and end it with `end`.It is recommended to use camel case style starting with a capital letter.


\begin{lstlisting}


class Shape

end


\end{lstlisting}

For example, the constructor name for `Shape` is `Shape_`. The reserved word `class` declares a type, a namespace, and a default constructor.The default constructor is the name of the class with an underscore as suffix.


\begin{lstlisting}


class Movable

end


\end{lstlisting}

It is recommended to indent the constants and functions declared inside. 


\begin{lstlisting}


class EqualsExample


\end{lstlisting}

The constant name should be a noun. A constant does not have parameters and it is declared with the equals sign (`=`).It is recommended to use snake case and start in lowercase.


\begin{lstlisting}


  my_number : Int = 2


\end{lstlisting}

A function has parameters and a type.Functions, even with empty parameters, are evaluated every time they are invoked. 


\begin{lstlisting}


  f (x : Int) (y : Int) : Int = 2 * x + y


\end{lstlisting}

Constants are only evaluated once, which is the first time they are needed. 


\begin{lstlisting}


  first_result : Int = f (12) (4)


\end{lstlisting}

In a function call, the parameters can be specified with the colon-equals sign (`:=`).This is especially recommended when several parameters are of the same type. 


\begin{lstlisting}


  second_result : Int = f (x := 20) (y := -10)

end


\end{lstlisting}

A class can extend another one by using `extends`.Abstract classes cannot be instantiated but can be extended.
Conversely, concrete classes cannot be extended but can be instantiated.
Concrete classes are declared with parentheses `(` and `)`.
It is recommended that concrete classes do not have a body, because this cannot be reused.
an underscore. Concrete classes extending only one class could be named as its superclass, but ending with


\begin{lstlisting}



\end{lstlisting}

A class does not need to define all its constants and functions. 


\begin{lstlisting}


class RegisteredPerson


\end{lstlisting}

lines between the declared attributes. A block starting with `abstract` denotes a constant or function that needs to be defined inextending classes. Only one `abstract` block should be defined per class, without leaving


\begin{lstlisting}


  abstract
    first_name : String
    last_name : String


\end{lstlisting}

If a constant or function is not meant to be exported, its name should start with anunderscore. 


\begin{lstlisting}


  _separator = " "


\end{lstlisting}

Strings can be concatenated by using the plus sign (`+`). 


\begin{lstlisting}


  full_name = first_name + _separator + last_name

end

class Agent

  abstract
    identifier : String

end


\end{lstlisting}

A concrete class needs as parameters all the constants and functions that have not beendefined in its super classes. 


\begin{lstlisting}


class RegisteredPersonAgent
  extends
    Agent
    RegisteredPerson

  abstract
    identifier : String
    first_name : String
    last_name : String

end

class Element

  abstract
    accept : Visitor -> Boolean

end

class Visitor

  abstract
    visit : Element -> Boolean

end

class Item
  extends Element

  abstract
    identifier : Int


\end{lstlisting}

object. The space before the dot is to improve readability. It is possible to refer to an object instance by using `this`.The dot (`.`) notation is the standard way of accessing attributes and methods of an


\begin{lstlisting}


  accept : Visitor -> Boolean =
    lambda visitor -->
      visitor .visit (this)

end

class PersonName

  abstract
    name : String


\end{lstlisting}

diamond-shaped class hierarchy. It is possible to override a function by using the `@override` annotation.This is intended only for exceptional cases, like the `toString` function, or a


\begin{lstlisting}


  @override
  toString = name

end


\end{lstlisting}

A class can be parameterized using square brackets ('[' and ']').The parameter needs to be of type Type. 


\begin{lstlisting}


class MyList [A : Type]

end


\end{lstlisting}

It is possible to have multiple type parameters. 


\begin{lstlisting}


class MyPair [A : Type] [B : Type]

  abstract
    fst : A
    snd : A

end


\end{lstlisting}

For example, `A subtype B` means that `A` is a subtype of `B`. The parameter type can be constrained using `subtype` and `supertype`.In that case, it is not necessary to declare the parameter to be of type Type.


\begin{lstlisting}


class ShapePainter [A subtype Shape]

end


\end{lstlisting}

  This contains the examples shown in the manual.


\begin{lstlisting}


class Manual


\end{lstlisting}

It is possible to import classes by listing them under an `import` reserved word. 


\begin{lstlisting}


  import
    java.util.Date

  a = 1

  b : Int = 2


\end{lstlisting}

An instance of a JVM class can be created with the `@new` annotation. If the code istranslated to Scala 3, this annotation is not required. 


\begin{lstlisting}


  now : Date = @new Date ()

  plus_one (x : Int) : Int = x + 1


\end{lstlisting}

A piecewise function can be defined using an `if`-`then`-`else` structure. The condition inthe `if` is evaluated, and then only the corresponding branch is evaluated. 


\begin{lstlisting}


  max (x : Int) (y : Int) : Int =
    if x > y
    then x
    else y


\end{lstlisting}

Scala sequences (`Seq`) can be used, as well as other basic Scala classes.Lambda functions are declared with `lambda` and a long right arrow (`-->`). 


\begin{lstlisting}


  plus_one (sequence : Seq [Int] ) : Seq [Int] =
    sequence .map (lambda element --> element + 1)


\end{lstlisting}

A synonym for `lambda` is `any`, which sometimes brings more readability. 


\begin{lstlisting}


  plus_two (sequence : Seq [Int] ) : Seq [Int] =
    sequence .map (any element --> element + 2)


\end{lstlisting}

Boolean values `false` and `true` are available. 


\begin{lstlisting}


  my_not (x : Boolean) : Boolean =
    if x
    then false
    else true

  my_and (x : Boolean) (y : Boolean) : Boolean =
    if x
    then y
    else false

  my_or (x : Boolean) (y : Boolean) : Boolean =
    if x
    then true
    else y


\end{lstlisting}

Boolean values have the standard `not`-`and`-`or` functions. 


\begin{lstlisting}


  my_xor (x : Boolean) (y : Boolean) : Boolean =
    (x or y) and not (x and y)


\end{lstlisting}

The order matters, so the remaining cases are capture by the last variable. It is possible to use pattern matching with `match` and `case`.The result of the matching case is put after a long double arrow `==>`.


\begin{lstlisting}


  if_then_else [A : Type] (condition : Boolean) (if_true : A) (if_false : A) : A =
    match condition
      case true ==> if_true
      case _otherwise ==> if_false


\end{lstlisting}

A constant or function name starting with underscore indicates that the constant orfunction is private, and therefore is not visible outside the class. 


\begin{lstlisting}


   _my_private_function (x : Float) : Float =
     x * x + x + 1


\end{lstlisting}

detected and optimized. A tail recursive function cannot be declared inside another function, and its name shouldstart with underscore. The annotation `@tailrec` helps ensuring that the tail recursion is


\begin{lstlisting}


  @tailrec
  _tailrec_sum (n : Int) (accum : Int) : Int =
    if n < 0
    then accum
    else _tailrec_sum (n - 1) (n + accum)

  sum (n : Int) =
    _tailrec_sum (n) (0)

end


\end{lstlisting}

The function used to compare equality is a long equals (`==`). 


\begin{lstlisting}


class FactorialConcise

  @tailrec
  _tailrec_get_factorial (n : Int) (product : Int) : Int =
    if n == 0
    then product
    else _tailrec_get_factorial (n - 1) (n * product)


\end{lstlisting}

Ideally, each object should do exactly one thing. That thing is what `apply` defines. 


\begin{lstlisting}


  apply (n : Int) : Int =
    _tailrec_get_factorial (n) (1)

end


\end{lstlisting}

FoldWhile captures the idea of a bounded loop. It starts in an initial state (`initial`) andprocesses (`next`) a finite sequence (`sequence`) while a condition holds (`condition`). 


\begin{lstlisting}


class FoldWhile

  @tailrec
  _tailrec_fold_while [A : Type] [B : Type] (sequence : Seq [A] ) (current : B)
      (next : B -> A -> B) (condition : B -> A -> Boolean) : B =
    if sequence .isEmpty or (not condition (current) (sequence .head) )
    then current
    else _tailrec_fold_while (sequence .tail) (next (current) (sequence .head) ) (next) (
      condition)

  apply [A : Type] [B : Type] (sequence : Seq [A] ) (initial : B) (next : B -> A -> B)
    (condition : B -> A -> Boolean)
      : B =
    _tailrec_fold_while (sequence) (initial) (next) (condition)

end


\end{lstlisting}

Range generates a sequence of length `n` of consecutive natural numbers startingfrom 0. 


\begin{lstlisting}


class Range

  @tailrec
  _tailrec_range (n : Int) (sequence : Seq [Int] ) : Seq [Int] =
    if n <= 0
    then sequence
    else _tailrec_range (n - 1) (sequence .+: (n - 1) )

  apply (length : Int) : Seq [Int] =
    _tailrec_range (length) (Seq [Int] () )

end


\end{lstlisting}

The main class has to be named `Main` and requires a `main` function that receives an`Array [String]` and returns a `Unit`. Only one main class per package is allowed. 


\begin{lstlisting}


class Main


\end{lstlisting}

An output to the standard output can be sent with a `println` command.This is a shorter form of JVM's `System.out.println`. 


\begin{lstlisting}


  main (arguments : Array [String] ) : Unit =
    println ("Hello world!")

end


\end{lstlisting}

The main class has an extending concrete class. 


\begin{lstlisting}


\end{lstlisting}

\end{document}

