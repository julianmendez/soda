package soda.example

* MemoizableFunction[A, B] = {

  abstract
    compute(x: A, memoized_values: Map[A, B]): Tuple2[B, Map[A, B]]

}

* MainFunction[A, B] = {

  abstract
    main_function: (A, Map[A, B]) -> Tuple2[B, Map[A, B]]

}

* Memoizer[A, B]
  extends MemoizableFunction[A, B] with MainFunction[A, B] = {

  compute(x: A, memoized_values: Map[A, B]): Tuple2[B, Map[A, B]] =
    let
      maybe_res = memoized_values.get(x)
      result =
        if maybe_res.isEmpty
        then compute_and_update(x, memoized_values)
        else (maybe_res.get, memoized_values)
    in result

  compute_and_update(x: A, memoized_values: Map[A, B]): Tuple2[B, Map[A, B]] =
    let
      (res, map) = main_function(x, memoized_values)
      new_pair = (x, res)
    in (res, map + new_pair)

}

* Memoizer_[A, B](main_function: (A, Map[A, B]) -> Tuple2[B, Map[A, B]])
  extends Memoizer[A, B]

* HardProblem
  extends MemoizableFunction[Int, Int] = {

  memoizer = Memoizer_[Int, Int](main_function)

  is_even(n: Int): Boolean =
    n % 2 == 0

  one_step(n: Int): Int =
    if is_even(n)
    then n / 2
    else 3 * n + 1

  main_function(n: Int, memoized_values: Map[Int, Int]): Tuple2[Int, Map[Int, Int]] =
    if n == 1
    then (0, memoized_values)
    else
      let
        (res, new_map) = compute(one_step(n), memoized_values)
      in (1 + res, new_map)

  compute(n: Int, memoized_values: Map[Int, Int]): Tuple2[Int, Map[Int, Int]] =
    memoizer.compute(n, memoized_values)

}

* HardProblem_()
  extends HardProblem

* MemoizedFibonacci
  extends MemoizableFunction[Int, Int] = {

  memoizer = Memoizer_[Int, Int](main_function)

  main_function(n: Int, memoized_values: Map[Int, Int]): Tuple2[Int, Map[Int, Int]] =
    if n == 0 then (0, memoized_values)
    else if n == 1 then (1, memoized_values)
    else
      let
        (res1, map1) = compute(n - 2, memoized_values)
        (res2, map2) = compute(n - 1, map1)
        res = res1 + res2
        new_pair = (n, res)
      in (res, map2 + new_pair)

  compute(n: Int, memoized_values: Map[Int, Int]): Tuple2[Int, Map[Int, Int]] =
    memoizer.compute(n, memoized_values)

}

* MemoizedFibonacci_()
  extends MemoizedFibonacci

