package se.umu.cs.rai.scopus.translator.example

+ scala.annotation.tailrec

* Status(
    r: BigInt,
    n: BigInt,
    q: BigInt,
    t: BigInt,
    l: BigInt,
    k: BigInt
 ) {

   @override
   toString = " r=" + r + " n=" + n + " q=" + q + " t=" + t + " l=" + l + " k=" + k

 }


* PiIterator() {

    initial_status = Status (r=0, n=3, q=1, t=1, l=3, k=1)

    @tailrec
    compute_new_status (s: Status): Status =
      if (4 * s.q + s.r - s.t) < (s.n * s.t)
      then s
      else {
        r = (2 * s.q + s.r) * s.l
        n = (s.q * (7 * s.k) + 2 + (s.r * s.l)) / (s.t * s.l)
        q = s.q * s.k
        t = s.t * s.l
        l = s.l + 2
        k = s.k + 1
        new_status = Status (r, n, q, t, l, k)
        compute_new_status (new_status)
      }

    next (s: Status): (BigInt, Status) = {
      ns = compute_new_status (s)
      ret = ns.n
      r = 10 * (ns.r - ns.n * ns.t)
      n = ((10 * (3 * ns.q + ns.r)) / ns.t) - (10 * ns.n)
      q = ns.q * 10
      t = ns.t
      l = ns.l
      k = ns.k
      new_status = Status (r, n, q, t, l, k)
      (ret, new_status)
    }

    take (n: Int): Seq[BigInt] =
      take_rec (n, Seq(), initial_status)

    @tailrec
    take_rec (n: Int, rev_seq: Seq[BigInt], s: Status): Seq[BigInt] =
      if n == 0
      then rev_seq.reverse
      else {
        (digit, new_status) = next (s)
        take_rec (n - 1, rev_seq.prepended (digit), new_status)
      }

  }
