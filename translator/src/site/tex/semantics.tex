\section{Semantics}

\newcommand{\I}[1]{\ensuremath{{#1}^{\mathcal{I}}}}


The semantics for \Soda can be defined as follows.

This definition is for a non-recursive definition of \Soda.
The recursive definition requires extra constraints to prevent undecidability.
This is discussed in the following section.

An interpretation of a \Soda formula is a pair $\mathcal{I} = \langle \Delta _{\mathcal{I}} , \Theta _{\mathcal{I}}, \I{\cdot} \rangle$, where $\Delta _{\mathcal{I}}$ is the interpretation domain, $\Theta _{\mathcal{I}}$ is a set of types, and $\I{\cdot}$ is the interpretation function.

For this definition, let us assume $\{\srccode{Boolean}, \srccode{Int}\} \in \Theta _{\mathcal{I}}$

They are defined as follows:

\begin{itemize}
    \item $\I{\srccode{Boolean}} = \{\text{false}, \text{true}\}$
    \item $\I{\srccode{Int}} = \mathbb{Z}$
    \item $\I{(f : T)} = \I{f} \in \I{T}$
    \item $\I{(\sif\ f_{B} \ \sthen\ e_{1} \ \selse\ e_{2})}$ = $\I{e_{1}}$ if $\I{f_{B}}$ is true, or $\I{e_{2}}$ if $\I{f_{B}}$ is false

    \item $\I{(\slet\ f = g \ \sdin\ e)}$ =
    \I{(e[f := g])}, provided that $f$ does not occur free in $g$.
    This reads as the interpretation of
    replacing in $e$ every free occurrence of $f$ by $g$

    \item $\I{(\slet\ f_{1} = g_{1}, \ldots , f_{n} = g_{n} \ \sdin\ e)}$ = \\
    $\I{(\slet\ f_{1} = g_{1}[f_{n} := g_{n}], \ldots , f_{n - 1} = g_{n - 1}[f_{n} := g_{n}] \ \sdin\ e[f_{n} := g_{n}])}$, provided that $f_{n}$ does not occur free in $g_{n}$.
    This reads as the interpretation of
    replacing in $e$ and in all $g_{1}, \ldots , g_{n - 1}$ every free occurrence of $f_{n}$ by $g_{n}$

    \item $\I{(\sclass\ A = \{ S \})}$ =
\end{itemize}


\begin{itemize}
    \item $f, f_{i}$ are variable names for lambda expressions
    \item $g, g_{i}$ are typed lambda expressions
    \item $S$ is a scope
\end{itemize}


In addition, we can operate on a Monad with the following definitions

$\I{bind(a, b)} = $


One problem is the infinitely recursive definition:
\begin{lstlisting}[label={lst:exampleOfRecursion}]
  f (x: Int) = g(x)
  g (x: Int) = f(x)
\end{lstlisting}

Because of that, conventionally, every recursive function should be declared as such, by being named or starting with the prefix \srccode{rec}.

For example, instead of writing this function
\begin{lstlisting}[label={lst:exampleOfFactorialBadNaming}]
  f (n: Int) =
    if n <= 0
    then 1
    else n * f(n - 1)
\end{lstlisting}

writing this other function
\begin{lstlisting}[label={lst:exampleOfFactorialGoodNaming}]
  rec_f (n: Int) =
    if n <= 0
    then 1
    else n * rec_f(n - 1)
\end{lstlisting}

The purpose is to highlight that it requires extra care to verify that its recursion finishes.

Alternatively, it is possible to use \srccode{foldLeft} over an finite iterable structure.
\begin{lstlisting}[label={lst:exampleOfFactorialFoldLeft}]
  f (n: Int) =
    let
      initial_value = 1
      next_value(acc: Int, elem: Int): Int = acc * elem
    in Range(0, n).foldLeft(initial_value)(next_value)
\end{lstlisting}

More information about it can be found in \textbf{System-F}, \textbf{Martin-L\"{o}f type theory}, and in \textbf{dependent types}.
