\section{Semantics}

\newcommand{\I}[1]{\ensuremath{{#1}^{\mathcal{I}}}}

The semantics for \Soda can be defined as follows.

An interpretation of a \Soda formula is a pair $\mathcal{I} = \langle \Delta _\mathcal{\I} , \I{\cdot} \rangle$, where $\Delta$ is the domain and $\I{\cdot}$ is the interpretation function.

They are defined as follows:

\begin{itemize}
    \item $\I{f =_{S} g}$ can be read as replacing every free occurrence of $f$ by $g$ in scope $S$

    \item $\I{\sif b \sthen e_{1} \selse e_{2}}$ = \I{e_{1}} if $b$ is true, or \I{e_{2}} if $b$ is false

    \item $\slet f_{1} = g_{1}, \ldots f_{n} = g_{n} \sdin e$ =
    \I{e[g_{1} / f_{1}, g_{n} / f_{n}]}, which reads as the interpretation of
    replacing in $e$ every free occurrence of $f_{1}$ by $g_{1}$, $f_{2}$ by $g_{2}$, and so on until replacing $f_{n}$ by $g_{n}$
\end{itemize}

where:
\begin{itemize}
    \item $f, f_{i}$ are variable names for lambda expressions
    \item $g, g_{i}$ are typed lambda expressions
    \item $S$ is a scope
\end{itemize}


In addition, we can operate on a Monad with the following definitions

$\I{bind(a, b)} = $


One problem is the infinetely recursive definition:
\begin{lstlisting}[label={lst:exampleOfRecursion}]
  f (x: Int) = g(x)
  g (x: Int) = f(x)
\end{lstlisting}

Because of that, conventionally, every recursive function should be declared as such, by being named or starting with the prefix \srccode{rec}.

For example, instead of writing this function
\begin{lstlisting}[label={lst:exampleOfFactorialBadNaming}]
  f (n: Int) =
    if n <= 0
    then 1
    else n * f(n - 1)
\end{lstlisting}

writing this other function
\begin{lstlisting}[label={lst:exampleOfFactorialGoodNaming}]
  rec_f (n: Int) =
    if n <= 0
    then 1
    else n * rec_f(n - 1)
\end{lstlisting}

The purpose is to highlight that it requires extra care to verify that its recursion finishes.

Alternatively, it is possible to use \srccode{foldLeft} over an finite iterable structure.
\begin{lstlisting}[label={lst:exampleOfFactorialFoldLeft}]
  f (n: Int) =
    let
      initial_value = 1
      next_value(acc: Int, elem: Int): Int = acc * elem
    in Range(0, n).foldLeft(initial_value)(next_value)
\end{lstlisting}

More information about it can be found in \textbf{System-F}, \textbf{Martin-L\"{o}f type theory}, and in \textbf{dependent types}.
