\chapter{Libraries}

\begin{lstlisting}[label={lst:foldLeftWhile}]
    foldLeftWhile[A, B, C subtype (B)](s: Seq[A], initial_value: C,
        next_value: (B, A) -> C, condition: (B, A) -> Boolean): C = {

      result = rec(s, initial_value)

      @tailrec
      rec(seq: Seq[A], acc: C): C =
        if seq.isEmpty
        then acc
        else
          if not condition(acc, seq.head)
          then acc
          else rec(seq.tail, next_value(acc, seq.head))

      result
    }
\end{lstlisting}

\begin{lstlisting}[label={lst:range}]
    range(n: Int): Seq[Int] = {

      result = rec(n, Seq[Int]())

      @tailrec
      rec(n: Int, seq: Seq[Int]): Seq[Int] =
        if n <= 0
        then seq
        else rec(n - 1, seq.+:(n - 1))

      result
    }
\end{lstlisting}


\begin{lstlisting}[label={lst:option}]
  class OptionSD[A] = {
    has opt[B](ifEmpty: B, ifNonEmpty: A -> B): B

    isEmpty: Boolean =
      opt(ifEmpty := true, ifNonEmpty := element -> false)

    getOrElse(default: A): A =
      opt(ifEmpty := default, ifNonEmpty := element -> element)

    fold[B](ifEmpty: B, f: A -> B): B =
      opt(ifEmpty, f)

    map[B](mapping: A -> B): OptionSD[B] =
      opt(
        ifEmpty := NoneSD[B](),
        ifNonEmpty := element -> SomeSD[B](mapping(element))
      )

    flatMap[B](mapping: A -> OptionSD[B]): OptionSD[B] =
      opt(
        ifEmpty := NoneSD[B](),
        ifNonEmpty := element -> mapping(element)
      )
  }

  class NoneSD[A] () extends OptionSD[A] = {
    opt[B](ifEmpty: B, ifNonEmpty: A -> B): B = ifEmpty
  }

  class SomeSD[A] (element: A) extends OptionSD[A] = {
    get: A = element

    opt[B](ifEmpty: B, ifNonEmpty: A -> B): B = ifNonEmpty(element)
  }
\end{lstlisting}

