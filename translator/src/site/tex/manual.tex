\documentclass[12pt,a4paper]{book}

\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{xspace}


\lstdefinelanguage{Scopus}{
morekeywords={if, then, else, class, has, extends, with, this, false, true, not, and, or, package, import, new, is, in, to, suchthat, equals, @override, @tailrec, @main},
sensitive=true, % keywords are not case-sensitive
morecomment=[l]{//}, % l is for line comment
morecomment=[s]{/*}{*/}, % s is for start and end delimiter
morestring=[b]" % defines that strings are enclosed in double quotes
} %


\newcommand{\srccode}[1]{\texttt{{#1}}}
\newcommand{\reservedWord}[1]{{\color{blue}\srccode{#1}}\xspace}
\newcommand{\annotation}[1]{{\color{brown}\srccode{#1}}\xspace}

\newcommand{\sdef}{\srccode{=}}
\newcommand{\scolon}{\srccode{:}}

\newcommand{\sif}{\reservedWord{if}}
\newcommand{\sthen}{\reservedWord{then}}
\newcommand{\selse}{\reservedWord{else}}

\newcommand{\sclass}{\reservedWord{class}}
\newcommand{\shas}{\reservedWord{has}}
\newcommand{\sextends}{\reservedWord{extends}}
\newcommand{\swith}{\reservedWord{with}}
\newcommand{\sthis}{\reservedWord{this}}

\newcommand{\sfalse}{\reservedWord{false}}
\newcommand{\strue}{\reservedWord{true}}
\newcommand{\snot}{\reservedWord{not}}
\newcommand{\sand}{\reservedWord{and}}
\newcommand{\sor}{\reservedWord{or}}

\newcommand{\spackage}{\reservedWord{package}}
\newcommand{\simport}{\reservedWord{import}}
\newcommand{\snew}{\reservedWord{new}}

\newcommand{\stailrec}{\annotation{@tailrec}}
\newcommand{\soverride}{\annotation{@override}}
\newcommand{\smain}{\annotation{@main}}

\newcommand{\sequalsSign}{\srccode{==}}

\newcommand{\sasterisk}{\srccode{*}}
\newcommand{\splus}{\srccode{+}}
\newcommand{\sminus}{\srccode{-}}

\newcommand{\sis}{\reservedWord{is}}
\newcommand{\scin}{\reservedWord{in}}
\newcommand{\sto}{\reservedWord{to}}
\newcommand{\ssuchthat}{\reservedWord{suchthat}}
\newcommand{\sequals}{\reservedWord{equals}}

\newcommand{\Scopus}{\textsc{Scopus}\xspace}
\newcommand{\lambdaSymbol}{{\tiny--\textgreater}\xspace}


\begin{document}

    \lstset{frame=tb,
    language=Scopus,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=none,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{teal},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=3
    }

    \begin{center}

        \phantom{H}

        \vspace{80mm}

        {\huge{Scopus}}

        \vspace{80mm}
        Julian Alfredo Mendez

        \vspace{10mm}
        v0.2.1

    \end{center}

    \newpage


    \chapter{Introduction}

    \Scopus is a human-centered formalism to describe, formalize, and prototype ethical problems and constraints.
    It could be seen as a specification language or as a functional programming language.
    A specification or piece of source code written in \Scopus needs to be especially easy to read, but it does not need to be easy to write.

    A prototype written in \Scopus does not need to be efficient, as long that it can be executed in a \textit{reasonable time}.
    A reasonable time is not a mathematical definition, but a human perception for a specific task.

    The current implementation of \Scopus can be translated into Scala, and it relies on its data types.
    Prototypes written in \Scopus can be run in the Java Virtual Machine (JVM).
    Therefore, it can be used as a JVM library and use libraries written in Java, Scala, or any other JVM language.

    \section{The Intended User of Scopus}

    The purpose of \Scopus is to give at least one way that is clear enough to describe things, paying less regard to efficiency.

    Let us try to think what problems Scopus tries to solve.
    If we think on the first programming languages, like Fortran, Cobol, and Lisp, they had challenges to parse the source code.
    Newer programming languages, like Python or Scala, have clearly more powerful computers to do the processing.

    Lisp source code can look very flexible, but it could be challenging to keep track of the parentheses.

    Fortran has been used by physicist thanks to its important number of libraries for physics.
    Earlier versions of Fortran could not process recursion as we usually do it now, since it did not use a stack for the variables.
    Programming backtracking was extremely intricate.

    \Scopus allows to write functions as tail recursive, as in other modern functional languages, and the compiler transforms the tail recursion to an iteration.

    Someone who needs to understand the code does not necessarily need to know how to write a tail recursion.
    Writing a tail recursion requires some knowledge of algorithms, but reading a tail recursion is very intuitive, in a mathematical way.
    Because of this type of asymmetries, we say that \Scopus is a language that is easy to read but not necessarily easy to write.

    \section{A Descriptive Language}

    In traditional programming languages, if we need to represent a big data structure, every byte counts.
    If we need to store numbers between 0 and 250, a byte (8 bits) would suffice.
    However, if we need to store numbers between 0 and 260, we would need one more bit (9 bits), which is practice it would mean to use two bytes (16 bits).

    In most cases, we do not care if an integer is 32-bit or 64-bit, and to understand an algorithm, we do not even care if an integer has a fixed length.
    The number of bytes a system uses is a technical issue, and it could complicate the understanding of an algorithm.

    This level of detail is usually irrelevant to describe a problem, unless the problem is about this technicality.
    In other words, it is more natural that a human reads about a number, regardless of how many bits that number needs to be represented.

    In an algorithm, we explain a sequence of steps to accomplish a particular goal.
    If we want to order an array, we can either swap elements in an array, like in bubble sort, or we can choose a pivot, like in quicksort, or use other strategies.

    Is it really important to describe a problem to know how an array is sorted?
    Usually we do not care how an array is being sorted, as long as it takes a \textit{reasonable} time.

    Let us consider another example.
    If we are manipulating strings, and we want to find a particular pattern.
    Finding a pattern is a very common problem.
    As long as there is one way of finding a pattern, we do not really care how it is done.

    \Scopus could be seen mostly as a specification language, where we can specify without saying how.
    But it could be seen as a programming language as well.

    The important point is that it can provide at least one implementation that is good enough, with an acceptable complexity, to test if something is compliant or not.

    \section{Purpose of \Scopus}

    The purpose of \Scopus is to give a ``yes'' or ``no'' answer to verify if something is compliant to ethical constraints.
    Ideally, it should also provide an explanation for its answer.

    As said before, \Scopus is a formalism with some libraries.
    It is not only a restricted variant of a functional language.
    It is also all the collections of requirements that are useful for defining ethical problems.

    In an iterative process, new ethical problems are formalized in \Scopus, and when patterns are found in many problems, they join its libraries.
    Thus, \Scopus contains a collection of small classes and functions to accomplish particular tasks.

    In some cases, it could look like a controlled natural language, but it is not its purpose to look like one.
    For example, there are formulas that can be said as a sentence or written as a formula.
    Reading ``the square root of two'' is harder than reading $\sqrt{2}$.
    \Scopus code has to be easy to read, not necessarily easy to say, or to write.

    \section{General features}

    The goal of \Scopus is to specify without being too specific, giving some freedom for different implementations.
    \Scopus tries to keep a good balance between vagueness and concreteness, a good balance between specificity and generality,
    a good balance between what is very descriptive, but also technically useful.

    This happens in a way that is general enough to abstract implementations, but specific enough to constraint a problem.
    We do not need to define how things are done, as long as they are done correctly and in a reasonable time.

    \section{Technical Considerations}

    \Scopus needs to be abstract enough to describe, efficient enough, easy to read, easy to execute, and easy to integrate.
    Because of that, \Scopus is a JVM language and can be compiled into Java byte code.

    For now, the translator converts \Scopus code into Scala code, which in turn can be compiled to byte code.
    For the sake of compatibility with the JVM, \Scopus has an \soverride annotation and a \snew command.
    The \soverride annotations is to be able to override JVM definitions, like method \srccode{toString()} in class \srccode{Object}.
    The \snew command is to be able to create JVM objects.

    \Scopus uses the main types provided by Scala.
    For example, numeric types like \srccode{Int}, \srccode{Float}, and immutable collections like \srccode{Seq}, \srccode{List}, \srccode{Array}, and \srccode{Map}.
    The JVM exception handling is done via \srccode{Try}.

    \section{Style}

    \Scopus does not require a semicolon to finish each instruction, and the tabulation at the beginning of the line is irrelevant.
    Blocks are defined with braces, but they can be omitted for one instruction.

    Comments are marked with the \srccode{/*} and  \srccode{*/}.
    The Scaladoc can be used by starting the comment with \srccode{/**}, as in Scala.
    In each line, comments and source code are mutually exclusive, a line that has a comment does not have source code, a line that has source code does not have a comment.

    In general, comments are slightly discouraged, because the code should be descriptive enough.
    If the code is not descriptive enough, it should be refactored instead of commented.
    Comments can very easily get outdated if the source is changed and the comment is not updated.

    Types are defined after the variables and they are statically defined.

    The recommended naming convention is using snake case, i.e. separating the words with underscore.
    Class names should start with a capital letter, functions with a lowercase letter.

    Since there are no private functions or constants in a class, the suggestion is to start their name with an underscore.

    This is only a recommendation, since the JVM objects use camel case, i.e. all the words come together, starting with a capital letter.
    Since \Scopus can be integrated with other JVM languages, some \Scopus code could use camel case.

    Example using snake case, recommended in \Scopus

    \begin{lstlisting}[label={lst:exampleExtends}]
  /** Class for a registered person, in snake case */
  class Registered_person (first_name: String, last_name: String) {
    _separator = " "

    full_name = first_name + _separator + last_name
  }
    \end{lstlisting}

    Example using camel case, as in Java:
    \begin{lstlisting}[label={lst:exampleExtends}]
  /** Class for a registered person, in camel case */
  class RegisteredPerson (firstName: String, lastName: String) {
    _separator = " "

    fullName = firstName + _separator + lastName
  }
    \end{lstlisting}

    \section{Mutability}

    Mutability is one of the reason that algorithms get more difficult to understand.
    Although it is a practical way to save memory usage, it could be error prone.
    For this reason, \Scopus does not have ways to program mutability.

    For technical reasons, it is possible to use mutable objects from the JVM in \Scopus.
    This is strongly discouraged, since other design decisions are based assuming that objects are immutable.

    \Scopus does not handle exceptions (except when they come from the JVM).
    The exceptions are caught by Scala classes (like \srccode{Try}), as Scala does.

    Functions with side effects, like input and output operations, are discouraged in \Scopus.
    In exceptional cases, they could be managed by JVM libraries.

    \section{Values and Functions}

    In \Scopus there is no difference between functions and values.
    Since immutability is assumed, if a function has no parameters, it is computed as a constant, i.e. it is computed only once and remains unchanged.

    \section{Types and Classes}

    \Scopus is statically typed.
    It has some of the ideas of object orientation.
    However, there are substantial differences with traditional object oriented programming.

    \section{Object Inheritance and Overriding}

    \Scopus has two types of classes: abstract classes, and concrete classes.

    Abstract classes are like traits in Scala and interfaces in Java, and either do not have any implementation, or what is implemented cannot be overridden.
    Concrete classes are like case classes in Scala, since they cannot be extended, and have a default constructor.
    Abstract classes are the only classes that can be extended, since no concrete class can be extended.

    All implemented functions are final (cannot be extended), and the same for all defined constants.
    This is to prevent that the behavior is changed after extending a class.
    For technical reasons, the annotation \soverride can be used to override JVM methods that are implemented already, like \srccode{Any.toString}.

    In \Scopus, there is a \sthis reserved word where an object can refer to its own instance, but there is no \srccode{super} reserved word.
    The reason is that there is no difference between a function or constant defined in a class or in a super class, if defined.

    \section{Private Objects}

    In \Scopus, there are no private objects.
    Everything is visible from other objects.
    Functions and constants that are meant to be internal of class can follow a naming convention of starting with an underscore.

    \section{Static Constants and Functions}

    In \Scopus, there is no concept of static functions.
    It is never assume that there is one instance of an object.
    The class constructors can be implemented as objects of another class, although not necessary unique.

    \section{Parametric Types}

    The use of parametric types are technically possible and allowed, but slightly discouraged.
    Sometimes smaller code is not necessarily easier to understand.
    Usually, parametric types are needed for highly generic data types, like collections.
    Nevertheless, using parametric types could hide a design flaw, when the code looks ``very general'' but in practice is only applicable to a particular type.


    \chapter{Reserved words}

    The reserved words in \Scopus can be classified in the following categories:

    \begin{itemize}
        \item Functional
        \item Object Oriented
        \item Boolean
        \item Library
        \item Annotations
    \end{itemize}


    The reserved words considered in Scala are listed at this link:
    \url{https://www.scala-lang.org/files/archive/spec/2.13/01-lexical-syntax.html}

    \section{Functional}

    \subsubsection{= (definition symbol)}

    The definition symbol, written as an equals symbol, is used to defined functions and constants.

    For example,
    \begin{lstlisting}[label={lst:exampleDef}]
  a = 1
    \end{lstlisting}

    \subsubsection{: (type symbol)}

    The type symbol, written as a colon symbol, is used to assign a statically defined type to a function or constant.

    For example,
    \begin{lstlisting}[label={lst:exampleType01}]
  b: Int = 2
    \end{lstlisting}

    Another example is the following:
    \begin{lstlisting}[label={lst:exampleType02}]
  plus_one (x: Int): Int = x + 1
    \end{lstlisting}

    \subsubsection{\sif, \sthen, \selse}

    The \sif-\sthen-\selse construct is used to define a conditional result in a function.

    For example,
    \begin{lstlisting}[label={lst:exampleIfThenElse}]
  max (x: Int, y: Int) =
    if x > y
    then x
    else y
    \end{lstlisting}

    \subsubsection{\lambdaSymbol (lambda symbol)}

    The lambda symbol, written as a right arrow, is used to bind a variable in a lambda expression.

    For example, this piece of code
    \begin{lstlisting}[label={lst:exampleLambda}]
  plus_one (sequence: Seq[Int]) =
    sequence.map(element -> element + 1)
    \end{lstlisting}
    returns a sequence of integers where each element is computed as the next integer from the input

    \section{Object Oriented}

    \subsubsection{\sclass, \shas}

    As mentioned, there are two types of classes: the abstract and the concrete.

    Abstract classes compare to interfaces in Java, or traits in Scala, and cannot be directly instantiated.

    Both types are declared using the \sclass reserved words.

    For example,
    \begin{lstlisting}[label={lst:exampleAbstractClass}]
  class Agent {
    has identifier: String
  }
    \end{lstlisting}
    defines an abstract agent that has some identifier.
    Agent is, however, an abstract class and cannot be instantiated.

    By contrast, concrete classes compare to final classes in Java and case classes in Scala.

    The following example shows a concrete class consisting only of a parameterized name.
    \begin{lstlisting}[label={lst:exampleConcreteClass}]
  class Person (name: String)
    \end{lstlisting}

    The difference between abstract classes and concrete classes is the parameters, possibly empty, that are required for concrete classes.

    \subsubsection{\sextends, \swith}

    It is possible to declare that a concrete class extends an abstract class using the \sextends reserved word.
    Concrete classes are final and cannot be extended.

    \begin{lstlisting}[label={lst:exampleExtends}]
  class Agent_Person (name: String) extends Agent {
    identifier = name
  }
    \end{lstlisting}

    Concrete classes can also extend multiple abstract classes.
    For example,
    \begin{lstlisting}[label={lst:exampleWith}]
  class Ranked_Individual {
    has rank: Int
  }

  class Ranked_Agent_Person (name: String, person_rank: Int) extends Agent with Ranked_Individual {
    identifier = name

    rank = person_rank
  }
    \end{lstlisting}

    \subsubsection{\sthis}

    In some cases, it could be necessary that an object can refer to itself.
    For that, the \sthis reserved word is used.

    For example,
    \begin{lstlisting}[label={lst:exampleWith}]
  class Element {
    has accept (v: Visitor): Boolean
  }

  class Visitor {
    has visit (x: Element): Boolean
  }

  class Item (identifier: Int) extends Element {
    accept (v: Visitor) = v.visit (this)
  }
    \end{lstlisting}

    \section{Boolean}

    \subsubsection{\sfalse, \strue}

    As in other programming languages, the \sfalse and \strue reserved words are used for the Boolean values.

    \begin{lstlisting}[label={lst:exampleFalseTrue}]

  my_not (x: Boolean) =
    if x
    then false
    else true

  my_and (x: Boolean, y: Boolean) =
    if x
    then
      if y
      then true
      else false
    else false

  my_or (x: Boolean, y: Boolean) =
    if x
    then true
    else
      if y
      then true
      else false
    \end{lstlisting}

    \subsubsection{\snot, \sand, \sor}

    The reserved words \snot, \sand, \sor are introduced for the sake of readability.

    \begin{lstlisting}[label={lst:exampleNotAndOr}]

  my_xor (x: Boolean, y: Boolean) = (x or y) and not (x and y)

    \end{lstlisting}

    \section{Library}

    \subsubsection{\spackage}

    The reserved word \spackage declares the package where the content should be included.
    All classes then belong to that package.

    \begin{lstlisting}[label={lst:examplePackage}]
  package org.example.scopus
    \end{lstlisting}

    \subsubsection{\simport}

    The reserved word \simport helps importing classes from other libraries and frameworks.

    \begin{lstlisting}[label={lst:examplePackage}]
  import java.util.Date

  import scala.annotation.tailrec
    \end{lstlisting}

    \subsubsection{\snew}

    Although every concrete class can be instantiated directly using the parameters, some JVM libraries and frameworks may need a \snew reserved word.
    For example,

    \begin{lstlisting}[label={lst:examplePackage}]
  import java.util.Date

  now = new Date()
    \end{lstlisting}

    \section{Annotations}

    Annotations are not part of the language itself, but they are necessary to translate it into Scala.

    \subsubsection{\stailrec}

    The \stailrec annotation is used to ensure that a recursive function uses tail recursion.
    If a tail recursive function is not properly converted to a loop, it could produce a stack overflow after few iterations.

    For technical reasons, the \stailrec annotation needs to be imported.

    For example, the following example shows a function \srccode{sum} that returns the sum of the first $n$ natural numbers, or 0 if $n \leq 0$.

    \begin{lstlisting}[label={lst:exampleTailrec}]
  import scala.annotation.tailrec

  sum (n: Int) = sum_rec (n, 0)

  @tailrec
  sum_rec (n: Int, accum: Int): Int =
    if n < 0
    then accum
    else sum_rec (n - 1, n + accum)

    \end{lstlisting}

    \subsubsection{\soverride}

    The \soverride annotation is used to ensure that a function is effectively overriding another function.
    When programming, a function name could be mispelled or could be declared in another abstract class.
    This annotation prevents this problem.

    \begin{lstlisting}[label={lst:exampleOverride}]
  class Person_Name (name: String) {
    @override
    toString = name
  }
    \end{lstlisting}

    \subsubsection{\smain}

    The \smain annotation is used to indicate that an entry point is needed.
    This is kept to have functions that can be executed from the console.

    \begin{lstlisting}[label={lst:exampleMain}]
  class Main () {
    main (args: Array[String]) =
      println ("Hello world!")
  }

  @main
    \end{lstlisting}

    This \srccode{main} method can be accessed by invoking a statically accessible \srccode{main} method in class \srccode{EntryPoint} located in the same package.


    \section{Synonyms}

    One of the interesting features of \Scopus is the use of synonyms.
    They can be used to shape the code for a particular domain.

    The synonyms found only at the beginning of a line are:

    \begin{center}
        \begin{tabular}{|ll|}
            \hline
            \textbf{synonym} & \textbf{reserved word} \\
            \hline
            \sasterisk       & \sclass                \\
            \hline
            \sminus          & \shas                  \\
            \hline
            \splus           & \simport               \\
            \hline
        \end{tabular}
    \end{center}

    The synonyms that can be at any part of a line are:

    \begin{center}
        \begin{tabular}{|ll|}
            \hline
            \textbf{synonym} & \textbf{reserved word} \\
            \hline
            \sis             & \sdef                  \\
            \hline
            \scin            & \scolon                \\
            \hline
            \sto             & \lambdaSymbol          \\
            \ssuchthat       & \lambdaSymbol          \\
            \hline
            \sequals         & \sequalsSign           \\
            \hline
        \end{tabular}
    \end{center}

    As an example we can see the factorial written first in a concise and then in a verbose manner.

    \begin{lstlisting}[label={lst:exampleFactorialConcise}]
  + scala.annotation.tailrec

  * Abstract_factorial_concise {
    - factorial (n: Int): Int
  }

  * Factorial_concise () extends Abstract_factorial_concise {

    factorial (n: Int) = factorial_rec (n, 1)

    @tailrec
    factorial_rec (n: Int, product: Int): Int =
      if n == 0
      then product
      else factorial_rec (n - 1, n * product)

  }
    \end{lstlisting}


    \begin{lstlisting}[label={lst:exampleFactorialVerbose}]
  import scala.annotation.tailrec

  class Abstract_factorial_verbose {
    has factorial (n in Int) in Int
  }

  class Factorial_verbose () extends Abstract_factorial_verbose {

    factorial (n in Int) is factorial_rec (n, 1)

    @tailrec
    factorial_rec (n in Int, product in Int) in Int is
      if n equals 0
      then product
      else factorial_rec (n - 1, n * product)

  }
    \end{lstlisting}


\end{document}

