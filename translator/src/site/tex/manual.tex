\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{xspace}


\lstdefinelanguage{Scopus}{
morekeywords={if, then, else, class, has, extends, with, this, false, true, not, and, or, package, import, new, is, in, to, that, equals, @override, @tailrec},
sensitive=true, % keywords are not case-sensitive
morecomment=[l]{//}, % l is for line comment
morecomment=[s]{/*}{*/}, % s is for start and end delimiter
morestring=[b]" % defines that strings are enclosed in double quotes
} %


\newcommand{\srccode}[1]{\texttt{{#1}}}
\newcommand{\reservedWord}[1]{{\color{blue}\srccode{#1}}\xspace}
\newcommand{\annotation}[1]{{\color{brown}\srccode{#1}}\xspace}

\newcommand{\sdef}{\srccode{=}}
\newcommand{\scolon}{\srccode{:}}

\newcommand{\sif}{\reservedWord{if}}
\newcommand{\sthen}{\reservedWord{then}}
\newcommand{\selse}{\reservedWord{else}}

\newcommand{\sclass}{\reservedWord{class}}
\newcommand{\shas}{\reservedWord{has}}
\newcommand{\sextends}{\reservedWord{extends}}
\newcommand{\swith}{\reservedWord{with}}
\newcommand{\sthis}{\reservedWord{this}}

\newcommand{\sfalse}{\reservedWord{false}}
\newcommand{\strue}{\reservedWord{true}}
\newcommand{\snot}{\reservedWord{not}}
\newcommand{\sand}{\reservedWord{and}}
\newcommand{\sor}{\reservedWord{or}}

\newcommand{\spackage}{\reservedWord{package}}
\newcommand{\simport}{\reservedWord{import}}
\newcommand{\snew}{\reservedWord{new}}

\newcommand{\stailrec}{\annotation{@tailrec}}
\newcommand{\soverride}{\annotation{@override}}

\newcommand{\sequalsSign}{\srccode{==}}

\newcommand{\sasterisk}{\srccode{*}}
\newcommand{\splus}{\srccode{+}}
\newcommand{\sminus}{\srccode{-}}

\newcommand{\sis}{\reservedWord{is}}
\newcommand{\scin}{\reservedWord{in}}
\newcommand{\sto}{\reservedWord{to}}
\newcommand{\sthat}{\reservedWord{that}}
\newcommand{\sequals}{\reservedWord{equals}}

\newcommand{\Scopus}{\textsc{Scopus}\xspace}
\newcommand{\lambdaSymbol}{{\tiny--\textgreater}}
\newcommand{\like}{{\color{green}YES}}
\newcommand{\unlike}{{\color{red}NO}}


\begin{document}

    \lstset{frame=tb,
    language=Scopus,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=none,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{green},
    stringstyle=\color{mauve},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=3
    }


    \section{\Scopus}

    \Scopus is a formalism that has good properties to describe and formalize.
    One could say it looks like a programming language.
    In fact, we can translate it to Scala, which is JVM.
    It is not \textit{only} a programming language.
    A family of formalisms that are meant to define some problems and constraints.

    It is a language that has to develop some priorities and some compromises about what we can say and what we cannot say.
    To give more clarity, but reducing complexity as much as possible.

    The success of the language can be seen by looking at examples.

    \subsection{Who is the intended user of Scopus?}

    First of all, let us try to thinking what problems Scopus tries to solve

    If we think how languages were fifty years ago, like Fortran, Cobol, C, Lisp.
    They had challenges to parse the source code.

    Newer programming languages like Python or Scala, they clearly have more powerful computers to do the processing.

    How come we still use the same programming languages?

    Until long ago physicists have been learning Fortran because of the massive number of libraries they could use for their own projects.

    These languages are thought to simplify the work of programmers.

    How many ways we can write a loop in C? How many ways we can encode something to repeat 10 times?

    There are many ways of expressing something in a programming language, but not all of them are very clear.

    Why are there so many ways of saying the same thing?

    The purpose of \Scopus is to give at least one way that is clear enough to describe things, paying less regard to efficiency.

    In \Scopus it is possible to write functions as tail recursive, and the compiler should transform the tail recursion to an iteration.

    That is way we can say that \Scopus is a language that is easy to read but not necessarily easy to write.

    Someone who needs to understand the code does not necessarily need to know how to write a tail recursion.
    To write a tail recursion requires some knowledge of algorithms, but reading a tail recursion is very intuitive, in a mathematical way.

    \subsection{Descriptive Language}

    In traditional programming languages, if we need to represent a big data structure, every byte counts.
    If we need to store numbers between 0 and 250, a byte (8 bits) would suffice.
    However, if we need to store numbers between 0 and 260, we would need one more bit (9 bits), which is practice it would mean to use two bytes (16 bits).

    In most of the cases, we do not care if an integer is 32-bit or 64-bit long.
    And to understand an algorithm, we do not even care if an integer has a fixed length.

    The number of bytes a system uses is a technical issue, and it could complicate the understanding of an algorithm.

    This level of detail is usually irrelevant to describe a problem, unless the problem is about this technicality.
    In other words, it is more natural that a human reads about a number, regardless of how many bits that number needs to be represented.

    In an algorithm, we explain a sequence of steps to accomplish a particular goal.
    If we want to order an array, we can either swap elements in an array, like in bubble sort, or we can choose a pivot, like in quicksort, or use other strategies.

    Is it really important to describe a problem to know how an array is sorted?
    Usually we do not care how an array is being sorted, as long as it takes a \textit{reasonable} time.

    Let us consider another example.
    If we are manipulating strings, and we want to find a particular pattern.
    Finding a pattern is a very common problem.
    As long as there is one way of finding a pattern, we do not really care how it is done.

    \Scopus could be seen mostly as a specification language, where we can specify without saying how.
    But it could be seen as a programming language as well.

    The important point is that it can provide at least one implementation that is good enough, with an acceptable complexity, to test if something is compliant or not.

    \subsection{Purpose of \Scopus}

    The purpose of \Scopus is to give a yes or no answer to verify if something is compliant.
    In addition, ideally it should also provide an explanation for its answer.

    The purpose of \Scopus is to specify without being too specific, giving some freedom for different implementations.

    As said before, \Scopus is a formalism with some libraries.
    It is not only a restricted variant of a functional language.
    It is also all the collections of requirements that useful for defining ethical problems.

    The best one can do is to identify ethical problems, formalize them in \Scopus, and see what is necessary.

    If there is a recurrent type of problems, one can find an easy solution.

    \Scopus then can contain a collection of small classes and functions to accomplish particular tasks.

    It could look like a controlled natural language, but not necessarily.
    It is not its purpose to look like a natural language.

    For example, there formulas that can be said as a sentence or written as a formula.
    Saying the ``the square root of two'' is harder to read than $\sqrt{2}$.

    And \Scopus has to be easy to read, not necessarily easy to say, or to write.

    \subsection{General features}

    This freedom is key for the goal of \Scopus, which gives opportunity to different implementations, but strict enough to define properties and behaviors.

    \Scopus has a good mixture of vagueness and concreteness, a good mixture of specificity and generality.

    This happens in a way that is general enough to abstract implementations, but specific enough to constraint a problem.

    As many languages, \Scopus relies on simple constructs.
    We do not need to define how things are done, as long as they are done correctly and in an acceptable time.

    The language provides not a simple way of describing problems, but also a collection of tools that can be used to describe those problems.

    What are the challenges and issues that the language can have?

    The main problem is that the language has to achieve usefulness.
    It has to be better enough to justify its creation.

    It has to solve problems and issues that other languages cannot.

    If it is not better, the is no motivation to use \Scopus.

    Is it just a style of programming?

    Is it just a style of describing things?

    Or it is something else?

    The main issue that other languages cannot solve, like some reserved words, or constructions.

    \Scopus represents a challenge, which is finding a good balance between what is very descriptive, but also is technically useful.

    The next steps for \Scopus is defining what problems can be modelled and defining who are supposed to write and read \Scopus.

    \subsection{Technical Requirements}

    \Scopus needs to be useful.
    Even if it is written in abstract and general way, it has be efficient and rather easy to execute.

    Because of that, it is JVM language, so that \Scopus can be compiled into Java byte code.

    At the moment, there is only a translator from \Scopus to Scala, which can translate simple code into Scala code.

    \Scopus does not need \soverride, but it is necessary for the compatibility with JVM.

    \Scopus would not need to have a \snew command to create objects, but it keeps it to be compatible with the JVM.

    \subsection{Style Comparison}


    \Scopus does not require a semicolon to finish each instruction, and the tabulation at the beginning of the line is irrelevant.
    Blocks are defined with braces, but they can be omitted for one instruction.

    Types are defined after the variables and they are statically defined.

    The programming languages to compare are
    \begin{itemize}
        \item Lisp (1959)
        \item Pascal (1970)
        \item Prolog (1972)
        \item C++ (1983)
        \item Python (1989)
        \item Haskell (1990)
        \item Java (1995)
        \item Scala (2003)
    \end{itemize}


    {\tiny{
    \begin{center}
        \begin{tabular}{llllllllll}
            property                         & \Scopus & Scala   & Java    & Haskell & Python  & C++     & Prolog  & Pascal  & Lisp    \\
            \hline
            no delimiter to end instructions & \like   & \like   & \unlike & \like   & \like   & \unlike & \unlike & \unlike & \like   \\
            no special format required       & \like   & \like   & \like   & \like   & \unlike & \like   & \like   & \like   & \like   \\
            blocks with delimiters           & \like   & \like   & \unlike & \unlike & \like   & \unlike & \like   & \like   & \like   \\
            types after variables            & \like   & \like   & \unlike & \like   & \like   & \unlike & \unlike & \like   & \unlike \\
            statically typed                 & \like   & \like   & \like   & \like   & \unlike & \like   & \unlike & \like   & \unlike \\
            mutable objects discouraged      & \like   & \like   & \unlike & \like   & \unlike & \unlike & \like   & \unlike & \like   \\
            everything is visible            & \like   & \unlike & \unlike & \unlike & \like   & \unlike & \like   & \unlike & \like   \\
            JVM language                     & \like   & \like   & \like   & \unlike & \unlike & \unlike & \unlike & \unlike & \unlike \\
            \hline
        \end{tabular}
    \end{center}
    }}

    \subsection{Mutability}

    Mutability is one of the reason that algorithms get more difficult to understand.
    It is practical way to save memory usage, but it could be error prone.
    We can use some concept of mutability by adding a variable for time.
    \Scopus does not have exceptions (except when they come from the JVM).
    The exceptions are caught by Scala classes (Try), as Scala does.

    For technical reasons, in \Scopus is technically possible to use mutable objects from the JVM.
    This is strongly discouraged, since other design decisions are based assuming that objects in immutable.

    In \Scopus there is no specific log, input, output commands.
    Instead this is managed by JVM libraries.

    In \Scopus the input/output is not encouraged.

    \subsection{Values and Functions}

    In \Scopus there is no difference between functions and values.
    Since immutability is assumed, if a function has no parameters, it is computed as a constant, i.e. it is computed only once and remains unchanged.

    \subsection{Types and Classes}

    \Scopus is statically typed.
    It has some of the ideas of object orientation.
    However, there are substantial differences with traditional object oriented programming.

    \Scopus has two types of classes: abstract classes, and concrete classes.

    Abstract classes are like traits in Scala and interfaces in Java.
    Concrete classes are like case classes in Scala, since they are final, but they have a default constructor.

    \subsection{Object Inheritance}

    In \Scopus there are abstract classes, which are like traits in Scala, or interfaces in Java.
    These abstract classes are the only ones that can be extended.
    No concrete class can be extended.
    In other words, all concrete classes are final.

    \subsection{Overriding}

    In \Scopus, functions cannot be overridden.
    For technical reasons, there is an annotation, \soverride, which is meant to be used to override JVM methods that are implemented, like \srccode{toString()}.
    All implemented functions are final (cannot be extended), and the same for all defined constants.
    This is to prevent that the behavior is changed after extending a class.

    \subsection{Private Objects}

    In \Scopus, there are no private objects.
    Everything is visible from other objects.
    This does not mean that there are functions that are not meant to be used outside an object.

    For that, a simple naming convention, like Python uses, can indicate when an internal function is being defined and used.

    \subsection{\sthis, but no \srccode{super}}

    In \Scopus, there is a \sthis reserved word to refer to its instance, but there is no \srccode{super} reserved word.
    The reason is that there is no difference between a function or constant defined in a class or in a super class, if defined.

    \subsection{Static Constants and Functions}

    In \Scopus, there is no concept of static functions.
    It is never assume that there is one instance of an object.
    The class constructors are then other objects of another class, but not necessary unique.

    \subsection{Parametric Types}

    The use of parametric types are technically possible and allowed, but slightly discouraged.
    Usually, parametric types are needed for highly generic data types, like collections.
    But, using parametric types could hide a design flaw, when the code look ``very general'' but in practice is should only be applicable to a particular type.
    Sometimes smaller code is not necessarily easier to understand.


    \section{Reserved words}

    The reserved words in \Scopus can be classified in the following categories:

    \begin{itemize}
        \item Functional
        \item Object Oriented
        \item Boolean
        \item Library
        \item Annotations
    \end{itemize}


    The reserved words considered in Scala are listed at this link:
    \url{https://www.scala-lang.org/files/archive/spec/2.13/01-lexical-syntax.html}

    \subsection{Functional}

    \subsubsection{= (definition symbol)}

    The definition symbol, written as an equals symbol, is used to defined functions and constants.

    For example,
    \begin{lstlisting}[label={lst:exampleDef}]
  a = 1
    \end{lstlisting}

    \subsubsection{: (type symbol)}

    The type symbol, written as a colon symbol, is used to assign a statically defined type to a function or constant.

    For example,
    \begin{lstlisting}[label={lst:exampleType01}]
  b: Int = 2
    \end{lstlisting}

    Another example is the following:
    \begin{lstlisting}[label={lst:exampleType02}]
  plus_one (x: Int): Int = x + 1
    \end{lstlisting}

    \subsubsection{\sif, \sthen, \selse}

    The \sif-\sthen-\selse construct is used to define a conditional result in a function.

    For example,
    \begin{lstlisting}[label={lst:exampleIfThenElse}]
  max (x: Int, y: Int) =
    if x > y
    then x
    else y
    \end{lstlisting}

    \subsubsection{\lambdaSymbol, $\rightarrow$ ($\backslash$u2192) (lambda symbol)}

    The lambda symbol, written as a right arrow, is used to bind a variable in a lambda expression.

    For example, this piece of code
    \begin{lstlisting}[label={lst:exampleLambda}]
  plus_one (sequence: Seq[Int]) =
    sequence.map(element -> element + 1)
    \end{lstlisting}
    returns a sequence of integers where each element is computed as the next integer from the input

    \subsection{Object Oriented}

    \subsubsection{\sclass, \shas}

    There are two types of classes: the abstract and the concrete.

    Abstract classes compare to interfaces in Java, or traits in Scala, and cannot be directly instantiated.

    Both types are declared using the \sclass reserved words.

    For example,
    \begin{lstlisting}[label={lst:exampleAbstractClass}]
  class Agent {
    has identifier: String
  }
    \end{lstlisting}
    defines an abstract agent that has some identifier.
    Agent is, however, an abstract class and cannot be instantiated.

    By contrast, concrete classes compare to final classes in Java and case classes in Scala.

    The following example shows a concrete class consisting only of a parameterized name.
    \begin{lstlisting}[label={lst:exampleConcreteClass}]
  class Person (name: String)
    \end{lstlisting}

    The difference between abstract classes and concrete classes is the parameters, possibly empty, that are required for concrete classes.

    \subsubsection{\sextends, \swith}

    It is possible to declare that a concrete class extends an abstract class using the \sextends reserved word.
    Concrete classes are final and cannot be extended.

    \begin{lstlisting}[label={lst:exampleExtends}]
  class Agent_Person (name: String) extends Agent {
    identifier = name
  }
    \end{lstlisting}

    Concrete classes can also extend multiple abstract classes.
    For example,
    \begin{lstlisting}[label={lst:exampleWith}]
  class Ranked_Individual {
    has rank: Int
  }

  class Ranked_Agent_Person (name: String, person_rank: Int) extends Agent with Ranked_Individual {
    identifier = name

    rank = person_rank
  }
    \end{lstlisting}

    \subsubsection{\sthis}

    In some cases, it could be necessary that an object can refer to itself.
    For that, the \sthis reserved word is used.

    For example,
    \begin{lstlisting}[label={lst:exampleWith}]
  class Element {
    has accept (v: Visitor): Boolean
  }

  class Visitor {
    has visit (x: Element): Boolean
  }

  class Item (identifier: Int) extends Element {
    accept (v: Visitor) = v.visit (this)
  }
    \end{lstlisting}

    \subsection{Boolean}

    \subsubsection{\sfalse, \strue}

    As in other programming languages, the \sfalse and \strue reserved words are used for the Boolean values.

    \begin{lstlisting}[label={lst:exampleFalseTrue}]

  my_not (x: Boolean) =
    if x
    then false
    else true

  my_and (x: Boolean, y: Boolean) =
    if x
    then
      if y
      then true
      else false
    else false

  my_or (x: Boolean, y: Boolean) =
    if x
    then true
    else
      if y
      then true
      else false
    \end{lstlisting}

    \subsubsection{\snot, \sand, \sor}

    The reserved words \snot, \sand, \sor are introduced for the sake of readability.

    \begin{lstlisting}[label={lst:exampleNotAndOr}]

  my_xor (x: Boolean, y: Boolean) = (x or y) and not (x and y)

    \end{lstlisting}

    \subsection{Library}

    \subsubsection{\spackage}

    The \spackage declares the package the content should be included.
    All classes then belong to that package.

    \begin{lstlisting}[label={lst:examplePackage}]
  package org.example.scopus
    \end{lstlisting}

    \subsubsection{\simport}

    The \simport helps importing classes from other libraries and frameworks.

    \begin{lstlisting}[label={lst:examplePackage}]
  import java.util.Date

  import scala.annotation.tailrec
    \end{lstlisting}

    \subsubsection{\snew}

    Although every concrete class can be instantiated directly using the parameters, some libraries and frameworks may need a \snew reserved word.
    For example,

    \begin{lstlisting}[label={lst:examplePackage}]
  import java.util.Date

  now = new Date()
    \end{lstlisting}

    \subsection{Annotations}

    Annotations are not part of the language itself, but they are necessary to translate it into Scala.

    \subsubsection{\stailrec}

    The \stailrec annotation is used to ensure that a recursive function uses tail recursion.
    If a tail recursive function is not properly converted to a loop, it could produce a stack overflow after few iterations.

    For technical reasons, the \stailrec annotation needs to be imported.

    For example, the following example shows a function \srccode{sum} that returns the sum of the first $n$ natural numbers, or 0 if $n \leq 0$.

    \begin{lstlisting}[label={lst:exampleTailrec}]
  import scala.annotation.tailrec

  sum (n: Int) = sum_rec (n, 0)

  @tailrec
  sum_rec (n: Int, accum: Int): Int =
    if n < 0
    then accum
    else sum_rec (n - 1, n + accum)

    \end{lstlisting}

    \subsubsection{\soverride}

    The \soverride annotation is used to ensure that a function is effectively overriding another function.
    When programming, a function name could be mispelled or could be declared in another abstract class.
    This annotation prevents this problem.

    \begin{lstlisting}[label={lst:exampleOverride}]
  class Person_Name (name: String) {
    @override
    toString = name
  }
    \end{lstlisting}


    \section{Synonyms}

    One of the interesting features of \Scopus is the use of synonyms.
    They can be used to shape the code for a particular domain.

    The synonyms found only at the beginning of a line are:

    \begin{center}
        \begin{tabular}{|ll|}
            \hline
            \textbf{synonym} & \textbf{reserved word} \\
            \hline
            \sasterisk       & \sclass                \\
            \hline
            \sminus          & \shas                  \\
            \hline
            \splus           & \simport               \\
            \hline
        \end{tabular}
    \end{center}

    The synonyms that can be at any part of a line are:

    \begin{center}
        \begin{tabular}{|ll|}
            \hline
            \textbf{synonym} & \textbf{reserved word} \\
            \hline
            \sis             & \sdef                  \\
            \hline
            \scin            & \scolon                \\
            $\in$            & \scolon                \\
            \hline
            \sto             & \lambdaSymbol          \\
            \sthat           & \lambdaSymbol          \\
            $\to$            & \lambdaSymbol          \\
            \hline
            \sequals         & \sequalsSign           \\
            \hline
        \end{tabular}
    \end{center}

    As an example we can see the factorial written first in a concise and then in a verbose manner.

    \begin{lstlisting}[label={lst:exampleFactorialConcise}]
  + scala.annotation.tailrec

  * AbstractFactorialConcise {
    - factorial (n: Int): Int
  }

  * FactorialConcise () extends AbstractFactorialConcise {

    factorial (n: Int) = factorial_rec (n, 1)

    @tailrec
    factorial_rec (n: Int, product: Int): Int =
      if n == 0
      then product
      else factorial_rec (n - 1, n * product)

  }
    \end{lstlisting}


    \begin{lstlisting}[label={lst:exampleFactorialVerbose}]
  import scala.annotation.tailrec

  class AbstractFactorialVerbose {
    has factorial (n in Int) in Int
  }

  class FactorialVerbose () extends AbstractFactorialVerbose {

    factorial (n in Int) is factorial_rec (n, 1)

    @tailrec
    factorial_rec (n in Int, product in Int) in Int is
      if n equals 0
      then product
      else factorial_rec (n - 1, n * product)

  }
    \end{lstlisting}


\end{document}

