\chapter{Manual}

\Soda (Symbolic Objective Descriptive Analysis) is a human-centered formalism to describe, formalize, and prototype ethical problems and constraints.
It could be seen as a specification language or as a functional programming language.

The reserved words in \Soda can be classified in the following categories:

\begin{itemize}
    \item Functional
    \item Object Oriented
    \item Boolean
    \item Library
    \item Annotations
\end{itemize}


%The reserved words considered in Scala are listed at this link:
%\url{https://www.scala-lang.org/files/archive/spec/2.13/01-lexical-syntax.html}

This is a tentative logo:

\Sodalogo


\section{Functional}

\subsubsection{= (definition symbol)}

The definition symbol, written as an equals symbol, is used to defined functions and constants.

For example,
\begin{lstlisting}[label={lst:exampleDef}]
  a = 1
\end{lstlisting}

\subsubsection{: (type symbol)}

The type symbol, written as a colon symbol, is used to assign a statically defined type to a function or constant.

For example,
\begin{lstlisting}[label={lst:exampleType01}]
  b: Int = 2
\end{lstlisting}

Another example is the following:
\begin{lstlisting}[label={lst:exampleType02}]
  plus_one (x: Int): Int = x + 1
\end{lstlisting}

\subsubsection{\sif, \sthen, \selse}

The \sif-\sthen-\selse construct is used to define a conditional result in a function.

For example,
\begin{lstlisting}[label={lst:exampleIfThenElse}]
  max (x: Int, y: Int) =
    if x > y
    then x
    else y
\end{lstlisting}

\subsubsection{\slambda (lambda symbol)}

The lambda symbol, written as a right arrow, is used to bind a variable in a lambda expression.

For example, this piece of code
\begin{lstlisting}[label={lst:exampleLambda}]
  plus_one (sequence: Seq[Int]) =
    sequence.map(element -> element + 1)
\end{lstlisting}
returns a sequence of integers where each element is computed as the next integer from the input


\section{Object Oriented}

\subsubsection{\sclass, \shas}

As mentioned, there are two types of classes: the abstract and the concrete.

Abstract classes compare to interfaces in Java, or traits in Scala, and cannot be directly instantiated.

Both types are declared using the \sclass reserved words.

For example,
\begin{lstlisting}[label={lst:exampleAbstractClass}]
  class Agent = {
    has identifier: String
  }
\end{lstlisting}
defines an abstract agent that has some identifier.
Agent is, however, an abstract class and cannot be instantiated.

By contrast, concrete classes compare to final classes in Java and case classes in Scala.

The following example shows a concrete class consisting only of a parameterized name.
\begin{lstlisting}[label={lst:exampleConcreteClass}]
  class Person (name: String)
\end{lstlisting}

The difference between abstract classes and concrete classes is the parameters, possibly empty, that are required for concrete classes.

\subsubsection{\sextends, \swith}

It is possible to declare that a concrete class extends an abstract class using the \sextends reserved word.
Concrete classes are final and cannot be extended.

\begin{lstlisting}[label={lst:exampleExtends}]
  class AgentPerson (name: String) extends Agent = {
    identifier = name
  }
\end{lstlisting}

Concrete classes can also extend multiple abstract classes.
For example,
\begin{lstlisting}[label={lst:exampleWith}]
  class RankedIndividual = {
    has rank: Int
  }

  class RankedAgentPerson (name: String, person_rank: Int) extends Agent with RankedIndividual = {
    identifier = name

    rank = person_rank
  }
\end{lstlisting}

\subsubsection{\sthis}

In some cases, it could be necessary that an object can refer to itself.
For that, the \sthis reserved word is used.

For example,
\begin{lstlisting}[label={lst:exampleExtendsElement}]
  class Element = {
    has accept (v: Visitor): Boolean
  }

  class Visitor = {
    has visit (x: Element): Boolean
  }

  class Item (identifier: Int) extends Element = {
    accept (v: Visitor) = v.visit (this)
  }
\end{lstlisting}

\subsubsection{\ssubtype, \ssupertype}

The bounds of a parametric type can be determined with \ssubtype, for the upper bound, and \ssupertype, for the lower bound.


\section{Boolean}

\subsubsection{\sfalse, \strue}

As in other programming languages, the \sfalse and \strue reserved words are used for the Boolean values.

\begin{lstlisting}[label={lst:exampleFalseTrue}]

  my_not (x: Boolean) =
    if x
    then false
    else true

  my_and (x: Boolean, y: Boolean) =
    if x
    then
      if y
      then true
      else false
    else false

  my_or (x: Boolean, y: Boolean) =
    if x
    then true
    else
      if y
      then true
      else false
\end{lstlisting}

\subsubsection{\snot, \sand, \sor}

The reserved words \snot, \sand, \sor are introduced for the sake of readability.

\begin{lstlisting}[label={lst:exampleNotAndOr}]

  my_xor (x: Boolean, y: Boolean) = (x or y) and not (x and y)

\end{lstlisting}


\section{Library}

\subsubsection{\spackage}

The reserved word \spackage declares the package where the content should be included.
All classes then belong to that package.

\begin{lstlisting}[label={lst:examplePackage}]
  package org.example.soda
\end{lstlisting}

\subsubsection{\simport}

The reserved word \simport helps importing classes from other libraries and frameworks.
It is recommended to put the \simport inside the class that is using it.
This differs from common practice in Java, where all the import statements are at the beginning of the file, outside the class.
It is important to notice that the imports can always be moved outwards, i.e. from inside the class to outside.
Including the imports in the class and not in more general place helps removing a class with its own imports.
If these imports are in general place, e.g. visible from the whole package, it becomes harder to maintain when classes are added or removed.
To have a view of the imports needed by a package, it would be necessary to use a tool, like an IDE.


\begin{lstlisting}[label={lst:exampleImport}]
  import java.util.Date
\end{lstlisting}


\section{Annotations}

Annotations are not part of the language itself, but they are necessary to translate it into Scala.

\subsubsection{\snew}

Although every concrete class can be instantiated directly using the parameters, some JVM libraries and frameworks may need a \snew reserved word.
This is only necessary when the code is translated into Scala 2.
For translations to Scala 3, the \snew annotation can be omitted.
For example,

\begin{lstlisting}[label={lst:exampleImportDate}]
  import java.util.Date

  now = @new Date()
\end{lstlisting}

\subsubsection{\soverride}

The \soverride annotation may be necessary to override some JVM functions, like \srccode{toString()}.
However, this could be misused to override functions and values of abstract classes.
This could make that a concrete class does not behave as the abstract class that implements.
For this reason, although \soverride annotation could be used to ensure that a function is effectively overriding another function, it should only be used to override JVM functions, and not \Soda functions.

\begin{lstlisting}[label={lst:exampleOverride}]
  class PersonName (name: String) = {
    @override
    toString = name
  }
\end{lstlisting}

\subsubsection{\stailrec}

The \stailrec annotation is used to ensure that a recursive function uses tail recursion.
If a tail recursive function is not properly converted to a loop, it could produce a stack overflow after few iterations.

For technical reasons, a function with tail recursion needs to be used inside another function.

\begin{lstlisting}[label={lst:exampleTailrecInside}]
  sum (n: Int) =
    let
      result = rec (n, 0)

      @tailrec
      rec (n: Int, accum: Int): Int =
        if n < 0
        then accum
        else rec (n - 1, n + accum)

    in result
\end{lstlisting}

\subsubsection{\smain}

The \smain annotation is used to indicate that an entry point is needed.
This is kept to have functions that can be executed from the console.

\begin{lstlisting}[label={lst:exampleMain}]
  class Main () = {
    main (args: Array[String]): Unit =
      println ("Hello world!")
  }

  @main
\end{lstlisting}

This \srccode{main} method can be accessed by invoking a statically accessible \srccode{main} method in class \srccode{EntryPoint} located in the same package.


\section{Synonyms}

One of the interesting features of \Soda is the use of synonyms.
They can be used to shape the code for a particular domain.

The synonyms found only at the beginning of a line are:

\begin{center}
    \begin{tabular}{|ll|}
        \hline
        \textbf{synonym} & \textbf{reserved word} \\
        \hline
        \sasterisk       & \sclass                \\
        \hline
        \splus           & \simport               \\
        \hline
    \end{tabular}
\end{center}

The synonyms that can be at any part of a line are:

\begin{center}
    \begin{tabular}{|ll|}
        \hline
        \textbf{synonym} & \textbf{reserved word} \\
        \hline
        \sis             & \sdef                  \\
        \hline
        \ssuchthat       & \slambda               \\
        \hline
    \end{tabular}
\end{center}

As an example we can see the factorial written first in a concise and then in a verbose manner.

\begin{lstlisting}[label={lst:exampleFactorialConcise}]
  * AbstractFactorialConcise = {
    has factorial (n: Int): Int
  }

  * FactorialConcise () extends AbstractFactorialConcise = {

    factorial (n: Int) = {
      result = rec (n, 1)

      @tailrec
      rec (n: Int, product: Int): Int =
        if n == 0
        then product
        else rec (n - 1, n * product)

      result
    }
  }
\end{lstlisting}


\begin{lstlisting}[label={lst:exampleFactorialVerbose}]
  class AbstractFactorialVerbose is {
    has factorial (n: Int): Int
  }

  class FactorialVerbose () extends AbstractFactorialVerbose is {

    factorial (n: Int) is
      let
        result is rec (n, 1)

        @tailrec
        rec (n: Int, product: Int): Int is
          if n == 0
          then product
          else rec (n - 1, n * product)

      in result
  }
\end{lstlisting}


