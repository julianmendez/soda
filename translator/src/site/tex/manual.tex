\documentclass[12pt,a4paper]{book}

\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{xspace}


\lstdefinelanguage{Soda}{
    morekeywords={if, then, else, class, has, extends, with, this, false, true, not, and, or, package, import, new, is, suchthat, @tailrec, @override, @main},
    sensitive=true, % keywords are not case-sensitive
    morecomment=[s]{/*}{*/}, % s is for start and end delimiter
    morestring=[b]" % defines that strings are enclosed in double quotes
} %


\newcommand{\srccode}[1]{\texttt{{#1}}}
\newcommand{\reservedWord}[1]{{\color{blue}\srccode{#1}}\xspace}
\newcommand{\annotation}[1]{{\color{brown}\srccode{#1}}\xspace}

\newcommand{\sdef}{\srccode{=}}
\newcommand{\scolon}{\srccode{:}}

\newcommand{\sif}{\reservedWord{if}}
\newcommand{\sthen}{\reservedWord{then}}
\newcommand{\selse}{\reservedWord{else}}

\newcommand{\sclass}{\reservedWord{class}}
\newcommand{\shas}{\reservedWord{has}}
\newcommand{\sextends}{\reservedWord{extends}}
\newcommand{\swith}{\reservedWord{with}}
\newcommand{\sthis}{\reservedWord{this}}

\newcommand{\sfalse}{\reservedWord{false}}
\newcommand{\strue}{\reservedWord{true}}
\newcommand{\snot}{\reservedWord{not}}
\newcommand{\sand}{\reservedWord{and}}
\newcommand{\sor}{\reservedWord{or}}

\newcommand{\spackage}{\reservedWord{package}}
\newcommand{\simport}{\reservedWord{import}}
\newcommand{\snew}{\reservedWord{new}}

\newcommand{\stailrec}{\annotation{@tailrec}}
\newcommand{\soverride}{\annotation{@override}}
\newcommand{\smain}{\annotation{@main}}

\newcommand{\sequalsSign}{\srccode{==}}

\newcommand{\sasterisk}{\srccode{*}}
\newcommand{\splus}{\srccode{+}}

\newcommand{\sis}{\reservedWord{is}}
\newcommand{\ssuchthat}{\reservedWord{suchthat}}

\newcommand{\scalacase}{\reservedWord{case}}
\newcommand{\scalaclass}{\reservedWord{class}}
\newcommand{\scalaval}{\reservedWord{val}}
\newcommand{\scalavar}{\reservedWord{var}}


\newcommand{\Soda}{\textsc{Soda}\xspace}
\newcommand{\lambdaSymbol}{{\tiny--\textgreater}\xspace}


\begin{document}

    \lstset{frame=tb,
        language=Soda,
        aboveskip=3mm,
        belowskip=3mm,
        showstringspaces=false,
        columns=flexible,
        basicstyle={\small\ttfamily},
        numbers=none,
        numberstyle=\tiny\color{gray},
        keywordstyle=\color{blue},
        commentstyle=\color{gray},
        stringstyle=\color{teal},
        breaklines=true,
        breakatwhitespace=true,
        tabsize=3
    }

    \begin{center}

        \phantom{H}

        \vspace{80mm}

        {\huge{Soda}}

        \vspace{80mm}
        Julian Alfredo Mendez

        \vspace{10mm}
        0.6.0

    \end{center}

    \newpage


    \chapter{Introduction}

    \Soda (Symbolic Objective Descriptive Analysis) is a human-centered formalism to describe, formalize, and prototype ethical problems and constraints.
    It could be seen as a specification language or as a functional programming language.
    A specification or piece of source code written in \Soda needs to be especially easy to read, but it does not need to be easy to write.

    A prototype written in \Soda does not need to be efficient, as long that it can be executed in a \textit{reasonable time}.
    A reasonable time is not a mathematical definition, but a human perception for a specific task.

    The current implementation of \Soda can be translated into Scala, and it relies on its data types.
    Prototypes written in \Soda can be run in the Java Virtual Machine (JVM).
    Therefore, it can be used as a JVM library and use libraries written in Java, Scala, or any other JVM language.

    The reasons of translating \Soda into Scala and not just using Scala could be summarized in three main points.

    The first point is to have a \textbf{lean syntax}.
    \Soda is expected to maximize transparency of written code.
    In general, less reserved words are used.
    For example, there is no need to distinguish between values (in Scala, \scalaval) and variables (in Scala, \scalavar).
    Also, there is no need to distinguish between public, protected or private methods.

    The second point is to have a \textbf{constrained syntax}.
    This means that the only available commands are those of a purely functional approach.
    This prevents creating mutable objects, like when using \scalavar, or changing a class behavior by inheritance, like when using a \scalaclass that is not a \scalacase \scalaclass.
    It is worth noticing that, since \Soda is a JVM language, it also accepts JVM mutable objects.
    However, these objects need to be declared at the beginning, and can be forbidden if that is necessary.

    Finally, the third point is to have \textbf{translation options}.
    \Soda could be translated to other languages that support tail recursion like Kotlin, for example.


    \section{The Intended User of Soda}

    The purpose of \Soda is to give at least one way that is clear enough to describe things, paying less regard to efficiency.

    Let us try to think what problems Soda tries to solve.
    If we think on the first programming languages, like Fortran, Cobol, and Lisp, they had challenges to parse the source code.
    Newer programming languages, like Python or Scala, have clearly more powerful computers to do the processing.

    Lisp source code can look very flexible, but it could be challenging keeping track of the parentheses.

    Fortran has been used by physicist thanks to its important number of libraries for physics.
    Earlier versions of Fortran could not process recursion as we usually do it now, since it did not use a stack for the variables.
    Programming backtracking was extremely intricate.

    \Soda allows writing functions as tail recursive, as in other modern functional languages, and the compiler transforms the tail recursion to an iteration.

    Someone who needs to understand the code does not necessarily need to know how to write a tail recursion.
    Writing a tail recursion requires some knowledge of algorithms, but reading a tail recursion is very intuitive, in a mathematical way.
    Because of this type of asymmetries, we say that \Soda is a language that is easy to read but not necessarily easy to write.

    Since \Soda is intended to maximize transparency, there is no reserved word to declare private methods.
    In object-oriented programming languages, classes and their attributes and methods are declared private to prevent using them outside the intended place.
    In \Soda, a protected class, attribute, or method name can be identified by using an underscore as prefix.


    \section{A Descriptive Language}

    In traditional programming languages, if we need to represent a big data structure, every byte counts.
    If we need to store numbers between 0 and 250, a byte (8 bits) would suffice.
    However, if we need to store numbers between 0 and 260, we would need one more bit (9 bits), which is practice it would mean to use two bytes (16 bits).

    In most cases, we do not care if an integer is 32-bit or 64-bit, and to understand an algorithm, we do not even care if an integer has a fixed length.
    The number of bytes a system uses is a technical issue, and it could complicate the understanding of an algorithm.

    This level of detail is usually irrelevant to describe a problem, unless the problem is about this technicality.
    In other words, it is more natural that a human reads about a number, regardless of how many bits that number needs to be represented.

    In an algorithm, we explain a sequence of steps to accomplish a particular goal.
    If we want to order an array, we can either swap elements in an array, like in bubble sort, or we can choose a pivot, like in quicksort, or use other strategies.

    Is it really important to describe a problem to know how an array is sorted?
    Usually we do not care how an array is being sorted, as long as it takes a \textit{reasonable} time.

    Let us consider another example.
    If we are manipulating strings, and we want to find a particular pattern.
    Finding a pattern is a very common problem.
    As long as there is one way of finding a pattern, we do not really care how it is done.

    \Soda could be seen mostly as a specification language, where we can specify without saying how.
    It could be seen as a programming language as well.

    The important point is that it can provide at least one implementation that is good enough, with an acceptable complexity, to test if something is compliant or not.


    \section{Purpose of \Soda}

    The purpose of \Soda is to give a ``yes'' or ``no'' answer to verify if something is compliant to ethical constraints.
    Ideally, it should also provide an explanation for its answer.

    As said before, \Soda is a formalism with some libraries.
    It is not only a restricted variant of a functional language.
    It is also all the collections of requirements that are useful for defining ethical problems.

    In an iterative process, new ethical problems are formalized in \Soda, and when patterns are found in many problems, they join its libraries.
    Thus, \Soda contains a collection of small classes and functions to accomplish particular tasks.

    In some cases, it could look like a controlled natural language, but it is not its purpose to look like one.
    For example, there are formulas that can be said as a sentence or written as a formula.
    Reading ``the square root of two'' is harder than reading $\sqrt{2}$.
    \Soda code has to be easy to read, not necessarily easy to say, or to write.


    \section{General features}

    The goal of \Soda is to specify without being too specific, giving some freedom for different implementations.
    \Soda tries to keep a good balance between vagueness and concreteness, a good balance between specificity and generality,
    a good balance between what is very descriptive, but also technically useful.

    This happens in a way that is general enough to abstract implementations, but specific enough to constraint a problem.
    We do not need to define how things are done, as long as they are done correctly and in a reasonable time.


    \section{Technical Considerations}

    \Soda needs to be abstract enough to describe, efficient enough, easy to read, easy to execute, and easy to integrate.
    Because of that, \Soda is a JVM language and can be compiled into Java byte code.

    For now, the translator converts \Soda code into Scala code, which in turn can be compiled to byte code.
    For the sake of compatibility with the JVM, \Soda has an \soverride annotation and a \snew command.
    The \soverride annotations is to be able to override JVM definitions, like method \srccode{toString()} in class \srccode{Object}.
    The \snew command is to be able to create JVM objects.

    \Soda uses the main types provided by Scala.
    For example, numeric types like \srccode{Int}, \srccode{Float}, and immutable collections like \srccode{Seq}, \srccode{List}, \srccode{Array}, and \srccode{Map}.
    The JVM exception handling is done via \srccode{Try}.


    \section{Philosophy}

    \Soda is designed to be a functional specification language.
    There are some general rules that apply to it:

    \begin{itemize}
        \item the specification is inteded to be read and understood by a human, so it has to be very clear;
        \item every defined thing is defined only once, in one place;
        \item objects are immutable;
        \item classes cannot be modified, but they can be extended.
    \end{itemize}


    \section{Mutability}

    Mutability is one of the reason that algorithms get more difficult to understand.
    Although it is a practical way to save memory usage, it could be error prone.
    For this reason, \Soda does not have ways to program mutability.

    For technical reasons, it is possible to use mutable objects from the JVM in \Soda.
    This is strongly discouraged, since other design decisions are based assuming that objects are immutable.

    \Soda does not handle exceptions (except when they come from the JVM).
    The exceptions are caught by Scala classes (like \srccode{Try}), as Scala does.

    Functions with side effects, like input and output operations, are discouraged in \Soda.
    In exceptional cases, they could be managed by JVM libraries.


    \section{Constants and Functions}

    In \Soda there are no mutable objects.
    Every value is therefore constant.
    In addition, if a function has no parameters, it is computed as a constant, i.e. it is computed only once and remains unchanged.

    There is a technical difference between constants and functions without parameters.
    While in Scala, the use of parameters is expected to denote side effects, in \Soda it only indicates that the value is recalculated.
    Thus, functions without parameters are evaluated every time they are invoked.
    For constants, \Soda uses \textit{lazy evaluation}, and they are only evaluated when they are used for the first time.

    In \Soda, it is possible to define a function that needs auxiliary computations using bindings.
    This can be done by defining a block between braces (\srccode{\{ \}}).
    In this block, all the auxiliary computations are evaluated only when the last line, the result, needs to be calculated.

    For example, the mathematical formula:
    \begin{center}
        $f(x) = g(x) + g(g(x))$
    \end{center}
    can be rewritten as
    \begin{center}
        $f(x) = a + b$, where $a = g(x)$ and $b = g(a)$.
    \end{center}

    In \Soda, the order is slightly changed, and the result is put at the end:
    \begin{lstlisting}[label={lst:exampleFunctionWithBraces}]
  f (x: Int) = {
    a = g(x)
    b = g(a)
    a + b
  }
    \end{lstlisting}

    This could be read as:
    \begin{center}
        $f(x)$ is a value such that, if $a = g(x)$ and $b = g(a)$, that value is $a + b$.
    \end{center}


    \section{Types and Classes}

    \Soda is statically typed.
    It has some ideas of object orientation.
    However, there are substantial differences with traditional object oriented programming.


    \section{Object Inheritance and Overriding}

    \Soda has two types of classes: abstract classes, and concrete classes.

    Abstract classes are like traits in Scala and interfaces in Java, and either do not have any implementation, or what is implemented cannot be overridden.
    Concrete classes are like case classes in Scala, since they cannot be extended, and have a default constructor.
    Abstract classes are the only classes that can be extended, since no concrete class can be extended.

    Abstract classes can contain \textit{abstract} constants and functions, which are only signatures of constants and functions.

    A class declaration of a concrete class has:
    \begin{itemize}
        \item the name for the new type;
        \item a declaration of its super types, if any;
        \item a possibly empty tuple of required instances to instantiate the class;
        \item a possibly empty sequence of constants and functions.
    \end{itemize}


    An class declaration of an abstract class contains:
    \begin{itemize}
        \item the name for the new type;
        \item a declaration of its super types, if any;
        \item a possibly empty sequence of possibly abstract constants and functions.
    \end{itemize}

    All super types are abstract classes, since concrete classes cannot be extended.

    The declaration of the sequence of constants and functions starts with an left brace (``\srccode{\{}'') and closes with a right brace (``\srccode{\}}'').

    All implemented functions are \textit{final} (cannot be extended), and the same for all defined constants.
    This is to prevent that the behavior is changed after extending a class.
    For technical reasons, the annotation \soverride can be used to override JVM methods that are implemented already, like \srccode{Any.toString}.

    In \Soda, there is a \sthis reserved word where an object can refer to its own instance, but there is no \srccode{super} reserved word.
    The reason is that there is no difference between a function or constant defined in a class or in a super class, if defined.

    It is important to observe that the syntax in \Soda does not restrict the definition of constants in a class that depends on a constructor from the same class.
    In \Soda there is no lazy evaluation, though.
    The evaluation of a constant occurs at the moment of instantiation, trying to evaluate a constant that uses an instance of the same class produces an infinite loop.
    A direct solution to this situation is to emulate the lazy evaluation by using a function without parameters instead of a constant.
    This subtle difference between a constant and a function without parameters are relevant to distinguish the moment when they are evaluated.
    The lack of lazy evaluation makes it relevant the order in which constants are defined in a class.


    \section{Static Constants and Functions}

    In \Soda, there is no concept of static functions.
    It is never assumed that there is one instance of an object.
    The class constructors can be implemented as objects of another class, although not necessary unique.


    \section{Parametric Types}

    The use of parametric types is technically possible and allowed, but slightly discouraged.
    Sometimes smaller code is not necessarily easier to understand.
    Usually, parametric types are needed for highly generic data types, like collections.
    Nevertheless, using parametric types could hide a design flaw, when the code looks ``very general'' but in practice is only applicable to a particular type.


    \section{Style}

    \Soda does not require a semicolon to finish each instruction, and the tabulation at the beginning of the line is irrelevant.
    Consecutive lines ending with a comma character (\srccode{,}) are considered to belong to the same line.

    Braces in the definition of a function should be avoided whenever that is possible.

    Defining a constant or a function requires a space around the equals character (\srccode{=}).
    This character can be used to define parameter names.
    In this case, there should not be any space around the character.

    \begin{lstlisting}[label={lst:exampleFunctionWithoutBraces}]
  class EqualsExample () {
    f (x: Int,
      y: Int) = 2 * x + y

    answer = f (x=20, y=2)
  }
    \end{lstlisting}

    Comments are marked with the \srccode{/*} and  \srccode{*/}.
    The Scaladoc can be used by starting the comment with \srccode{/**}, as in Scala.
    In each line, comments and source code are mutually exclusive, a line that has a comment does not have source code, a line that has source code does not have a comment.

    In general, comments are slightly discouraged, because the code should be descriptive enough.
    If the code is not descriptive enough, it should be refactored instead of commented.
    Comments can very easily get outdated if the source is changed, and the comment is not updated.

    Types are defined after the variables, and they are statically defined.

    The recommended naming convention is using snake case, i.e. separating the words with underscore.
    Class names should start with a capital letter, functions with a lowercase letter.

    Since there are no private functions or constants in a class, the suggestion is to start their name with an underscore.

    This is only a recommendation, since the JVM objects use camel case, i.e. all the words come together, starting with a capital letter.
    Since \Soda can be integrated with other JVM languages, some \Soda code could use camel case.

    Example using snake case, recommended in \Soda

    \begin{lstlisting}[label={lst:exampleExtendsSnakeCase}]
  /** Class for a registered person, in snake case */
  class Registered_person (first_name: String, last_name: String) {
    _separator = " "

    full_name = first_name + _separator + last_name
  }
    \end{lstlisting}

    Example using camel case, as in Java:
    \begin{lstlisting}[label={lst:exampleExtendsCamelCase}]
  /** Class for a registered person, in camel case */
  class RegisteredPerson (firstName: String, lastName: String) {
    _separator = " "

    fullName = firstName + _separator + lastName
  }
    \end{lstlisting}


    \chapter{Reserved words}

    The reserved words in \Soda can be classified in the following categories:

    \begin{itemize}
        \item Functional
        \item Object Oriented
        \item Boolean
        \item Library
        \item Annotations
    \end{itemize}


    The reserved words considered in Scala are listed at this link:
    \url{https://www.scala-lang.org/files/archive/spec/2.13/01-lexical-syntax.html}


    \section{Functional}

    \subsubsection{= (definition symbol)}

    The definition symbol, written as an equals symbol, is used to defined functions and constants.

    For example,
    \begin{lstlisting}[label={lst:exampleDef}]
  a = 1
    \end{lstlisting}

    \subsubsection{: (type symbol)}

    The type symbol, written as a colon symbol, is used to assign a statically defined type to a function or constant.

    For example,
    \begin{lstlisting}[label={lst:exampleType01}]
  b: Int = 2
    \end{lstlisting}

    Another example is the following:
    \begin{lstlisting}[label={lst:exampleType02}]
  plus_one (x: Int): Int = x + 1
    \end{lstlisting}

    \subsubsection{\sif, \sthen, \selse}

    The \sif-\sthen-\selse construct is used to define a conditional result in a function.

    For example,
    \begin{lstlisting}[label={lst:exampleIfThenElse}]
  max (x: Int, y: Int) =
    if x > y
    then x
    else y
    \end{lstlisting}

    \subsubsection{\lambdaSymbol (lambda symbol)}

    The lambda symbol, written as a right arrow, is used to bind a variable in a lambda expression.

    For example, this piece of code
    \begin{lstlisting}[label={lst:exampleLambda}]
  plus_one (sequence: Seq[Int]) =
    sequence.map(element -> element + 1)
    \end{lstlisting}
    returns a sequence of integers where each element is computed as the next integer from the input


    \section{Object Oriented}

    \subsubsection{\sclass, \shas}

    As mentioned, there are two types of classes: the abstract and the concrete.

    Abstract classes compare to interfaces in Java, or traits in Scala, and cannot be directly instantiated.

    Both types are declared using the \sclass reserved words.

    For example,
    \begin{lstlisting}[label={lst:exampleAbstractClass}]
  class Agent {
    has identifier: String
  }
    \end{lstlisting}
    defines an abstract agent that has some identifier.
    Agent is, however, an abstract class and cannot be instantiated.

    By contrast, concrete classes compare to final classes in Java and case classes in Scala.

    The following example shows a concrete class consisting only of a parameterized name.
    \begin{lstlisting}[label={lst:exampleConcreteClass}]
  class Person (name: String)
    \end{lstlisting}

    The difference between abstract classes and concrete classes is the parameters, possibly empty, that are required for concrete classes.

    \subsubsection{\sextends, \swith}

    It is possible to declare that a concrete class extends an abstract class using the \sextends reserved word.
    Concrete classes are final and cannot be extended.

    \begin{lstlisting}[label={lst:exampleExtends}]
  class Agent_Person (name: String) extends Agent {
    identifier = name
  }
    \end{lstlisting}

    Concrete classes can also extend multiple abstract classes.
    For example,
    \begin{lstlisting}[label={lst:exampleWith}]
  class RankedIndividual {
    has rank: Int
  }

  class RankedAgentPerson (name: String, person_rank: Int) extends Agent with RankedIndividual {
    identifier = name

    rank = person_rank
  }
    \end{lstlisting}

    \subsubsection{\sthis}

    In some cases, it could be necessary that an object can refer to itself.
    For that, the \sthis reserved word is used.

    For example,
    \begin{lstlisting}[label={lst:exampleExtendsElement}]
  class Element {
    has accept (v: Visitor): Boolean
  }

  class Visitor {
    has visit (x: Element): Boolean
  }

  class Item (identifier: Int) extends Element {
    accept (v: Visitor) = v.visit (this)
  }
    \end{lstlisting}


    \section{Boolean}

    \subsubsection{\sfalse, \strue}

    As in other programming languages, the \sfalse and \strue reserved words are used for the Boolean values.

    \begin{lstlisting}[label={lst:exampleFalseTrue}]

  my_not (x: Boolean) =
    if x
    then false
    else true

  my_and (x: Boolean, y: Boolean) =
    if x
    then
      if y
      then true
      else false
    else false

  my_or (x: Boolean, y: Boolean) =
    if x
    then true
    else
      if y
      then true
      else false
    \end{lstlisting}

    \subsubsection{\snot, \sand, \sor}

    The reserved words \snot, \sand, \sor are introduced for the sake of readability.

    \begin{lstlisting}[label={lst:exampleNotAndOr}]

  my_xor (x: Boolean, y: Boolean) = (x or y) and not (x and y)

    \end{lstlisting}


    \section{Library}

    \subsubsection{\spackage}

    The reserved word \spackage declares the package where the content should be included.
    All classes then belong to that package.

    \begin{lstlisting}[label={lst:examplePackage}]
  package org.example.soda
    \end{lstlisting}

    \subsubsection{\simport}

    The reserved word \simport helps importing classes from other libraries and frameworks.

    \begin{lstlisting}[label={lst:exampleImport}]
  import java.util.Date
    \end{lstlisting}

    \subsubsection{\snew}

    Although every concrete class can be instantiated directly using the parameters, some JVM libraries and frameworks may need a \snew reserved word.
    For example,

    \begin{lstlisting}[label={lst:exampleImportDate}]
  import java.util.Date

  now = new Date()
    \end{lstlisting}


    \section{Annotations}

    Annotations are not part of the language itself, but they are necessary to translate it into Scala.

    \subsubsection{\soverride}

    The \soverride annotation may be necessary to override some JVM functions, like \srccode{toString()}.
    However, this could be misused to override functions and values of abstract classes.
    This could make that a concrete class does not behave as the abstract class that implements.
    For this reason, although \soverride annotation could be used to ensure that a function is effectively overriding another function, it should only be used to override JVM functions, and not \Soda functions.

    \begin{lstlisting}[label={lst:exampleOverride}]
  class PersonName (name: String) {
    @override
    toString = name
  }
    \end{lstlisting}

    \subsubsection{\stailrec}

    The \stailrec annotation is used to ensure that a recursive function uses tail recursion.
    If a tail recursive function is not properly converted to a loop, it could produce a stack overflow after few iterations.

    For technical reasons, a function with tail recursion needs to be used inside another function.

    \begin{lstlisting}[label={lst:exampleTailrecInside}]
  sum (n: Int) = {
    result = rec (n, 0)

    @tailrec
    rec (n: Int, accum: Int): Int =
      if n < 0
      then accum
      else rec (n - 1, n + accum)

    result
  }
    \end{lstlisting}

    \subsubsection{\smain}

    The \smain annotation is used to indicate that an entry point is needed.
    This is kept to have functions that can be executed from the console.

    \begin{lstlisting}[label={lst:exampleMain}]
  class Main () {
    main (args: Array[String]) =
      println ("Hello world!")
  }

  @main
    \end{lstlisting}

    This \srccode{main} method can be accessed by invoking a statically accessible \srccode{main} method in class \srccode{EntryPoint} located in the same package.


    \section{Synonyms}

    One of the interesting features of \Soda is the use of synonyms.
    They can be used to shape the code for a particular domain.

    The synonyms found only at the beginning of a line are:

    \begin{center}
        \begin{tabular}{|ll|}
            \hline
            \textbf{synonym} & \textbf{reserved word} \\
            \hline
            \sasterisk       & \sclass                \\
            \hline
            \splus           & \simport               \\
            \hline
        \end{tabular}
    \end{center}

    The synonyms that can be at any part of a line are:

    \begin{center}
        \begin{tabular}{|ll|}
            \hline
            \textbf{synonym} & \textbf{reserved word} \\
            \hline
            \sis             & \sdef                  \\
            \hline
            \ssuchthat       & \lambdaSymbol          \\
            \hline
        \end{tabular}
    \end{center}

    As an example we can see the factorial written first in a concise and then in a verbose manner.

    \begin{lstlisting}[label={lst:exampleFactorialConcise}]
  * AbstractFactorialConcise {
    has factorial (n: Int): Int
  }

  * FactorialConcise () extends AbstractFactorialConcise {

    factorial (n: Int) = {
      result = rec (n, 1)

      @tailrec
      rec (n: Int, product: Int): Int =
        if n == 0
        then product
        else rec (n - 1, n * product)

      result
    }
  }
    \end{lstlisting}


    \begin{lstlisting}[label={lst:exampleFactorialVerbose}]
  class AbstractFactorialVerbose {
    has factorial (n: Int): Int
  }

  class FactorialVerbose () extends AbstractFactorialVerbose {

    factorial (n: Int) is {
      result is rec (n, 1)

      @tailrec
      rec (n: Int, product: Int): Int is
        if n == 0
        then product
        else rec (n - 1, n * product)

      result
    }
  }
    \end{lstlisting}


\end{document}

