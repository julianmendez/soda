package soda.collection


* MSeqTranslator[T]() = {

  foldLeftSeq[B, C subtype B](seq: Seq[T], initial_value: C,
      next_value: (B, T) -> C): C =
    let
      @tailrec
      rec(seq: Seq[T], acc: C, next_value: (B, T) -> C): C =
        if seq.isEmpty
        then acc
        else rec(seq.tail, next_value(acc, seq.head), next_value)

    in rec(seq, initial_value, next_value)

  asMSeq(seq: Seq[T]): MSeq[T] =
    let
      initial_value: MSeq[T] = Min().empty
      next_value(acc: MSeq[T], elem: T): MSeq[T] = Min().prepended(acc, elem)
    in Min().reverse(
        foldLeftSeq[MSeq[T], MSeq[T]](seq, initial_value, next_value) )

  asSeq(mseq: MSeq[T]): Seq[T] =
    let
      initial_value: Seq[T] = Seq()
      next_value(acc: Seq[T], elem: T): Seq[T] = acc.+:(elem)
    in Min().foldLeft(mseq, initial_value, next_value).reverse
}

* MSeqPair[T](left: MSeq[T], right: MSeq[T])

* Min[T]() = {
  + soda.lib.OptionSD
  + soda.lib.SomeSD
  + soda.lib.NoneSD

  empty: ESeq[T] = ESeq()

  prepended(s: MSeq[T], e: T): NESeq[T] = NESeq(e, s)

  head(s: NESeq[T]): T = s.head()

  tail(s: NESeq[T]): MSeq[T] = s.tail()

  nonEmpty(s: MSeq[T]): Boolean = not isEmpty(s)

  isEmpty(s: MSeq[T]): Boolean = s.isEmpty

  /* */

  foldLeftWhile[B, C subtype B](s: MSeq[T], initial_value: C, next_value: (B, T) -> C,
      condition: (B, T) -> Boolean): C =
    s.foldLeftWhile[B, C](initial_value, next_value, condition)

  foldLeft[B, C subtype B](s: MSeq[T], initial_value: C, next_value: (B, T) -> C): C =
    let
      condition(acc: B, elem: T): Boolean = true
    in foldLeftWhile[B, C](s, initial_value, next_value, condition)

  reverse(s: MSeq[T]): MSeq[T] =
    s.opt(ifEmpty := empty, ifNonEmpty := (neseq -> reverseNonEmpty(neseq)))

  reverseNonEmpty(s: NESeq[T]): NESeq[T] =
    let
      initial_value: NESeq[T] = prepended(empty, s.head())
      next_value(acc: MSeq[T], elem: T): NESeq[T] = prepended(acc, elem)
    in foldLeft(s.tail(), initial_value, next_value)

  length(s: MSeq[T]): Int =
    let
      initial_value: Int = 0
      next_value(acc: Int, elem: T): Int = acc + 1
    in foldLeft(s, initial_value, next_value)

  indexOf(s: MSeq[T], e: T): Int =
    let
      initial_value = FoldTuple(0, -1)
      next_value(tuple: FoldTuple, elem: T): FoldTuple =
        FoldTuple(tuple.index + 1,
          if elem == e then tuple.index else tuple.position)
      condition(tuple: FoldTuple, elem: T): Boolean = tuple.position == -1
      * FoldTuple(index: Int, position: Int)

    in foldLeftWhile(s, initial_value, next_value, condition).position

  contains(s: MSeq[T], e: T): Boolean =
    let
      initial_value: Boolean = false
      next_value(acc: Boolean, elem: T): Boolean = elem == e
      condition(acc: Boolean, elem: T): Boolean = not acc
    in foldLeftWhile(s, initial_value, next_value, condition)

  at(s: MSeq[T], n: Int): OptionSD[T] =
    s.opt(
      ifEmpty := NoneSD[T](),
      ifNonEmpty := (neseq ->
        if n < 0 or n >= length(s)
        then NoneSD[T]()
        else SomeSD[T](_atNonEmpty(neseq, n))
      )
    )

  _atNonEmpty(xs: NESeq[T], n: Int): T =
    let
      initial_value = FoldTuple(xs.head(), -1)
      next_value(tuple: FoldTuple, elem: T): FoldTuple = FoldTuple(elem, tuple.index + 1)
      condition(tuple: FoldTuple, elem: T): Boolean = tuple.index < n

      * FoldTuple(elem: T, index: Int)

    in foldLeftWhile(xs, initial_value, next_value, condition).elem

  /* */

  take(s: MSeq[T], n: Int): MSeq[T] =
    let
      initial_value = FoldTuple(empty, 0)
      next_value(tuple: FoldTuple, elem: T): FoldTuple =
        FoldTuple(prepended(tuple.seq, elem), tuple.index + 1)
      condition (tuple: FoldTuple, elem: T): Boolean = tuple.index < n

      * FoldTuple(seq: MSeq[T], index: Int)

    in reverse(
        foldLeftWhile(s, initial_value, next_value, condition).seq )

  drop(s: MSeq[T], n: Int): MSeq[T] =
    let
      initial_value = FoldTuple(s, 0)
      next_value(tuple: FoldTuple, elem: T): FoldTuple =
        tuple.seq.opt(
          ifEmpty := FoldTuple(tuple.seq, tuple.index + 1),
          ifNonEmpty := (neseq -> FoldTuple(neseq.tail(), tuple.index + 1) )
        )
      condition (tuple: FoldTuple, elem: T): Boolean =
        tuple.index < n

      * FoldTuple(seq: MSeq[T], index: Int)

    in foldLeftWhile(s, initial_value, next_value, condition).seq

  takeWhile(s: MSeq[T], p: (T -> Boolean)): MSeq[T] = reverse(spanRevRec(s, p).left)

  dropWhile(s: MSeq[T], p: (T -> Boolean)): MSeq[T] = spanRevRec(s, p).right

  splitAt(s: MSeq[T], n: Int): MSeqPair[T] = MSeqPair(take(s, n), drop(s, n))

  span(s: MSeq[T], p: (T -> Boolean)): MSeqPair[T] =
    let
      pair = spanRevRec(s, p)
    in MSeqPair(reverse(pair.left), pair.right)

  /* */

  appended(s: MSeq[T], e: T): MSeq[T] = reverse(prepended(reverse(s), e))

  last(s: NESeq[T]): T = reverseNonEmpty(s).head()

  concat(s0: MSeq[T], s1: MSeq[T]): MSeq[T] =
    let
      initial_value: MSeq[T] = s1
      next_value(acc: MSeq[T], elem: T): MSeq[T] = prepended(acc, elem)
      s0rev = reverse(s0)
    in foldLeft(s0rev, initial_value, next_value)

  slice(s: MSeq[T], from: Int, until: Int): MSeq[T] = take(drop(s, from), until - from)

  /* */

  forall(s: MSeq[T], p: (T -> Boolean)): Boolean =
    let
      initial_value = true
      next_value(acc: Boolean, elem: T): Boolean = acc and p(elem)
      condition(acc: Boolean, elem: T): Boolean = acc
    in foldLeftWhile(s, initial_value, next_value, condition)

  exists(s: MSeq[T], p: (T -> Boolean)): Boolean =
    let
      initial_value = false
      next_value(acc: Boolean, elem: T): Boolean = acc or p(elem)
      condition(acc: Boolean, elem: T): Boolean = not acc
    in foldLeftWhile(s, initial_value, next_value, condition)

  find(s: MSeq[T], p: (T -> Boolean)): OptionSD[T] =
    let
      initial_value = NoneSD[T]()
      next_value(acc: OptionSD[T], elem: T): OptionSD[T] =
        if p(elem) then SomeSD[T](elem) else NoneSD[T]()
      condition(acc: OptionSD[T], elem: T): Boolean = acc.isEmpty
    in foldLeftWhile(s, initial_value, next_value, condition)

  filter(s: MSeq[T], p: (T -> Boolean)): MSeq[T] =
    let
      initial_value = empty
      next_value(acc: MSeq[T], elem: T): MSeq[T] =
        if p(elem)
        then prepended(acc, elem)
        else acc
    in reverse( foldLeft(s, initial_value, next_value) )

  map0(s: MSeq[T], f: (T -> T)): MSeq[T] =
    let
      initial_value = empty
      next_value(acc: MSeq[T], elem: T): MSeq[T] =
        prepended(acc, f(elem))
    in reverse( foldLeft(s, initial_value, next_value) )

  /**
   * <pre>
   * def foldLeft[B](z: B)(op: (B, A) -> B): B = {
   * . var result = z
   * . it = iterator
   * . while (it.hasNext) {
   * . . result = op(result, it.next())
   * . }
   * . result
   * }
   * </pre>
   */
  foldLeft0(mseq: MSeq[T]): (MSeq[T], ((MSeq[T], T) -> MSeq[T])) -> MSeq[T] =
    (initial_value: MSeq[T], next_value: ((MSeq[T], T) -> MSeq[T])) -> foldLeft(mseq, initial_value, next_value)

  /* */

  spanRevRec(s0: MSeq[T], p: T -> Boolean): MSeqPair[T] =
    let
      result = MSeqPair(pair.right, pair.left)
      pair = foldLeftWhile(s0, initial_value, next_value, condition)

      initial_value = FoldTuple(s0, empty, true)

      next_value(tuple: FoldTuple, elem: T): FoldTuple =
        let
          left = tuple.left
          right = tuple.right
          result = left.opt(
            ifEmpty := FoldTuple(left, right, false),
            ifNonEmpty := (neleft ->
              let
                e = neleft.head()
                new_taking = p(e)

                new_tuple =
                  if new_taking
                  then FoldTuple(neleft.tail(), prepended(right, e), new_taking)
                  else FoldTuple(neleft, right, new_taking)
              in new_tuple
            )
          )
        in result

      condition(tuple: FoldTuple, elem: T): Boolean = tuple.taking

      * FoldTuple(left: MSeq[T], right: MSeq[T], taking: Boolean)

    in result
}

