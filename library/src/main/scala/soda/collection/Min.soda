package soda.collection

class MSeqTranslator [A]

  @tailrec
  _tailrec_foldLeftSeq [B] (sequence : Seq [A] ) (current_value : B) (next_value : B -> A -> B) : B =
    if sequence.isEmpty
    then current_value
    else _tailrec_foldLeftSeq (sequence.tail) (next_value (current_value) (sequence.head) ) (next_value)

  foldLeftSeq [B] (sequence : Seq [A] ) (initial_value : B) (next_value : B -> A -> B) : B =
    _tailrec_foldLeftSeq (sequence) (initial_value) (next_value)

  asMSeq (seq : Seq [A] ) : MSeq [A] =
    let
      initial_value : MSeq [A] = Min_ ().empty
      next_value (acc : MSeq [A] ) (elem : A) : MSeq [A] = Min_ ().prepended (acc) (elem)
    in Min_ ().reverse (foldLeftSeq [MSeq [A] ] (seq) (initial_value) (next_value) )

  asSeq (mseq : MSeq [A] ) : Seq [A] =
    let
      initial_value : Seq [A] = Seq ()
      next_value (acc : Seq [A] ) (elem : A) : Seq [A] = acc.+: (elem)
    in (Min_ ().foldLeft (mseq) (initial_value) (next_value) ).reverse

end

class MSeqPair [A]

  abstract
    left : MSeq [A]
    right : MSeq [A]

end

class Min [A]

  import
    soda.lib.NoneSD_
    soda.lib.OptionSD
    soda.lib.SomeSD_

  empty : ESeq [A] = ESeq_ ()

  prepended (s : MSeq [A] ) (e : A) : NESeq [A] =
    NESeq_ (e, s)

  head (s : NESeq [A] ) : A =
    s.head

  tail (s : NESeq [A] ) : MSeq [A] =
    s.tail

  nonEmpty (s : MSeq [A] ) : Boolean =
    not isEmpty (s)

  isEmpty (s : MSeq [A] ) : Boolean =
    s.isEmpty

  /* */

  foldLeftWhile [B] (s : MSeq [A] ) (initial_value : B) (next_value : B -> A -> B) (condition : B -> A -> Boolean) : B =
    MSeqRec_ [A] ().fold_while [B] (s) (initial_value) (next_value) (condition)

  foldLeft [B] (s : MSeq [A] ) (initial_value : B) (next_value : B -> A -> B) : B =
    foldLeftWhile (s) (initial_value) (next_value) (lambda (acc : B) -> lambda (elem : A) -> true)

  reverse (s : MSeq [A] ) : MSeq [A] =
    s.opt [MSeq [A] ] (ifEmpty := empty) (ifNonEmpty := lambda neseq -> reverseNonEmpty (neseq) )

  reverseNonEmpty (s : NESeq [A] ) : NESeq [A] =
    let
      initial_value : NESeq [A] = prepended (empty) (s.head)
      next_value (acc : MSeq [A] ) (elem : A) : NESeq [A] = prepended (acc) (elem)
    in foldLeft (s.tail) (initial_value) (next_value)

  length (s : MSeq [A] ) : Int =
    let
      initial_value : Int = 0
      next_value (acc : Int) (elem : A) : Int = acc + 1
    in foldLeft (s) (initial_value) (next_value)

  indexOf (s : MSeq [A] ) (e : A) : Int =
    let
      initial_value : IndexFoldTuple [A] = IndexFoldTuple_ [A] (0, -1)
      next_value (tuple : IndexFoldTuple [A] ) (elem : A) : IndexFoldTuple [A] =
        IndexFoldTuple_ [A] (tuple.index + 1,
          if elem == e then tuple.index else tuple.position)
      condition (tuple : IndexFoldTuple [A] ) (elem : A) : Boolean = tuple.position == -1
    in (foldLeftWhile (s) (initial_value) (next_value) (condition) ).position

  contains (s : MSeq [A] ) (e : A) : Boolean =
    let
      initial_value : Boolean = false
      next_value (acc : Boolean) (elem : A) : Boolean = elem == e
      condition (acc : Boolean) (elem : A) : Boolean = not acc
    in foldLeftWhile (s) (initial_value) (next_value) (condition)

  at (s : MSeq [A] ) (n : Int) : OptionSD [A] =
    s.opt [OptionSD [A] ] (
      ifEmpty := NoneSD_ [A] () ) (
      ifNonEmpty := (neseq ->
        if n < 0 or n >= length (s)
        then NoneSD_ [A] ()
        else SomeSD_ [A] (_atNonEmpty (neseq ) (n) )
      )
    )

  _atNonEmpty (xs : NESeq [A] ) (n : Int) : A =
    let
      initial_value : AtFoldTuple [A] = AtFoldTuple_ [A] (xs.head, -1)
      next_value (tuple : AtFoldTuple [A] ) (elem : A) : AtFoldTuple [A] = AtFoldTuple_ [A] (elem, tuple.index + 1)
      condition (tuple : AtFoldTuple [A] ) (elem : A) : Boolean = tuple.index < n
    in (foldLeftWhile (xs) (initial_value) (next_value) (condition) ).elem

  /* */

  take (s : MSeq [A] ) (n : Int) : MSeq [A] =
    let
      initial_value : TakeDropFoldTuple [A] = TakeDropFoldTuple_ [A] (empty, 0)
      next_value (tuple : TakeDropFoldTuple [A] ) (elem : A) : TakeDropFoldTuple [A] =
        TakeDropFoldTuple_ [A] (prepended (tuple.seq) (elem), tuple.index + 1)
      condition (tuple : TakeDropFoldTuple [A] ) (elem : A) : Boolean = tuple.index < n
    in reverse ( (foldLeftWhile (s) (initial_value) (next_value) (condition) ).seq )

  drop (s : MSeq [A] ) (n : Int) : MSeq [A] =
    let
      initial_value : TakeDropFoldTuple [A] = TakeDropFoldTuple_ [A] (s, 0)
      next_value (tuple : TakeDropFoldTuple [A] ) (elem : A) : TakeDropFoldTuple [A] =
        tuple.seq.opt (
          ifEmpty := TakeDropFoldTuple_ [A] (tuple.seq, tuple.index + 1) ) (
          ifNonEmpty := lambda neseq -> TakeDropFoldTuple_ [A] (neseq.tail, tuple.index + 1)
        )
      condition (tuple : TakeDropFoldTuple [A] ) (elem : A) : Boolean =
        tuple.index < n
    in (foldLeftWhile (s) (initial_value) (next_value) (condition) ).seq

  takeWhile (s : MSeq [A] ) (p : A -> Boolean) : MSeq [A] = reverse ( (spanRevRec (s) (p) ).left)

  dropWhile (s : MSeq [A] ) (p : A -> Boolean) : MSeq [A] = (spanRevRec (s) (p) ).right

  splitAt (s : MSeq [A] ) (n : Int) : MSeqPair [A] = MSeqPair_ (take (s) (n), drop (s) (n) )

  span (s : MSeq [A] ) (p : A -> Boolean) : MSeqPair [A] =
    let
      pair = spanRevRec (s) (p)
    in MSeqPair_ (reverse (pair.left), pair.right)

  /* */

  appended (s : MSeq [A] ) (e : A) : MSeq [A] = reverse (prepended (reverse (s) ) (e) )

  last (s : NESeq [A] ) : A = reverseNonEmpty (s).head

  concat (s0 : MSeq [A] ) (s1 : MSeq [A] ) : MSeq [A] =
    let
      initial_value : MSeq [A] = s1
      next_value (acc : MSeq [A] ) (elem : A) : MSeq [A] = prepended (acc) (elem)
      s0rev = reverse (s0)
    in foldLeft (s0rev) (initial_value) (next_value)

  slice (s : MSeq [A] ) (from : Int) (until : Int) : MSeq [A] = take (drop (s) (from) ) (until - from)

  /* */

  forall (s : MSeq [A] ) (p : A -> Boolean) : Boolean =
    let
      initial_value : Boolean = true
      next_value (acc : Boolean) (elem : A) : Boolean = acc and p (elem)
      condition (acc : Boolean) (elem : A) : Boolean = acc
    in foldLeftWhile (s) (initial_value) (next_value) (condition)

  exists (s : MSeq [A] ) (p : A -> Boolean ) : Boolean =
    let
      initial_value : Boolean = false
      next_value (acc : Boolean) (elem : A) : Boolean = acc or p (elem)
      condition (acc : Boolean) (elem : A) : Boolean = not acc
    in foldLeftWhile (s) (initial_value) (next_value) (condition)

  find (s : MSeq [A] ) (p : A -> Boolean) : OptionSD [A] =
    let
      initial_value : OptionSD [A] = NoneSD_ [A] ()
      next_value (acc : OptionSD [A] ) (elem : A) : OptionSD [A] =
        if p (elem) then SomeSD_ [A] (elem) else NoneSD_ [A] ()
      condition (acc : OptionSD [A] ) (elem : A) : Boolean = acc.isEmpty
    in foldLeftWhile (s) (initial_value) (next_value) (condition)

  filter (s : MSeq [A] ) (p : A -> Boolean) : MSeq [A] =
    let
      initial_value : MSeq [A] = empty
      next_value (acc : MSeq [A] ) (elem : A) : MSeq [A] =
        if p (elem)
        then prepended (acc) (elem)
        else acc
    in reverse (foldLeft (s) (initial_value) (next_value) )

  map0 (s : MSeq [A] ) (f : A -> A) : MSeq [A] =
    let
      initial_value : MSeq [A] = empty
      next_value (acc : MSeq [A] ) (elem : A) : MSeq [A] =
        prepended (acc) (f (elem) )
    in reverse (foldLeft (s) (initial_value) (next_value) )

  /**
   * <pre>
   * def foldLeft [B] (z : B) (op : (B, A) -> B) : B =
   * . var result = z
   * . it = iterator
   * . while (it.hasNext) {
   * . . result = op (result, it.next () )
   * . }
   * . result
   * end
   * </pre>
   */
  foldLeft0 (mseq : MSeq [A] ) : MSeq [A] -> (MSeq [A] -> A -> MSeq [A] ) -> MSeq [A] =
    lambda (initial_value : MSeq [A] ) ->
      lambda (next_value : MSeq [A] -> A -> MSeq [A] ) ->
        foldLeft (mseq) (initial_value) (next_value)

  /* */

  spanRevRec (s0 : MSeq [A] ) (p : A -> Boolean) : MSeqPair [A] =
    let
      result = MSeqPair_ (pair.right, pair.left)
      pair = foldLeftWhile (s0) (initial_value) (next_value) (condition)
      initial_value : SpanRevFoldTuple [A] = SpanRevFoldTuple_ [A] (s0, empty, true)
      next_value (tuple : SpanRevFoldTuple [A] ) (elem : A) : SpanRevFoldTuple [A] =
        let
          left = tuple.left
          right = tuple.right
          result = left.opt [SpanRevFoldTuple [A] ] (
            ifEmpty := SpanRevFoldTuple_ [A] (left, right, false) ) (
            ifNonEmpty := lambda neleft -> _aux_next_value (tuple) (p) (neleft)
          )
        in result
      condition (tuple : SpanRevFoldTuple [A] ) (elem : A) : Boolean = tuple.taking
    in result

  _aux_next_value (tuple : SpanRevFoldTuple [A] ) (p : A -> Boolean) (neleft : NESeq [A] ) : SpanRevFoldTuple [A] =
    let
      left = tuple.left
      right = tuple.right
      e = neleft.head
      new_taking = p (e)
      new_tuple =
        if new_taking
        then SpanRevFoldTuple_ [A] (neleft.tail, prepended (right) (e), new_taking)
        else SpanRevFoldTuple_ [A] (neleft, right, new_taking)
    in new_tuple

end

class IndexFoldTuple [A]

  abstract
    index : Int
    position : Int

end

class AtFoldTuple [A]

  abstract
    elem : A
    index : Int

end

class TakeDropFoldTuple [A]

  abstract
    seq : MSeq [A]
    index : Int

end

class SpanRevFoldTuple [A]

  abstract
    left : MSeq [A]
    right : MSeq [A]
    taking : Boolean

end

