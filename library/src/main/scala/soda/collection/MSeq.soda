package soda.collection

class MSeq [T]

  abstract
    isEmpty: Boolean
    opt [B] (ifEmpty: B, ifNonEmpty: NESeq [T] -> B): B

end

class MSeqRec [T]

  @tailrec
  _tailrec_fold [B, C subtype B] (sequence: MSeq [T], current_value: C, next_value:  (B, T) -> C, condition:  (B, T) -> Boolean): C =
    if sequence.isEmpty
    then current_value
    else
      let
        neseq = sequence.opt (ifEmpty := None, ifNonEmpty :=  (x -> Some (x))).get
      in if not condition (current_value, neseq.head ()) then current_value else _tailrec_fold (neseq.tail (), next_value (current_value, neseq.head ()), next_value, condition)

  fold [B, C subtype B] (sequence: MSeq [T], initial_value: C, next_value:  (B, T) -> C, condition:  (B, T) -> Boolean): C =
    _tailrec_fold (sequence, initial_value, next_value, condition)

end

class MSeqRec_ [T] ()
  extends
    MSeqRec [T]

end

class ESeq [T]
  extends
    MSeq [T]

  isEmpty = true

  opt [B] (ifEmpty: B, ifNonEmpty: NESeq [T] -> B): B = ifEmpty

end

class ESeq_ [T] ()
  extends
    ESeq [T]

end

class NEMSeq [T]
  extends
    MSeq [T]

  abstract
    head0: T
    tail0: MSeq [T]

end

class NESeq [T]
  extends
    NEMSeq [T]

  isEmpty = false

  opt [B] (ifEmpty: B, ifNonEmpty: NESeq [T] -> B): B = ifNonEmpty (this)

  head (): T = head0

  tail (): MSeq [T] = tail0

end

class NESeq_ [T] (head0: T, tail0: MSeq [T])
  extends
    NESeq [T]

end

