package soda.collection

class MSeq [T]

  abstract
    isEmpty: Boolean
    _as_NESeq: Option [NESeq [T] ]

  opt [B] (ifEmpty: B, ifNonEmpty: NESeq [T] -> B): B =
    if isEmpty
    then ifEmpty
    else ifNonEmpty (_as_NESeq.get)

end

class MSeqRec [T]

  @tailrec
  _tailrec_fold [B, C subtype B] (sequence: MSeq [T], current_value: C, next_value:  (B, T) -> C, condition:  (B, T) -> Boolean): C =
    if sequence.isEmpty
    then current_value
    else
      let
        neseq = sequence.opt (ifEmpty := None, ifNonEmpty := (x -> Some (x) ) ).get
      in if not condition (current_value, neseq.head) then current_value else _tailrec_fold (neseq.tail, next_value (current_value, neseq.head), next_value, condition)

  fold [B, C subtype B] (sequence: MSeq [T], initial_value: C, next_value:  (B, T) -> C, condition:  (B, T) -> Boolean): C =
    _tailrec_fold (sequence, initial_value, next_value, condition)

end

class MSeqRec_ [T] ()
  extends
    MSeqRec [T]

end

class ESeq [T]
  extends
    MSeq [T]

  isEmpty = true

  _as_NESeq: Option [NESeq [T] ] = None

end

class ESeq_ [T] ()
  extends
    ESeq [T]

end

class NEMSeq [T]
  extends
    MSeq [T]

  abstract
    head0: T
    tail0: MSeq [T]

end

class NESeq [T]
  extends
    NEMSeq [T]

  isEmpty = false

  _as_NESeq: Option [NESeq [T] ] = Some (this)

  head: T = head0

  tail: MSeq [T] = tail0

end

class NESeq_ [T] (head0: T, tail0: MSeq [T])
  extends
    NESeq [T]

end

