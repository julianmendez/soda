package soda.collection


* MSeq[T] = {

  has isEmpty: Boolean

  has opt[B](ifEmpty: B, ifNonEmpty: NESeq[T] -> B): B
}

* MSeqRec[T] = {

  fold[B, C subtype B](mseq: MSeq[T],
      initial_value: C, next_value: (B, T) -> C, condition: (B, T) -> Boolean): C =
    let
      @tailrec
      rec(seq: MSeq[T], acc: C, next_value: (B, T) -> C, condition: (B, T) -> Boolean): C =
        if seq.isEmpty
        then acc
        else
          let
            neseq = seq.opt(ifEmpty := None, ifNonEmpty := (x -> Some(x))).get
          in if not condition(acc, neseq.head()) then acc else rec(
               neseq.tail(), next_value(acc, neseq.head()), next_value, condition)
    in rec(mseq, initial_value, next_value, condition)
}

* MSeqRec_[T]()
  extends MSeqRec[T]

* ESeq[T]
  extends MSeq[T] = {

  isEmpty = true

  opt[B](ifEmpty: B, ifNonEmpty: NESeq[T] -> B): B = ifEmpty
}

* ESeq_[T]()
  extends ESeq[T]

* NEMSeq[T]
  extends MSeq[T] = {

  has head0: T

  has tail0: MSeq[T]
}

* NESeq[T]
  extends NEMSeq[T] = {

  isEmpty = false

  opt[B](ifEmpty: B, ifNonEmpty: NESeq[T] -> B): B = ifNonEmpty(this)

  head(): T = head0

  tail(): MSeq[T] = tail0
}

* NESeq_[T](head0: T, tail0: MSeq[T])
  extends NESeq[T]

