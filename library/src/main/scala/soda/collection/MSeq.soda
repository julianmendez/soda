package soda.collection


* MSeq[T] = {
  has isEmpty: Boolean

  has opt[B](ifEmpty: B, ifNonEmpty: NESeq[T] -> B): B

  foldLeftWhile[B, C subtype B](initial_value: C,
      next_value: (B, T) -> C, condition: (B, T) -> Boolean): C =
    let
      @tailrec
      rec(seq: MSeq[T], acc: C, next_value: (B, T) -> C, condition: (B, T) -> Boolean): C =
        if seq.isEmpty
        then acc
        else
          let
            neseq = seq.opt(ifEmpty := None, ifNonEmpty := (x -> Some(x))).get
          in if not condition(acc, neseq.head()) then acc else rec(
               neseq.tail(), next_value(acc, neseq.head()), next_value, condition)
    in rec(this, initial_value, next_value, condition)
}

* ESeq[T] extends MSeq[T] = {

  isEmpty = true

  opt[B](ifEmpty: B, ifNonEmpty: NESeq[T] -> B): B = ifEmpty
}

* ESeq_[T]() extends ESeq[T]

* NESeq[T] extends MSeq[T] = {

  has head0: T

  has tail0: MSeq[T]

  isEmpty = false

  opt[B](ifEmpty: B, ifNonEmpty: NESeq[T] -> B): B = ifNonEmpty(this)

  head(): T = head0

  tail(): MSeq[T] = tail0
}

* NESeq_[T](head0: T, tail0: MSeq[T]) extends NESeq[T]

