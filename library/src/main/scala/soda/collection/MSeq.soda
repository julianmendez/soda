package soda.collection


* MSeq[T] = {
  has isEmpty: Boolean

  has opt[B](ifEmpty: B, ifNonEmpty: NESeq[T] -> B): B

  foldLeftWhile[B, C subtype (B)](initial_value: C,
      next_value: (B, T) -> C, condition: (B, T) -> Boolean): C = {

    result = rec(this, initial_value, next_value, condition)

    @tailrec
    rec(seq: MSeq[T], acc: C, next_value: (B, T) -> C, condition: (B, T) -> Boolean): C =
      if seq.isEmpty
      then acc
      else {
        neseq = seq.opt(ifEmpty := None, ifNonEmpty := (x -> Some(x))).get
        if not condition(acc, neseq.head())
        then acc
        else rec(neseq.tail(), next_value(acc, neseq.head()), next_value, condition)
      }

    result
  }

}


* ESeq[T] () extends MSeq[T] = {

  isEmpty = true

  opt[B](ifEmpty: B, ifNonEmpty: NESeq[T] -> B): B = ifEmpty

}


* NESeq[T] (head0: T, tail0: MSeq[T]) extends MSeq[T] = {

  isEmpty = false

  opt[B](ifEmpty: B, ifNonEmpty: NESeq[T] -> B): B = ifNonEmpty(this)

  head(): T = head0

  tail(): MSeq[T] = tail0

}

