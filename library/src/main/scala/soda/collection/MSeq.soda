package soda.collection

class MSeq [T]

  abstract
    isEmpty: Boolean

  opt [B] (ifEmpty: B, ifNonEmpty: NESeq [T] -> B): B =
    match this
      | ESeq_ () => ifEmpty
      | NESeq_ (head, tail) => ifNonEmpty (NESeq_ (head, tail) )
    end

end

class MSeqRec [T]

  @tailrec
  _tailrec_fold [B, C subtype B] (sequence: MSeq [T], current_value: C, next_value:  (B, T) -> C, condition:  (B, T) -> Boolean): C =
    if sequence.isEmpty
    then current_value
    else
      let
        neseq = sequence.opt (ifEmpty := None, ifNonEmpty := (x -> Some (x) ) ).get
      in if not condition (current_value, neseq.head) then current_value else _tailrec_fold (neseq.tail, next_value (current_value, neseq.head), next_value, condition)

  fold [B, C subtype B] (sequence: MSeq [T], initial_value: C, next_value:  (B, T) -> C, condition:  (B, T) -> Boolean): C =
    _tailrec_fold (sequence, initial_value, next_value, condition)

end

class ESeq [T]
  extends
    MSeq [T]

  isEmpty = true

end

class NEMSeq [T]
  extends
    MSeq [T]

  abstract
    head0: T
    tail0: MSeq [T]

  isEmpty = false

end

class NESeq [T]
  extends
    NEMSeq [T]

  abstract
    head0: T
    tail0: MSeq [T]

  head: T = head0

  tail: MSeq [T] = tail0

end

