package soda.collection


* MSeq[T] = {

  has isEmpty: Boolean

  has opt[B](ifEmpty: B, ifNonEmpty: NESeq[T] -> B): B

}

* MSeqRec[T] = {

  @tailrec
  _rec_fold[B, C subtype B](sequence: MSeq[T],
      current_value: C, next_value: (B, T) -> C, condition: (B, T) -> Boolean): C =
    if sequence.isEmpty
    then current_value
    else
      let
        neseq = sequence.opt(ifEmpty := None, ifNonEmpty := (x -> Some(x))).get
      in if not condition(current_value, neseq.head()) then current_value else _rec_fold(
           neseq.tail(), next_value(current_value, neseq.head()), next_value, condition)

  fold[B, C subtype B](sequence: MSeq[T],
      initial_value: C, next_value: (B, T) -> C, condition: (B, T) -> Boolean): C =
    _rec_fold(sequence, initial_value, next_value, condition)

}

* MSeqRec_[T]()
  extends MSeqRec[T]

* ESeq[T]
  extends MSeq[T] = {

  isEmpty = true

  opt[B](ifEmpty: B, ifNonEmpty: NESeq[T] -> B): B = ifEmpty

}

* ESeq_[T]()
  extends ESeq[T]

* NEMSeq[T]
  extends MSeq[T] = {

  has head0: T

  has tail0: MSeq[T]

}

* NESeq[T]
  extends NEMSeq[T] = {

  isEmpty = false

  opt[B](ifEmpty: B, ifNonEmpty: NESeq[T] -> B): B = ifNonEmpty(this)

  head(): T = head0

  tail(): MSeq[T] = tail0

}

* NESeq_[T](head0: T, tail0: MSeq[T])
  extends NESeq[T]

