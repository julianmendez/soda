package soda.collection

class MSeq [T]

  abstract
    isEmpty : Boolean

  opt [B] (ifEmpty : B) (ifNonEmpty : NESeq [T] -> B) : B =
    match this
      | ESeq_ () => ifEmpty
      | NESeq_ (head, tail) => ifNonEmpty (NESeq_ (head, tail) )
    end

end

class MSeqRec [T]

  @tailrec
  _tailrec_fold_while [B] (sequence : MSeq [T] ) (current_value : B) (next_value_function : B -> T -> B) (condition : B -> T -> Boolean) : B =
    match sequence
      case ESeq_ () => current_value
      case NESeq_ (head, tail) =>
        if not condition (current_value) (head)
        then current_value
        else _tailrec_fold_while (tail) (next_value_function (current_value) (head) ) (next_value_function) (condition)
      end

  fold_while [B] (sequence : MSeq [T] ) (initial_value : B) (next_value : B -> T -> B) (condition : B -> T -> Boolean) : B =
    _tailrec_fold_while (sequence) (initial_value) (next_value) (condition)

end

class ESeq [T]
  extends
    MSeq [T]

  isEmpty = true

end

class NEMSeq [T]
  extends
    MSeq [T]

  abstract
    head0 : T
    tail0 : MSeq [T]

  isEmpty = false

end

class NESeq [T]
  extends
    NEMSeq [T]

  abstract
    head0 : T
    tail0 : MSeq [T]

  head : T = head0

  tail : MSeq [T] = tail0

end

