package se.umu.cs.rai.scopus.collection


+ scala.annotation.tailrec


* MSeqTranslator() {

  asMSeq(s: Seq[Elem]): MSeq = Min().reverse(asMSeqRec(s, Min().empty))

  asSeq(ms: MSeq): Seq[Elem] = asSeqRec(ms, Seq()).reverse

  @tailrec
  asMSeqRec(seq: Seq[Elem], ms: MSeq): MSeq =
    if seq.isEmpty
    then ms
    else asMSeqRec(seq.tail, Min().prepended(ms, seq.head))

  @tailrec
  asSeqRec(ms: MSeq, seq: Seq[Elem]): Seq[Elem] =
    if Min().isEmpty(ms)
    then seq
    else asSeqRec(Min().tail(ms), seq.prepended(Min().head(ms)))

}


* Min() {

  empty: MSeq = ESeq()

  prepended(s: MSeq, e: Elem): MSeq = NESeq(e, s)

  head(s: MSeq): Elem = s.head

  tail(s: MSeq): MSeq = s.tail

  nonEmpty(s: MSeq): Boolean = not isEmpty(s)

  isEmpty(s: MSeq): Boolean = s.isEmpty

  //

  reverse(s: MSeq): MSeq = reverseRec(s, empty)

  length(s: MSeq): Int = lengthRec(s, 0)

  indexOf(s: MSeq, e: Elem): Int = indexOfRec(s, e, 0)

  contains(s: MSeq, e: Elem): Boolean = containsRec(s, e)

  at(s: MSeq, n: Int): Elem = atRec(s, n)

  //

  take(s: MSeq, n: Int): MSeq = reverse(takeRevRec(s, n, empty))

  drop(s: MSeq, n: Int): MSeq = dropRec(s, n)

  takeWhile(s: MSeq, p: (Elem -> Boolean)): MSeq = reverse(spanRevRec(s, p, taking = true, empty)._1)

  dropWhile(s: MSeq, p: (Elem -> Boolean)): MSeq = spanRevRec(s, p, taking = true, empty)._2

  splitAt(s: MSeq, n: Int): (MSeq, MSeq) = (take(s, n), drop(s, n))

  span(s: MSeq, p: (Elem -> Boolean)): (MSeq, MSeq) = {
    pair = spanRevRec(s, p, taking = true, empty)
    (reverse(pair._1), pair._2)
  }

  //

  appended(s: MSeq, e: Elem): MSeq = reverse(prepended(reverse(s), e))

  last(s: MSeq): Elem = head(reverse(s))

  concat(s0: MSeq, s1: MSeq): MSeq = reverseRec(reverse(s0), s1)

  slice(s: MSeq, from: Int, until: Int): MSeq = take(drop(s, from), until - from)

  //

  forall(s: MSeq, p: (Elem -> Boolean)): Boolean = forallRec(s, p)

  exists(s: MSeq, p: (Elem -> Boolean)): Boolean = existsRec(s, p)

  find(s: MSeq, p: (Elem -> Boolean)): Option[Elem] = findRec(s, p)

  filter(s: MSeq, p: (Elem -> Boolean)): MSeq = reverse(filterRevRec(s, p, empty))

  map0(s: MSeq, f: (Elem -> Elem)): MSeq = reverse(mapRevRec(s, f, empty))

  /**
   * <pre>
   * def foldLeft[B](z: B)(op: (B, A) -> B): B = {
   * . var result = z
   * . it = iterator
   * . while (it.hasNext) {
   * . . result = op(result, it.next())
   * . }
   * . result
   * }
   * </pre>
   */
  foldLeft0(s0: MSeq, s1: MSeq, f: ((MSeq, Elem) -> MSeq)): MSeq =
    foldLeftRec(s0, f, s1)

  //

  @tailrec
  reverseRec(s0: MSeq, s1: MSeq): MSeq =
    if isEmpty(s0)
    then s1
    else reverseRec(tail(s0), prepended(s1, head(s0)))

  @tailrec
  lengthRec(s: MSeq, n: Int): Int =
    if isEmpty(s)
    then n
    else lengthRec(tail(s), n + 1)

  @tailrec
  indexOfRec(s: MSeq, e: Elem, n: Int): Int =
    if isEmpty(s)
    then -1
    else if head(s) == e
    then n
    else indexOfRec(tail(s), e, n + 1)

  @tailrec
  containsRec(s: MSeq, e: Elem): Boolean =
    if isEmpty(s)
    then false
    else if head(s) == e
    then true
    else containsRec(tail(s), e)

  @tailrec
  atRec(s: MSeq, n: Int): Elem =
    if isEmpty(s) or n < 0
    then throw new IndexOutOfBoundsException()
    else if n == 0
    then head(s)
    else atRec(tail(s), n - 1)

  //

  @tailrec
  takeRevRec(s0: MSeq, n: Int, s1: MSeq): MSeq =
    if isEmpty(s0) or n <= 0
    then s1
    else takeRevRec(tail(s0), n - 1, prepended(s1, head(s0)))

  @tailrec
  dropRec(s: MSeq, n: Int): MSeq =
    if isEmpty(s) or n <= 0
    then s
    else dropRec(tail(s), n - 1)

  @tailrec
  spanRevRec(s0: MSeq, p: Elem -> Boolean, taking: Boolean, s1: MSeq): (MSeq, MSeq) =
    if isEmpty(s0) or not taking
    then (s1, s0)
    else {
      newTaking = p(head(s0))
      (newS1, newS0) =
        if newTaking
        then (prepended(s1, head(s0)), tail(s0))
        else (s1, s0)
      spanRevRec(newS0, p, newTaking, newS1)
    }

  //

  @tailrec
  forallRec(s: MSeq, p: Elem -> Boolean): Boolean =
    if isEmpty(s)
    then true
    else if not p(head(s))
    then false
    else forallRec(tail(s), p)

  @tailrec
  existsRec(s: MSeq, p: Elem -> Boolean): Boolean =
    if isEmpty(s)
    then false
    else if p(head(s))
    then true
    else existsRec(tail(s), p)

  @tailrec
  findRec(s: MSeq, p: Elem -> Boolean): Option[Elem] =
    if isEmpty(s)
    then None
    else if p(head(s))
    then Some(head(s))
    else findRec(tail(s), p)

  @tailrec
  filterRevRec(s0: MSeq, f: Elem -> Boolean, s1: MSeq): MSeq =
    if isEmpty(s0)
    then s1
    else {
      newS1 =
        if f(head(s0))
        then prepended(s1, head(s0))
        else s1
      filterRevRec(tail(s0), f, newS1)
    }

  @tailrec
  mapRevRec(s0: MSeq, f: Elem -> Elem, s1: MSeq): MSeq =
    if isEmpty(s0)
    then s1
    else mapRevRec(tail(s0), f, prepended(s1, f(head(s0))))

  @tailrec
  foldLeftRec(s0: MSeq, f: (MSeq, Elem) -> MSeq, s1: MSeq): MSeq =
    if isEmpty(s0)
    then s1
    else foldLeftRec(tail(s0), f, f(s1, head(s0)))

}

