package scopus.collection


+ scala.annotation.tailrec


* MSeqTranslator[T]() {

  foldLeftSeq[B](seq: Seq[T], initval: B, op: (B, T) -> B): B = {
    result = rec(seq, initval, op)

    @tailrec
    rec[B](seq: Seq[T], acc: B, op: (B, T) -> B): B =
      if seq.isEmpty
      then acc
      else rec(seq.tail, op(acc, seq.head), op)

    result
  }

  asMSeq(seq: Seq[T]): MSeq[T] = {
    result = Min().reverse(
      foldLeftSeq[MSeq[T]](seq, initval, op) )

    initval: MSeq[T] = Min().empty

    op(acc: MSeq[T], elem: T): MSeq[T] = Min().prepended(acc, elem)

    result
  }

  asSeq(mseq: MSeq[T]): Seq[T] = {
    result = Min().foldLeft(mseq, initval, op).reverse

    initval: Seq[T] = Seq()

    op(acc: Seq[T], elem: T): Seq[T] = acc.+:(elem)

    result
  }

}


* Min[T]() {

  empty: MSeq[T] = ESeq()

  prepended(s: MSeq[T], e: T): MSeq[T] = NESeq(e, s)

  head(s: MSeq[T]): T = s.head()

  tail(s: MSeq[T]): MSeq[T] = s.tail()

  nonEmpty(s: MSeq[T]): Boolean = not isEmpty(s)

  isEmpty(s: MSeq[T]): Boolean = s.isEmpty

  /* */

  foldLeftWhile[B](s: MSeq[T], initval: B, op: (B, T) -> B, cond: (B, T) -> Boolean): B =
    s.foldLeftWhile[B](initval, op, cond)

  foldLeft[B](s: MSeq[T], initval: B, op: (B, T) -> B): B = {
    cond(acc: B, elem: T): Boolean = true

    foldLeftWhile[B](s, initval, op, cond)
  }

  reverse(s: MSeq[T]): MSeq[T] = {
    init: MSeq[T] = empty

    op(acc: MSeq[T], elem: T): MSeq[T] = prepended(acc, elem)

    foldLeft(s, init, op)
  }

  length(s: MSeq[T]): Int = {
    initval: Int = 0

    op(acc: Int, elem: T): Int = acc + 1

    foldLeft(s, initval, op)
  }

  indexOf(s: MSeq[T], e: T): Int = {
    initval: (Int, Int) = (0, -1)

    op(acc: (Int, Int), elem: T): (Int, Int) =
      (acc._1 + 1,
        if elem == e then acc._1 else acc._2)

    cond(acc: (Int, Int), elem: T): Boolean = acc._2 == -1

    foldLeftWhile(s, initval, op, cond)._2
  }

  contains(s: MSeq[T], e: T): Boolean = {
    initval: Boolean = false

    op(acc: Boolean, elem: T): Boolean = elem == e

    cond(acc: Boolean, elem: T): Boolean = not acc

    foldLeftWhile(s, initval, op, cond)
  }

  at(s: MSeq[T], n: Int): T = {
    result = if isEmpty(s) or n < 0 or n >= length(s) then None.get else atNonEmpty(s, n)

    atNonEmpty(xs: MSeq[T], n: Int): T = {
      init: (T, Int) = (head(xs), -1)

      op(acc: (T, Int), elem: T): (T, Int) = (elem, acc._2 + 1)

      cond(acc: (T, Int), elem: T): Boolean = acc._2 < n

      foldLeftWhile(xs, init, op, cond)._1
    }

    result
  }

  /* */

  take(s: MSeq[T], n: Int): MSeq[T] = {
    result = reverse(rec(s, n, empty))

    @tailrec
    rec(s0: MSeq[T], n: Int, s1: MSeq[T]): MSeq[T] =
      if isEmpty(s0) or n <= 0
      then s1
      else rec(tail(s0), n - 1, prepended(s1, head(s0)))

    result
  }

  drop(s: MSeq[T], n: Int): MSeq[T] = {
    result = rec(s, n)

    @tailrec
    rec(s: MSeq[T], n: Int): MSeq[T] =
      if isEmpty(s) or n <= 0
      then s
      else rec(tail(s), n - 1)

    result
  }

  takeWhile(s: MSeq[T], p: (T -> Boolean)): MSeq[T] = reverse(spanRevRec(s, p, taking = true, empty)._1)

  dropWhile(s: MSeq[T], p: (T -> Boolean)): MSeq[T] = spanRevRec(s, p, taking = true, empty)._2

  splitAt(s: MSeq[T], n: Int): (MSeq[T], MSeq[T]) = (take(s, n), drop(s, n))

  span(s: MSeq[T], p: (T -> Boolean)): (MSeq[T], MSeq[T]) = {
    pair = spanRevRec(s, p, taking = true, empty)
    (reverse(pair._1), pair._2)
  }

  /* */

  appended(s: MSeq[T], e: T): MSeq[T] = reverse(prepended(reverse(s), e))

  last(s: MSeq[T]): T = head(reverse(s))

  concat(s0: MSeq[T], s1: MSeq[T]): MSeq[T] = {
    init: MSeq[T] = s1

    op(acc: MSeq[T], elem: T): MSeq[T] = prepended(acc, elem)

    s0rev = reverse(s0)

    foldLeft(s0rev, init, op)
  }

  slice(s: MSeq[T], from: Int, until: Int): MSeq[T] = take(drop(s, from), until - from)

  /* */

  forall(s: MSeq[T], p: (T -> Boolean)): Boolean = {
    result = rec(s, p)

    @tailrec
    rec(s: MSeq[T], p: T -> Boolean): Boolean =
      if isEmpty(s)
      then true
      else if not p(head(s))
      then false
      else rec(tail(s), p)

    result
  }

  exists(s: MSeq[T], p: (T -> Boolean)): Boolean = {
    result = rec(s, p)

    @tailrec
    rec(s: MSeq[T], p: T -> Boolean): Boolean =
      if isEmpty(s)
      then false
      else if p(head(s))
      then true
      else rec(tail(s), p)

    result
  }

  find(s: MSeq[T], p: (T -> Boolean)): Option[T] = {
    result = rec(s, p)

    @tailrec
    rec(s: MSeq[T], p: T -> Boolean): Option[T] =
      if isEmpty(s)
      then None
      else if p(head(s))
      then Some(head(s))
      else rec(tail(s), p)

    result
  }

  filter(s: MSeq[T], p: (T -> Boolean)): MSeq[T] = {
    result = reverse(rec(s, p, empty))

    @tailrec
    rec(s0: MSeq[T], f: T -> Boolean, s1: MSeq[T]): MSeq[T] =
      if isEmpty(s0)
      then s1
      else {
        newS1 =
          if f(head(s0))
          then prepended(s1, head(s0))
          else s1
        rec(tail(s0), f, newS1)
      }

    result
  }

  map0(s: MSeq[T], f: (T -> T)): MSeq[T] = {
    result = reverse(rec(s, f, empty))

    @tailrec
    rec(s0: MSeq[T], f: T -> T, s1: MSeq[T]): MSeq[T] =
      if isEmpty(s0)
      then s1
      else rec(tail(s0), f, prepended(s1, f(head(s0))))

    result
  }

  /**
   * <pre>
   * def foldLeft[B](z: B)(op: (B, A) -> B): B = {
   * . var result = z
   * . it = iterator
   * . while (it.hasNext) {
   * . . result = op(result, it.next())
   * . }
   * . result
   * }
   * </pre>
   */
  foldLeft0(mseq: MSeq[T]): (MSeq[T], ((MSeq[T], T) -> MSeq[T])) -> MSeq[T] = {
    result = (acc: MSeq[T], op: ((MSeq[T], T) -> MSeq[T])) -> rec(mseq, acc, op)

    @tailrec
    rec(mseq: MSeq[T], acc: MSeq[T], op: (MSeq[T], T) -> MSeq[T]): MSeq[T] =
      if isEmpty(mseq)
      then acc
      else rec(tail(mseq), op(acc, head(mseq)), op)

    result
   }

  /* */

  @tailrec
  @private
  spanRevRec(s0: MSeq[T], p: T -> Boolean, taking: Boolean, s1: MSeq[T]): (MSeq[T], MSeq[T]) =
    if isEmpty(s0) or not taking
    then (s1, s0)
    else {
      newTaking = p(head(s0))
      (newS1, newS0) =
        if newTaking
        then (prepended(s1, head(s0)), tail(s0))
        else (s1, s0)
      spanRevRec(newS0, p, newTaking, newS1)
    }

}

